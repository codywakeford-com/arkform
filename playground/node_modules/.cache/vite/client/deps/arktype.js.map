{
  "version": 3,
  "sources": ["../../../../../../../../node_modules/@ark/util/out/arrays.js", "../../../../../../../../node_modules/@ark/util/out/domain.js", "../../../../../../../../node_modules/@ark/util/out/errors.js", "../../../../../../../../node_modules/@ark/util/out/flatMorph.js", "../../../../../../../../node_modules/@ark/util/out/records.js", "../../../../../../../../node_modules/@ark/util/out/objectKinds.js", "../../../../../../../../node_modules/@ark/util/out/clone.js", "../../../../../../../../node_modules/@ark/util/out/functions.js", "../../../../../../../../node_modules/@ark/util/out/generics.js", "../../../../../../../../node_modules/@ark/util/out/hkt.js", "../../../../../../../../node_modules/@ark/util/out/isomorphic.js", "../../../../../../../../node_modules/@ark/util/out/strings.js", "../../../../../../../../node_modules/@ark/util/out/numbers.js", "../../../../../../../../node_modules/@ark/util/out/registry.js", "../../../../../../../../node_modules/@ark/util/out/primitive.js", "../../../../../../../../node_modules/@ark/util/out/serialize.js", "../../../../../../../../node_modules/@ark/util/out/path.js", "../../../../../../../../node_modules/@ark/util/out/scanner.js", "../../../../../../../../node_modules/@ark/util/out/traits.js", "../../../../../../../../node_modules/@ark/schema/out/shared/registry.js", "../../../../../../../../node_modules/@ark/schema/out/shared/compile.js", "../../../../../../../../node_modules/@ark/schema/out/shared/utils.js", "../../../../../../../../node_modules/@ark/schema/out/shared/implement.js", "../../../../../../../../node_modules/@ark/schema/out/shared/toJsonSchema.js", "../../../../../../../../node_modules/@ark/schema/out/config.js", "../../../../../../../../node_modules/@ark/schema/out/shared/errors.js", "../../../../../../../../node_modules/@ark/schema/out/shared/traversal.js", "../../../../../../../../node_modules/@ark/schema/out/node.js", "../../../../../../../../node_modules/@ark/schema/out/shared/disjoint.js", "../../../../../../../../node_modules/@ark/schema/out/shared/intersections.js", "../../../../../../../../node_modules/@ark/schema/out/constraint.js", "../../../../../../../../node_modules/@ark/schema/out/generic.js", "../../../../../../../../node_modules/@ark/schema/out/predicate.js", "../../../../../../../../node_modules/@ark/schema/out/refinements/divisor.js", "../../../../../../../../node_modules/@ark/schema/out/refinements/range.js", "../../../../../../../../node_modules/@ark/schema/out/refinements/after.js", "../../../../../../../../node_modules/@ark/schema/out/refinements/before.js", "../../../../../../../../node_modules/@ark/schema/out/refinements/exactLength.js", "../../../../../../../../node_modules/@ark/schema/out/refinements/max.js", "../../../../../../../../node_modules/@ark/schema/out/refinements/maxLength.js", "../../../../../../../../node_modules/@ark/schema/out/refinements/min.js", "../../../../../../../../node_modules/@ark/schema/out/refinements/minLength.js", "../../../../../../../../node_modules/@ark/schema/out/refinements/kinds.js", "../../../../../../../../node_modules/@ark/schema/out/refinements/pattern.js", "../../../../../../../../node_modules/@ark/schema/out/parse.js", "../../../../../../../../node_modules/@ark/schema/out/structure/prop.js", "../../../../../../../../node_modules/@ark/schema/out/structure/optional.js", "../../../../../../../../node_modules/@ark/schema/out/roots/root.js", "../../../../../../../../node_modules/@ark/schema/out/roots/utils.js", "../../../../../../../../node_modules/@ark/schema/out/roots/alias.js", "../../../../../../../../node_modules/@ark/schema/out/roots/basis.js", "../../../../../../../../node_modules/@ark/schema/out/roots/domain.js", "../../../../../../../../node_modules/@ark/schema/out/roots/intersection.js", "../../../../../../../../node_modules/@ark/schema/out/roots/morph.js", "../../../../../../../../node_modules/@ark/schema/out/roots/proto.js", "../../../../../../../../node_modules/@ark/schema/out/roots/union.js", "../../../../../../../../node_modules/@ark/schema/out/roots/unit.js", "../../../../../../../../node_modules/@ark/schema/out/structure/index.js", "../../../../../../../../node_modules/@ark/schema/out/structure/required.js", "../../../../../../../../node_modules/@ark/schema/out/structure/sequence.js", "../../../../../../../../node_modules/@ark/schema/out/structure/structure.js", "../../../../../../../../node_modules/@ark/schema/out/kinds.js", "../../../../../../../../node_modules/@ark/schema/out/module.js", "../../../../../../../../node_modules/@ark/schema/out/scope.js", "../../../../../../../../node_modules/@ark/schema/out/structure/shared.js", "../../../../../../../../node_modules/@ark/schema/out/intrinsic.js", "../../../../../../../../node_modules/arktype/out/config.js", "../../../../../../../../node_modules/arktype/out/parser/shift/operand/date.js", "../../../../../../../../node_modules/arktype/out/parser/shift/operand/enclosed.js", "../../../../../../../../node_modules/arktype/out/parser/ast/validate.js", "../../../../../../../../node_modules/arktype/out/parser/reduce/shared.js", "../../../../../../../../node_modules/arktype/out/parser/shift/operand/genericArgs.js", "../../../../../../../../node_modules/arktype/out/parser/shift/operand/unenclosed.js", "../../../../../../../../node_modules/arktype/out/parser/shift/operand/operand.js", "../../../../../../../../node_modules/arktype/out/parser/shift/scanner.js", "../../../../../../../../node_modules/arktype/out/parser/shift/operator/bounds.js", "../../../../../../../../node_modules/arktype/out/parser/shift/operator/brand.js", "../../../../../../../../node_modules/arktype/out/parser/shift/operator/divisor.js", "../../../../../../../../node_modules/arktype/out/parser/shift/operator/operator.js", "../../../../../../../../node_modules/arktype/out/parser/shift/operator/default.js", "../../../../../../../../node_modules/arktype/out/parser/string.js", "../../../../../../../../node_modules/arktype/out/parser/reduce/dynamic.js", "../../../../../../../../node_modules/arktype/out/generic.js", "../../../../../../../../node_modules/arktype/out/match.js", "../../../../../../../../node_modules/arktype/out/parser/property.js", "../../../../../../../../node_modules/arktype/out/parser/objectLiteral.js", "../../../../../../../../node_modules/arktype/out/parser/tupleExpressions.js", "../../../../../../../../node_modules/arktype/out/parser/tupleLiteral.js", "../../../../../../../../node_modules/arktype/out/parser/definition.js", "../../../../../../../../node_modules/arktype/out/type.js", "../../../../../../../../node_modules/arktype/out/scope.js", "../../../../../../../../node_modules/arktype/out/keywords/builtins.js", "../../../../../../../../node_modules/arktype/out/keywords/Array.js", "../../../../../../../../node_modules/arktype/out/keywords/FormData.js", "../../../../../../../../node_modules/arktype/out/keywords/TypedArray.js", "../../../../../../../../node_modules/arktype/out/keywords/constructors.js", "../../../../../../../../node_modules/arktype/out/keywords/number.js", "../../../../../../../../node_modules/arktype/out/keywords/string.js", "../../../../../../../../node_modules/arktype/out/keywords/ts.js", "../../../../../../../../node_modules/arktype/out/keywords/keywords.js", "../../../../../../../../node_modules/arktype/out/module.js"],
  "sourcesContent": ["/**\n * Extracts duplicated elements and their indices from an array, returning them.\n *\n * Note that given `a === b && b === c`, then `c === a` must be `true` for this to give accurate results.\n *\n * @param arr The array to extract duplicate elements from.\n */ export const getDuplicatesOf = (arr, opts) => {\n    const isEqual = opts?.isEqual ?? ((l, r) => l === r);\n    const elementFirstSeenIndx = new Map();\n    const duplicates = [];\n    for (const [indx, element] of arr.entries()) {\n        const duplicatesIndx = duplicates.findIndex(duplicate => isEqual(duplicate.element, element));\n        if (duplicatesIndx !== -1) {\n            // This is at least the third occurence of an item equal to `element`,\n            // so add this index to the list of indices where the element is duplicated.\n            duplicates[duplicatesIndx].indices.push(indx);\n            continue;\n        }\n        // At this point, we know this is either the first\n        // or second occurence of an item equal to `element`...\n        let found = false;\n        for (const [existingElement, firstSeenIndx] of elementFirstSeenIndx) {\n            if (isEqual(element, existingElement)) {\n                // This is the second occurence of an item equal to `element`,\n                // so store it as a duplicate.\n                found = true;\n                duplicates.push({\n                    element: existingElement,\n                    indices: [firstSeenIndx, indx]\n                });\n            }\n        }\n        if (!found) {\n            // We haven't seen this element before,\n            // so just store the index it was first seen\n            elementFirstSeenIndx.set(element, indx);\n        }\n    }\n    return duplicates;\n};\nexport const join = (segments, delimiter) => segments.join(delimiter);\nexport const getPath = (root, path) => {\n    let result = root;\n    for (const segment of path) {\n        if (typeof result !== \"object\" || result === null)\n            return undefined;\n        result = result[segment];\n    }\n    return result;\n};\nexport const intersectUniqueLists = (l, r) => {\n    const intersection = [...l];\n    for (const item of r)\n        if (!l.includes(item))\n            intersection.push(item);\n    return intersection;\n};\nexport const liftArray = (data) => (Array.isArray(data) ? data : [data]);\n/**\n * Splits an array into two arrays based on the result of a predicate\n *\n * @param predicate - The guard function used to determine which items to include.\n * @returns A tuple containing two arrays:\n * \t\t\t\t- the first includes items for which `predicate` returns true\n * \t\t\t\t- the second includes items for which `predicate` returns false\n *\n * @example\n * const list = [1, \"2\", \"3\", 4, 5];\n * const [numbers, strings] = spliterate(list, (x) => typeof x === \"number\");\n * // Type: number[]\n * // Output: [1, 4, 5]\n * console.log(evens);\n * // Type: string[]\n * // Output: [\"2\", \"3\"]\n * console.log(odds);\n */\nexport const spliterate = (arr, predicate) => {\n    const result = [[], []];\n    for (const item of arr) {\n        if (predicate(item))\n            result[0].push(item);\n        else\n            result[1].push(item);\n    }\n    return result;\n};\nexport const ReadonlyArray = Array;\nexport const includes = (array, element) => array.includes(element);\nexport const range = (length, offset = 0) => [...new Array(length)].map((_, i) => i + offset);\n/**\n * Adds a value or array to an array, returning the concatenated result\n */\nexport const append = (to, value, opts) => {\n    if (to === undefined) {\n        return (value === undefined ? []\n            : Array.isArray(value) ? value\n                : [value]);\n    }\n    if (opts?.prepend) {\n        if (Array.isArray(value))\n            to.unshift(...value);\n        else\n            to.unshift(value);\n    }\n    else {\n        if (Array.isArray(value))\n            to.push(...value);\n        else\n            to.push(value);\n    }\n    return to;\n};\n/**\n * Concatenates an element or list with a readonly list\n */\nexport const conflatenate = (to, elementOrList) => {\n    if (elementOrList === undefined || elementOrList === null)\n        return to ?? [];\n    if (to === undefined || to === null)\n        return liftArray(elementOrList);\n    return to.concat(elementOrList);\n};\n/**\n * Concatenates a variadic list of elements or lists with a readonly list\n */\nexport const conflatenateAll = (...elementsOrLists) => elementsOrLists.reduce(conflatenate, []);\n/**\n * Appends a value or concatenates an array to an array if it is not already included, returning the array\n */\nexport const appendUnique = (to, value, opts) => {\n    if (to === undefined)\n        return Array.isArray(value) ? value : [value];\n    const isEqual = opts?.isEqual ?? ((l, r) => l === r);\n    for (const v of liftArray(value))\n        if (!to.some(existing => isEqual(existing, v)))\n            to.push(v);\n    return to;\n};\nexport const groupBy = (array, discriminant) => array.reduce((result, item) => {\n    const key = item[discriminant];\n    result[key] = append(result[key], item);\n    return result;\n}, {});\nexport const arrayEquals = (l, r, opts) => l.length === r.length &&\n    l.every(opts?.isEqual ?\n        (lItem, i) => opts.isEqual(lItem, r[i])\n        : (lItem, i) => lItem === r[i]);\n", "export const hasDomain = (data, kind) => domainOf(data) === kind;\nexport const domainOf = (data) => {\n    const builtinType = typeof data;\n    return (builtinType === \"object\" ?\n        data === null ?\n            \"null\"\n            : \"object\"\n        : builtinType === \"function\" ? \"object\"\n            : builtinType);\n};\n/** Each domain's completion for the phrase \"must be _____\" */\nexport const domainDescriptions = {\n    boolean: \"boolean\",\n    null: \"null\",\n    undefined: \"undefined\",\n    bigint: \"a bigint\",\n    number: \"a number\",\n    object: \"an object\",\n    string: \"a string\",\n    symbol: \"a symbol\"\n};\nexport const jsTypeOfDescriptions = {\n    ...domainDescriptions,\n    function: \"a function\"\n};\n", "export class InternalArktypeError extends Error {\n}\nexport const throwInternalError = message => throwError(message, InternalArktypeError);\nexport const throwError = (message, ctor = Error) => {\n    throw new ctor(message);\n};\nexport class ParseError extends Error {\n    name = \"ParseError\";\n}\nexport const throwParseError = message => throwError(message, ParseError);\n/**\n *  TypeScript won't suggest strings beginning with a space as properties.\n *  Useful for symbol-like string properties.\n */\nexport const noSuggest = (s) => ` ${s}`;\n/** \"Hair Space\" character, used  as a non-rendered sentinel for an error message string:\n *  https://www.compart.com/en/unicode/U+200A\n */\nexport const zeroWidthSpace = \" \";\n", "import { append } from \"./arrays.js\";\nexport const flatMorph = (o, flatMapEntry) => {\n    const result = {};\n    const inputIsArray = Array.isArray(o);\n    let outputShouldBeArray = false;\n    for (const [i, entry] of Object.entries(o).entries()) {\n        const mapped = inputIsArray ? flatMapEntry(i, entry[1]) : flatMapEntry(...entry, i);\n        outputShouldBeArray ||= typeof mapped[0] === \"number\";\n        const flattenedEntries = Array.isArray(mapped[0]) || mapped.length === 0 ?\n            // if we have an empty array (for filtering) or an array with\n            // another array as its first element, treat it as a list\n            mapped\n            // otherwise, it should be a single entry, so nest it in a tuple\n            // so it doesn't get spread when the result is flattened\n            : [mapped];\n        for (const [k, v] of flattenedEntries) {\n            if (typeof k === \"object\")\n                result[k.group] = append(result[k.group], v);\n            else\n                result[k] = v;\n        }\n    }\n    return outputShouldBeArray ? Object.values(result) : result;\n};\n", "import { noSuggest } from \"./errors.js\";\nimport { flatMorph } from \"./flatMorph.js\";\n/**\n * Object.entries wrapper providing narrowed types for objects with known sets\n * of keys, e.g. those defined internally as configs\n */\nexport const entriesOf = Object.entries;\nexport const fromEntries = (entries) => Object.fromEntries(entries);\nexport const keysOf = (o) => Object.keys(o);\nexport const isKeyOf = (k, o) => k in o;\nexport const hasKey = (o, k) => k in o;\n// must be defined this way to avoid https://github.com/microsoft/TypeScript/issues/55049\nexport const hasDefinedKey = (o, k) => o[k] !== undefined;\nexport const InnerDynamicBase = class {\n};\nexport class DynamicBase {\n    constructor(properties) {\n        Object.assign(this, properties);\n    }\n}\nexport const NoopBase = class {\n};\n/** @ts-ignore (needed to extend `t`) **/\nexport class CastableBase extends NoopBase {\n}\nexport const splitByKeys = (o, leftKeys) => {\n    const l = {};\n    const r = {};\n    let k;\n    for (k in o) {\n        if (k in leftKeys)\n            l[k] = o[k];\n        else\n            r[k] = o[k];\n    }\n    return [l, r];\n};\nexport const pick = (o, keys) => splitByKeys(o, keys)[0];\nexport const omit = (o, keys) => splitByKeys(o, keys)[1];\nexport const isEmptyObject = (o) => Object.keys(o).length === 0;\nexport const stringAndSymbolicEntriesOf = (o) => [\n    ...Object.entries(o),\n    ...Object.getOwnPropertySymbols(o).map(k => [k, o[k]])\n];\n/** Like Object.assign, but it will preserve getters instead of evaluating them. */\nexport const defineProperties = (base, merged) => \n// declared like this to avoid https://github.com/microsoft/TypeScript/issues/55049\nObject.defineProperties(base, Object.getOwnPropertyDescriptors(merged));\n/** Copies enumerable keys of o to a new object in alphabetical order */\nexport const withAlphabetizedKeys = (o) => {\n    const keys = Object.keys(o).sort();\n    const result = {};\n    for (let i = 0; i < keys.length; i++)\n        result[keys[i]] = o[keys[i]];\n    return result;\n};\nexport const invert = (t) => flatMorph(t, (k, v) => [v, k]);\nexport const unset = noSuggest(\"represents an uninitialized value\");\nexport const enumValues = (tsEnum) => Object.values(tsEnum).filter(v => {\n    if (typeof v === \"number\")\n        return true;\n    return typeof tsEnum[v] !== \"number\";\n});\n", "import { domainOf } from \"./domain.js\";\nimport { isKeyOf } from \"./records.js\";\n// ECMAScript Objects\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\nexport const ecmascriptConstructors = {\n    Array,\n    Boolean,\n    Date,\n    Error,\n    Function,\n    Map,\n    Number,\n    Promise,\n    RegExp,\n    Set,\n    String,\n    WeakMap,\n    WeakSet\n};\n/** Node18 */\nexport const FileConstructor = globalThis.File ?? Blob;\n// Platform APIs\n// See https://developer.mozilla.org/en-US/docs/Web/API\n// Must be implemented in Node etc. as well as the browser to include here\nexport const platformConstructors = {\n    ArrayBuffer,\n    Blob,\n    File: FileConstructor,\n    FormData,\n    Headers,\n    Request,\n    Response,\n    URL\n};\nexport const typedArrayConstructors = {\n    Int8Array,\n    Uint8Array,\n    Uint8ClampedArray,\n    Int16Array,\n    Uint16Array,\n    Int32Array,\n    Uint32Array,\n    Float32Array,\n    Float64Array,\n    BigInt64Array,\n    BigUint64Array\n};\n// Built-in object constructors based on a subset of:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\nexport const builtinConstructors = {\n    ...ecmascriptConstructors,\n    ...platformConstructors,\n    ...typedArrayConstructors,\n    String,\n    Number,\n    Boolean\n};\nexport const objectKindOf = (data) => {\n    let prototype = Object.getPrototypeOf(data);\n    while (prototype?.constructor &&\n        (!isKeyOf(prototype.constructor.name, builtinConstructors) ||\n            !(data instanceof builtinConstructors[prototype.constructor.name])))\n        prototype = Object.getPrototypeOf(prototype);\n    const name = prototype?.constructor?.name;\n    if (name === undefined || name === \"Object\")\n        return undefined;\n    return name;\n};\nexport const objectKindOrDomainOf = (data) => (typeof data === \"object\" && data !== null ?\n    (objectKindOf(data) ?? \"object\")\n    : domainOf(data));\nexport const hasObjectKind = (data, kind) => objectKindOf(data) === kind;\nexport const isArray = Array.isArray;\nexport const ecmascriptDescriptions = {\n    Array: \"an array\",\n    Function: \"a function\",\n    Date: \"a Date\",\n    RegExp: \"a RegExp\",\n    Error: \"an Error\",\n    Map: \"a Map\",\n    Set: \"a Set\",\n    String: \"a String object\",\n    Number: \"a Number object\",\n    Boolean: \"a Boolean object\",\n    Promise: \"a Promise\",\n    WeakMap: \"a WeakMap\",\n    WeakSet: \"a WeakSet\"\n};\nexport const platformDescriptions = {\n    ArrayBuffer: \"an ArrayBuffer instance\",\n    Blob: \"a Blob instance\",\n    File: \"a File instance\",\n    FormData: \"a FormData instance\",\n    Headers: \"a Headers instance\",\n    Request: \"a Request instance\",\n    Response: \"a Response instance\",\n    URL: \"a URL instance\"\n};\nexport const typedArrayDescriptions = {\n    Int8Array: \"an Int8Array\",\n    Uint8Array: \"a Uint8Array\",\n    Uint8ClampedArray: \"a Uint8ClampedArray\",\n    Int16Array: \"an Int16Array\",\n    Uint16Array: \"a Uint16Array\",\n    Int32Array: \"an Int32Array\",\n    Uint32Array: \"a Uint32Array\",\n    Float32Array: \"a Float32Array\",\n    Float64Array: \"a Float64Array\",\n    BigInt64Array: \"a BigInt64Array\",\n    BigUint64Array: \"a BigUint64Array\"\n};\n/** Each defaultObjectKind's completion for the phrase \"must be _____\" */\nexport const objectKindDescriptions = {\n    ...ecmascriptDescriptions,\n    ...platformDescriptions,\n    ...typedArrayDescriptions\n};\n/**\n * this will only return an object kind if it's the root constructor\n * example TypeError would return null not 'Error'\n **/\nexport const getBuiltinNameOfConstructor = (ctor) => {\n    const constructorName = Object(ctor).name ?? null;\n    return (constructorName &&\n        isKeyOf(constructorName, builtinConstructors) &&\n        builtinConstructors[constructorName] === ctor) ?\n        constructorName\n        : null;\n};\n/**\n * Returns an array of constructors for all ancestors (i.e., prototypes) of a given object.\n */\nexport const ancestorsOf = (o) => {\n    let proto = Object.getPrototypeOf(o);\n    const result = [];\n    while (proto !== null) {\n        result.push(proto.constructor);\n        proto = Object.getPrototypeOf(proto);\n    }\n    return result;\n};\nexport const constructorExtends = (ctor, base) => {\n    let current = ctor.prototype;\n    while (current !== null) {\n        if (current === base.prototype)\n            return true;\n        current = Object.getPrototypeOf(current);\n    }\n    return false;\n};\n", "import { getBuiltinNameOfConstructor } from \"./objectKinds.js\";\n/** Shallowly copy the properties of the object. */\nexport const shallowClone = input => _clone(input, null);\n/** Deeply copy the properties of the a non-subclassed Object, Array or Date.*/\nexport const deepClone = (input) => _clone(input, new Map());\nconst _clone = (input, seen) => {\n    if (typeof input !== \"object\" || input === null)\n        return input;\n    if (seen?.has(input))\n        return seen.get(input);\n    const builtinConstructorName = getBuiltinNameOfConstructor(input.constructor);\n    if (builtinConstructorName === \"Date\")\n        return new Date(input.getTime());\n    // we don't try and clone other prototypes here since this we can't guarantee arrow functions attached to the object\n    // are rebound in case they reference `this` (see https://x.com/colinhacks/status/1818422039210049985)\n    if (builtinConstructorName && builtinConstructorName !== \"Array\")\n        return input;\n    const cloned = Array.isArray(input) ?\n        input.slice()\n        : Object.create(Object.getPrototypeOf(input));\n    const propertyDescriptors = Object.getOwnPropertyDescriptors(input);\n    if (seen) {\n        seen.set(input, cloned);\n        for (const k in propertyDescriptors) {\n            const desc = propertyDescriptors[k];\n            if (\"get\" in desc || \"set\" in desc)\n                continue;\n            desc.value = _clone(desc.value, seen);\n        }\n    }\n    Object.defineProperties(cloned, propertyDescriptors);\n    return cloned;\n};\n", "import { throwInternalError } from \"./errors.js\";\nimport { unset } from \"./records.js\";\nexport const cached = (thunk) => {\n    let result = unset;\n    return () => (result === unset ? (result = thunk()) : result);\n};\nexport const isThunk = (value) => typeof value === \"function\" && value.length === 0;\nexport const tryCatch = (fn, onError) => {\n    try {\n        return fn();\n    }\n    catch (e) {\n        return onError?.(e);\n    }\n};\nexport const DynamicFunction = class extends Function {\n    constructor(...args) {\n        const params = args.slice(0, -1);\n        const body = args.at(-1);\n        try {\n            super(...params, body);\n        }\n        catch (e) {\n            return throwInternalError(`Encountered an unexpected error while compiling your definition:\n                Message: ${e} \n                Source: (${args.slice(0, -1)}) => {\n                    ${args.at(-1)}\n                }`);\n        }\n    }\n};\nexport class Callable {\n    constructor(fn, ...[opts]) {\n        return Object.assign(Object.setPrototypeOf(fn.bind(opts?.bind ?? this), this.constructor.prototype), opts?.attach);\n    }\n}\n/**\n * Checks if the environment has Content Security Policy (CSP) enabled,\n * preventing JIT-optimized code from being compiled via new Function().\n *\n * @returns `true` if a function created using new Function() can be\n * successfully invoked in the environment, `false` otherwise.\n *\n * The result is cached for subsequent invocations.\n */\nexport const envHasCsp = cached(() => {\n    try {\n        return new Function(\"return false\")();\n    }\n    catch {\n        return true;\n    }\n});\n", "import { noSuggest } from \"./errors.js\";\nexport const brand = noSuggest(\"brand\");\nexport const narrow = (t) => t;\n/** primitive key used to represent an inferred type at compile-time */\nexport const inferred = noSuggest(\"arkInferred\");\n", "import { noSuggest } from \"./errors.js\";\nconst args = noSuggest(\"args\");\nexport class Hkt {\n    constructor() { }\n}\n", "// based on the util of the same name in @ark/fs\n// isolated here for use with registry\n/** get a CJS/ESM compatible string representing the current file */\nconst fileName = () => {\n    try {\n        const error = new Error();\n        const stackLine = error.stack?.split(\"\\n\")[2]?.trim() || \"\"; // [1]=this func, [2]=caller\n        const filePath = stackLine.match(/\\(?(.+?)(?::\\d+:\\d+)?\\)?$/)?.[1] || \"unknown\";\n        return filePath.replace(/^file:\\/\\//, \"\");\n    }\n    catch {\n        return \"unknown\";\n    }\n};\nconst env = globalThis.process?.env ?? {};\nexport const isomorphic = {\n    fileName,\n    env\n};\n", "export const capitalize = (s) => (s[0].toUpperCase() + s.slice(1));\nexport const uncapitalize = (s) => (s[0].toLowerCase() + s.slice(1));\nexport const anchoredRegex = (regex) => new RegExp(anchoredSource(regex), typeof regex === \"string\" ? \"\" : regex.flags);\nexport const deanchoredRegex = (regex) => new RegExp(deanchoredSource(regex), typeof regex === \"string\" ? \"\" : regex.flags);\nexport const anchoredSource = (regex) => {\n    const source = typeof regex === \"string\" ? regex : regex.source;\n    return `^(?:${source})$`;\n};\nexport const deanchoredSource = (regex) => {\n    const source = typeof regex === \"string\" ? regex : regex.source;\n    if (source.startsWith(\"^(?:\") && source.endsWith(\")$\"))\n        return source.slice(4, -2);\n    return source.slice(source[0] === \"^\" ? 1 : 0, source.at(-1) === \"$\" ? -1 : undefined);\n};\nexport const RegexPatterns = {\n    negativeLookahead: (pattern) => `(?!${pattern})`,\n    nonCapturingGroup: (pattern) => `(?:${pattern})`\n};\nexport const escapeChar = \"\\\\\";\nexport const whitespaceChars = {\n    \" \": 1,\n    \"\\n\": 1,\n    \"\\t\": 1\n};\nexport const emojiToUnicode = (emoji) => emoji\n    .split(\"\")\n    .map(char => {\n    const codePoint = char.codePointAt(0);\n    return codePoint ? `\\\\u${codePoint.toString(16).padStart(4, \"0\")}` : \"\";\n})\n    .join(\"\");\n", "import { throwParseError } from \"./errors.js\";\nimport { anchoredRegex, RegexPatterns } from \"./strings.js\";\n/*\n * The goal of the number literal and bigint literal regular expressions is to:\n *\n *   1. Ensure definitions form a bijection with the values they represent.\n *   2. Attempt to mirror TypeScript's own format for stringification of numeric\n *      values such that the regex should match a given definition if any only if\n *      a precise literal type will be inferred (in TS4.8+).\n */\nconst anchoredNegativeZeroPattern = /^-0\\.?0*$/.source;\nconst positiveIntegerPattern = /[1-9]\\d*/.source;\nconst looseDecimalPattern = /\\.\\d+/.source;\nconst strictDecimalPattern = /\\.\\d*[1-9]/.source;\nconst createNumberMatcher = (opts) => anchoredRegex(RegexPatterns.negativeLookahead(anchoredNegativeZeroPattern) +\n    RegexPatterns.nonCapturingGroup(\"-?\" +\n        RegexPatterns.nonCapturingGroup(RegexPatterns.nonCapturingGroup(\"0|\" + positiveIntegerPattern) +\n            RegexPatterns.nonCapturingGroup(opts.decimalPattern) +\n            \"?\") +\n        (opts.allowDecimalOnly ? \"|\" + opts.decimalPattern : \"\") +\n        \"?\"));\n/**\n *  Matches a well-formatted numeric expression according to the following rules:\n *    1. Must include an integer portion (i.e. '.321' must be written as '0.321')\n *    2. The first digit of the value must not be 0, unless the entire integer portion is 0\n *    3. If the value includes a decimal, its last digit may not be 0\n *    4. The value may not be \"-0\"\n */\nexport const wellFormedNumberMatcher = createNumberMatcher({\n    decimalPattern: strictDecimalPattern,\n    allowDecimalOnly: false\n});\nexport const isWellFormedNumber = wellFormedNumberMatcher.test.bind(wellFormedNumberMatcher);\n/**\n * Similar to wellFormedNumber but more permissive in the following ways:\n *\n *  - Allows numbers without an integer portion like \".5\" (well-formed equivalent is \"0.5\")\n *  - Allows decimals with trailing zeroes like \"0.10\" (well-formed equivalent is \"0.1\")\n */\nexport const numericStringMatcher = createNumberMatcher({\n    decimalPattern: looseDecimalPattern,\n    allowDecimalOnly: true\n});\nexport const isNumericString = numericStringMatcher.test.bind(numericStringMatcher);\nexport const numberLikeMatcher = /^-?\\d*\\.?\\d*$/;\nconst isNumberLike = (s) => s.length !== 0 && numberLikeMatcher.test(s);\n/**\n *  Matches a well-formatted integer according to the following rules:\n *    1. must begin with an integer, the first digit of which cannot be 0 unless the entire value is 0\n *    2. The value may not be \"-0\"\n */\nexport const wellFormedIntegerMatcher = anchoredRegex(RegexPatterns.negativeLookahead(\"^-0$\") +\n    \"-?\" +\n    RegexPatterns.nonCapturingGroup(RegexPatterns.nonCapturingGroup(\"0|\" + positiveIntegerPattern)));\nexport const isWellFormedInteger = wellFormedIntegerMatcher.test.bind(wellFormedIntegerMatcher);\nexport const integerLikeMatcher = /^-?\\d+$/;\nconst isIntegerLike = integerLikeMatcher.test.bind(integerLikeMatcher);\nconst numericLiteralDescriptions = {\n    number: \"a number\",\n    bigint: \"a bigint\",\n    integer: \"an integer\"\n};\nexport const writeMalformedNumericLiteralMessage = (def, kind) => `'${def}' was parsed as ${numericLiteralDescriptions[kind]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`;\nconst isWellFormed = (def, kind) => kind === \"number\" ? isWellFormedNumber(def) : isWellFormedInteger(def);\nconst parseKind = (def, kind) => kind === \"number\" ? Number(def) : Number.parseInt(def);\nconst isKindLike = (def, kind) => kind === \"number\" ? isNumberLike(def) : isIntegerLike(def);\nexport const tryParseNumber = (token, options) => parseNumeric(token, \"number\", options);\nexport const tryParseWellFormedNumber = (token, options) => parseNumeric(token, \"number\", { ...options, strict: true });\nexport const tryParseInteger = (token, options) => parseNumeric(token, \"integer\", options);\nconst parseNumeric = (token, kind, options) => {\n    const value = parseKind(token, kind);\n    if (!Number.isNaN(value)) {\n        if (isKindLike(token, kind)) {\n            if (options?.strict) {\n                return isWellFormed(token, kind) ? value : (throwParseError(writeMalformedNumericLiteralMessage(token, kind)));\n            }\n            return value;\n        }\n    }\n    return (options?.errorOnFail ?\n        throwParseError(options?.errorOnFail === true ?\n            `Failed to parse ${numericLiteralDescriptions[kind]} from '${token}'`\n            : options?.errorOnFail)\n        : undefined);\n};\nexport const tryParseWellFormedBigint = (def) => {\n    if (def[def.length - 1] !== \"n\")\n        return;\n    const maybeIntegerLiteral = def.slice(0, -1);\n    let value;\n    try {\n        value = BigInt(maybeIntegerLiteral);\n    }\n    catch {\n        return;\n    }\n    if (wellFormedIntegerMatcher.test(maybeIntegerLiteral))\n        return value;\n    if (integerLikeMatcher.test(maybeIntegerLiteral)) {\n        // If the definition looks like a bigint but is\n        // not well-formed, throw.\n        return throwParseError(writeMalformedNumericLiteralMessage(def, \"bigint\"));\n    }\n};\n/**\n * Returns the next or previous representable floating-point number after the given input.\n *\n * @param {\"+\" | \"-\"} [direction=\"+\"] - The direction to find the nearest float. \"+\" for the next float, \"-\" for the previous float.\n * @throws {Error} If the input is not a finite number.\n *\n * @example\n * console.log(nearestFloat(0)); // Smallest positive number\n * console.log(nearestFloat(2)); // 2.0000000000000004\n * console.log(nearestFloat(2.1)); // 2.1000000000000005\n * console.log(nearestFloat(2, \"-\")); // 1.9999999999999998\n * console.log(nearestFloat(2.1, \"-\")); // 2.0999999999999996\n * // as size of input increases, the increments become larger to stay within what\n * // JS can represent in a numeric value\n * console.log(nearestFloat(5555555555555555)); // 5555555555555556\n * console.log(nearestFloat(5555555555555555, \"-\")); // 5555555555555554\n */\nexport const nearestFloat = (n, direction = \"+\") => {\n    const buffer = new ArrayBuffer(8);\n    const f64 = new Float64Array(buffer);\n    const u32 = new Uint32Array(buffer);\n    f64[0] = n;\n    if (n === 0) {\n        u32[0] = 1;\n        u32[1] = direction === \"-\" ? 1 << 31 : 0;\n    }\n    else if ((n > 0 && direction === \"+\") || (n < 0 && direction === \"-\")) {\n        if (u32[0]++ === 0xffffffff)\n            u32[1]++;\n    }\n    else if (u32[0]-- === 0)\n        u32[1]--;\n    return f64[0];\n};\n", "import { domainOf } from \"./domain.js\";\nimport { throwInternalError } from \"./errors.js\";\nimport { isomorphic } from \"./isomorphic.js\";\nimport { FileConstructor, objectKindOf } from \"./objectKinds.js\";\n// Eventually we can just import from package.json in the source itself\n// but for now, import assertions are too unstable and it wouldn't support\n// recent node versions (https://nodejs.org/api/esm.html#json-modules).\n// For now, we assert this matches the package.json version via a unit test.\nexport const arkUtilVersion = \"0.46.0\";\nexport const initialRegistryContents = {\n    version: arkUtilVersion,\n    filename: isomorphic.fileName(),\n    FileConstructor\n};\nexport const registry = initialRegistryContents;\nconst namesByResolution = new Map();\nconst nameCounts = Object.create(null);\nexport const register = (value) => {\n    const existingName = namesByResolution.get(value);\n    if (existingName)\n        return existingName;\n    let name = baseNameFor(value);\n    if (nameCounts[name])\n        name = `${name}${nameCounts[name]++}`;\n    else\n        nameCounts[name] = 1;\n    registry[name] = value;\n    namesByResolution.set(value, name);\n    return name;\n};\nexport const isDotAccessible = (keyName) => /^[$A-Z_a-z][\\w$]*$/.test(keyName);\nconst baseNameFor = (value) => {\n    switch (typeof value) {\n        case \"object\": {\n            if (value === null)\n                break;\n            const prefix = objectKindOf(value) ?? \"object\";\n            // convert to camelCase\n            return prefix[0].toLowerCase() + prefix.slice(1);\n        }\n        case \"function\":\n            return isDotAccessible(value.name) ? value.name : \"fn\";\n        case \"symbol\":\n            return value.description && isDotAccessible(value.description) ?\n                value.description\n                : \"symbol\";\n    }\n    return throwInternalError(`Unexpected attempt to register serializable value of type ${domainOf(value)}`);\n};\n", "export const serializePrimitive = (value) => (typeof value === \"string\" ? JSON.stringify(value)\n    : typeof value === \"bigint\" ? `${value}n`\n        : `${value}`);\n", "import { domainOf } from \"./domain.js\";\nimport { serializePrimitive } from \"./primitive.js\";\nimport { stringAndSymbolicEntriesOf } from \"./records.js\";\nimport { isDotAccessible, register } from \"./registry.js\";\nexport const snapshot = (data, opts = {}) => _serialize(data, {\n    onUndefined: `$ark.undefined`,\n    onBigInt: n => `$ark.bigint-${n}`,\n    ...opts\n}, []);\nexport const print = (data, opts) => console.log(printable(data, opts));\nexport const printable = (data, opts) => {\n    switch (domainOf(data)) {\n        case \"object\":\n            const o = data;\n            const ctorName = o.constructor.name;\n            return (ctorName === \"Object\" || ctorName === \"Array\" ?\n                opts?.quoteKeys === false ?\n                    stringifyUnquoted(o, opts?.indent ?? 0, \"\")\n                    : JSON.stringify(_serialize(o, printableOpts, []), null, opts?.indent)\n                : stringifyUnquoted(o, opts?.indent ?? 0, \"\"));\n        case \"symbol\":\n            return printableOpts.onSymbol(data);\n        default:\n            return serializePrimitive(data);\n    }\n};\nconst stringifyUnquoted = (value, indent, currentIndent) => {\n    if (typeof value === \"function\")\n        return printableOpts.onFunction(value);\n    if (typeof value !== \"object\" || value === null)\n        return serializePrimitive(value);\n    const nextIndent = currentIndent + \" \".repeat(indent);\n    if (Array.isArray(value)) {\n        if (value.length === 0)\n            return \"[]\";\n        const items = value\n            .map(item => stringifyUnquoted(item, indent, nextIndent))\n            .join(\",\\n\" + nextIndent);\n        return indent ? `[\\n${nextIndent}${items}\\n${currentIndent}]` : `[${items}]`;\n    }\n    const ctorName = value.constructor.name;\n    if (ctorName === \"Object\") {\n        const keyValues = stringAndSymbolicEntriesOf(value).map(([key, val]) => {\n            const stringifiedKey = typeof key === \"symbol\" ? printableOpts.onSymbol(key)\n                : isDotAccessible(key) ? key\n                    : JSON.stringify(key);\n            const stringifiedValue = stringifyUnquoted(val, indent, nextIndent);\n            return `${nextIndent}${stringifiedKey}: ${stringifiedValue}`;\n        });\n        if (keyValues.length === 0)\n            return \"{}\";\n        return indent ?\n            `{\\n${keyValues.join(\",\\n\")}\\n${currentIndent}}`\n            : `{${keyValues.join(\", \")}}`;\n    }\n    if (value instanceof Date)\n        return describeCollapsibleDate(value);\n    if (\"expression\" in value && typeof value.expression === \"string\")\n        return value.expression;\n    return ctorName;\n};\nconst printableOpts = {\n    onCycle: () => \"(cycle)\",\n    onSymbol: v => `Symbol(${register(v)})`,\n    onFunction: v => `Function(${register(v)})`\n};\nconst _serialize = (data, opts, seen) => {\n    switch (domainOf(data)) {\n        case \"object\": {\n            const o = data;\n            if (\"toJSON\" in o && typeof o.toJSON === \"function\")\n                return o.toJSON();\n            if (typeof o === \"function\")\n                return printableOpts.onFunction(o);\n            if (seen.includes(o))\n                return \"(cycle)\";\n            const nextSeen = [...seen, o];\n            if (Array.isArray(o))\n                return o.map(item => _serialize(item, opts, nextSeen));\n            if (o instanceof Date)\n                return o.toDateString();\n            const result = {};\n            for (const k in o)\n                result[k] = _serialize(o[k], opts, nextSeen);\n            for (const s of Object.getOwnPropertySymbols(o)) {\n                result[opts.onSymbol?.(s) ?? s.toString()] = _serialize(o[s], opts, nextSeen);\n            }\n            return result;\n        }\n        case \"symbol\":\n            return printableOpts.onSymbol(data);\n        case \"bigint\":\n            return opts.onBigInt?.(data) ?? `${data}n`;\n        case \"undefined\":\n            return opts.onUndefined ?? \"undefined\";\n        case \"string\":\n            return data.replaceAll(\"\\\\\", \"\\\\\\\\\");\n        default:\n            return data;\n    }\n};\n/**\n * Converts a Date instance to a human-readable description relative to its precision\n */\nexport const describeCollapsibleDate = (date) => {\n    const year = date.getFullYear();\n    const month = date.getMonth();\n    const dayOfMonth = date.getDate();\n    const hours = date.getHours();\n    const minutes = date.getMinutes();\n    const seconds = date.getSeconds();\n    const milliseconds = date.getMilliseconds();\n    if (month === 0 &&\n        dayOfMonth === 1 &&\n        hours === 0 &&\n        minutes === 0 &&\n        seconds === 0 &&\n        milliseconds === 0)\n        return `${year}`;\n    const datePortion = `${months[month]} ${dayOfMonth}, ${year}`;\n    if (hours === 0 && minutes === 0 && seconds === 0 && milliseconds === 0)\n        return datePortion;\n    let timePortion = date.toLocaleTimeString();\n    const suffix = timePortion.endsWith(\" AM\") || timePortion.endsWith(\" PM\") ?\n        timePortion.slice(-3)\n        : \"\";\n    if (suffix)\n        timePortion = timePortion.slice(0, -suffix.length);\n    if (milliseconds)\n        timePortion += `.${pad(milliseconds, 3)}`;\n    else if (timeWithUnnecessarySeconds.test(timePortion))\n        timePortion = timePortion.slice(0, -3);\n    return `${timePortion + suffix}, ${datePortion}`;\n};\nconst months = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n];\nconst timeWithUnnecessarySeconds = /:\\d\\d:00$/;\nconst pad = (value, length) => String(value).padStart(length, \"0\");\n", "import { ReadonlyArray } from \"./arrays.js\";\nimport { throwParseError } from \"./errors.js\";\nimport { isDotAccessible } from \"./registry.js\";\nimport { printable } from \"./serialize.js\";\nexport const appendStringifiedKey = (path, prop, ...[opts]) => {\n    const stringifySymbol = opts?.stringifySymbol ?? printable;\n    let propAccessChain = path;\n    switch (typeof prop) {\n        case \"string\":\n            propAccessChain =\n                isDotAccessible(prop) ?\n                    path === \"\" ?\n                        prop\n                        : `${path}.${prop}`\n                    : `${path}[${JSON.stringify(prop)}]`;\n            break;\n        case \"number\":\n            propAccessChain = `${path}[${prop}]`;\n            break;\n        case \"symbol\":\n            propAccessChain = `${path}[${stringifySymbol(prop)}]`;\n            break;\n        default:\n            if (opts?.stringifyNonKey)\n                propAccessChain = `${path}[${opts.stringifyNonKey(prop)}]`;\n            else {\n                throwParseError(`${printable(prop)} must be a PropertyKey or stringifyNonKey must be passed to options`);\n            }\n    }\n    return propAccessChain;\n};\nexport const stringifyPath = (path, ...opts) => path.reduce((s, k) => appendStringifiedKey(s, k, ...opts), \"\");\nexport class ReadonlyPath extends ReadonlyArray {\n    // alternate strategy for caching since the base object is frozen\n    cache = {};\n    constructor(...items) {\n        super();\n        this.push(...items);\n    }\n    toJSON() {\n        if (this.cache.json)\n            return this.cache.json;\n        this.cache.json = [];\n        for (let i = 0; i < this.length; i++) {\n            this.cache.json.push(typeof this[i] === \"symbol\" ? printable(this[i]) : this[i]);\n        }\n        return this.cache.json;\n    }\n    stringify() {\n        if (this.cache.stringify)\n            return this.cache.stringify;\n        return (this.cache.stringify = stringifyPath(this));\n    }\n    stringifyAncestors() {\n        if (this.cache.stringifyAncestors)\n            return this.cache.stringifyAncestors;\n        let propString = \"\";\n        const result = [propString];\n        for (const path of this) {\n            propString = appendStringifiedKey(propString, path);\n            result.push(propString);\n        }\n        return (this.cache.stringifyAncestors = result);\n    }\n}\n", "import { escapeChar, whitespaceChars } from \"./strings.js\";\nexport class Scanner {\n    chars;\n    i;\n    def;\n    constructor(def) {\n        this.def = def;\n        this.chars = [...def];\n        this.i = 0;\n    }\n    /** Get lookahead and advance scanner by one */\n    shift() {\n        return (this.chars[this.i++] ?? \"\");\n    }\n    get lookahead() {\n        return (this.chars[this.i] ?? \"\");\n    }\n    get nextLookahead() {\n        return this.chars[this.i + 1] ?? \"\";\n    }\n    get length() {\n        return this.chars.length;\n    }\n    shiftUntil(condition) {\n        let shifted = \"\";\n        while (this.lookahead) {\n            if (condition(this, shifted)) {\n                if (shifted[shifted.length - 1] === escapeChar)\n                    shifted = shifted.slice(0, -1);\n                else\n                    break;\n            }\n            shifted += this.shift();\n        }\n        return shifted;\n    }\n    shiftUntilLookahead(charOrSet) {\n        return typeof charOrSet === \"string\" ?\n            this.shiftUntil(s => s.lookahead === charOrSet)\n            : this.shiftUntil(s => s.lookahead in charOrSet);\n    }\n    shiftUntilNonWhitespace() {\n        return this.shiftUntil(() => !(this.lookahead in whitespaceChars));\n    }\n    jumpToIndex(i) {\n        this.i = i < 0 ? this.length + i : i;\n    }\n    jumpForward(count) {\n        this.i += count;\n    }\n    get location() {\n        return this.i;\n    }\n    get unscanned() {\n        return this.chars.slice(this.i, this.length).join(\"\");\n    }\n    get scanned() {\n        return this.chars.slice(0, this.i).join(\"\");\n    }\n    sliceChars(start, end) {\n        return this.chars.slice(start, end).join(\"\");\n    }\n    lookaheadIs(char) {\n        return this.lookahead === char;\n    }\n    lookaheadIsIn(tokens) {\n        return this.lookahead in tokens;\n    }\n}\n", "import { hasDomain } from \"./domain.js\";\nimport { noSuggest } from \"./errors.js\";\nimport { ancestorsOf } from \"./objectKinds.js\";\nimport { NoopBase } from \"./records.js\";\n// even though the value we attach will be identical, we use this so classes\n// won't be treated as instanceof a Trait\nconst implementedTraits = noSuggest(\"implementedTraits\");\nexport const hasTrait = (traitClass) => (o) => {\n    if (!hasDomain(o, \"object\"))\n        return false;\n    if (implementedTraits in o.constructor &&\n        o.constructor[implementedTraits].includes(traitClass))\n        return true;\n    // emulate standard instanceof behavior\n    return ancestorsOf(o).includes(traitClass);\n};\n/** @ts-ignore required to extend NoopBase */\nexport class Trait extends NoopBase {\n    static get [Symbol.hasInstance]() {\n        return hasTrait(this);\n    }\n    traitsOf() {\n        return implementedTraits in this.constructor ?\n            this.constructor[implementedTraits]\n            : [];\n    }\n}\nconst collectPrototypeDescriptors = (trait) => {\n    let proto = trait.prototype;\n    let result = {};\n    do {\n        // ensure prototypes are sorted from lowest to highest precedence\n        result = Object.assign(Object.getOwnPropertyDescriptors(proto), result);\n        proto = Object.getPrototypeOf(proto);\n    } while (proto !== Object.prototype && proto !== null);\n    return result;\n};\nexport const compose = ((...traits) => {\n    const base = function (...args) {\n        for (const trait of traits) {\n            const instance = Reflect.construct(trait, args, this.constructor);\n            Object.assign(this, instance);\n        }\n    };\n    const flatImplementedTraits = [];\n    for (const trait of traits) {\n        // copy static properties\n        Object.assign(base, trait);\n        // flatten and copy prototype\n        Object.defineProperties(base.prototype, collectPrototypeDescriptors(trait));\n        if (implementedTraits in trait) {\n            // add any ancestor traits from which the current trait was composed\n            for (const innerTrait of trait[implementedTraits]) {\n                if (!flatImplementedTraits.includes(innerTrait))\n                    flatImplementedTraits.push(innerTrait);\n            }\n        }\n        if (!flatImplementedTraits.includes(trait))\n            flatImplementedTraits.push(trait);\n    }\n    Object.defineProperty(base, implementedTraits, {\n        value: flatImplementedTraits,\n        enumerable: false\n    });\n    return base;\n});\nexport const implement = (...args) => {\n    if (args.at(-1) instanceof Trait)\n        return compose(...args);\n    const implementation = args.at(-1);\n    const base = compose(...args.slice(0, -1));\n    // copy implementation last since it overrides traits\n    Object.defineProperties(base.prototype, Object.getOwnPropertyDescriptors(implementation));\n    return base;\n};\n", "import { register, registry } from \"@ark/util\";\nlet _registryName = \"$ark\";\nlet suffix = 2;\nwhile (_registryName in globalThis)\n    _registryName = `$ark${suffix++}`;\nexport const registryName = _registryName;\nglobalThis[registryName] = registry;\nexport const $ark = registry;\nexport const reference = (name) => `${registryName}.${name}`;\nexport const registeredReference = (value) => reference(register(value));\n", "import { CastableBase, DynamicFunction, hasDomain, isDotAccessible, serializePrimitive } from \"@ark/util\";\nimport { registeredReference } from \"./registry.js\";\nexport class CompiledFunction extends CastableBase {\n    argNames;\n    body = \"\";\n    constructor(...args) {\n        super();\n        this.argNames = args;\n        for (const arg of args) {\n            if (arg in this) {\n                throw new Error(`Arg name '${arg}' would overwrite an existing property on FunctionBody`);\n            }\n            ;\n            this[arg] = arg;\n        }\n    }\n    indentation = 0;\n    indent() {\n        this.indentation += 4;\n        return this;\n    }\n    dedent() {\n        this.indentation -= 4;\n        return this;\n    }\n    prop(key, optional = false) {\n        return compileLiteralPropAccess(key, optional);\n    }\n    index(key, optional = false) {\n        return indexPropAccess(`${key}`, optional);\n    }\n    line(statement) {\n        ;\n        this.body += `${\" \".repeat(this.indentation)}${statement}\\n`;\n        return this;\n    }\n    const(identifier, expression) {\n        this.line(`const ${identifier} = ${expression}`);\n        return this;\n    }\n    let(identifier, expression) {\n        return this.line(`let ${identifier} = ${expression}`);\n    }\n    set(identifier, expression) {\n        return this.line(`${identifier} = ${expression}`);\n    }\n    if(condition, then) {\n        return this.block(`if (${condition})`, then);\n    }\n    elseIf(condition, then) {\n        return this.block(`else if (${condition})`, then);\n    }\n    else(then) {\n        return this.block(\"else\", then);\n    }\n    /** Current index is \"i\" */\n    for(until, body, initialValue = 0) {\n        return this.block(`for (let i = ${initialValue}; ${until}; i++)`, body);\n    }\n    /** Current key is \"k\" */\n    forIn(object, body) {\n        return this.block(`for (const k in ${object})`, body);\n    }\n    block(prefix, contents, suffix = \"\") {\n        this.line(`${prefix} {`);\n        this.indent();\n        contents(this);\n        this.dedent();\n        return this.line(`}${suffix}`);\n    }\n    return(expression = \"\") {\n        return this.line(`return ${expression}`);\n    }\n    write(name = \"anonymous\", indent = 0) {\n        return `${name}(${this.argNames.join(\", \")}) { ${indent ?\n            this.body\n                .split(\"\\n\")\n                .map(l => \" \".repeat(indent) + `${l}`)\n                .join(\"\\n\")\n            : this.body} }`;\n    }\n    compile() {\n        return new DynamicFunction(...this.argNames, this.body);\n    }\n}\nexport const compileSerializedValue = (value) => hasDomain(value, \"object\") || typeof value === \"symbol\" ?\n    registeredReference(value)\n    : serializePrimitive(value);\nexport const compileLiteralPropAccess = (key, optional = false) => {\n    if (typeof key === \"string\" && isDotAccessible(key))\n        return `${optional ? \"?\" : \"\"}.${key}`;\n    return indexPropAccess(serializeLiteralKey(key), optional);\n};\nexport const serializeLiteralKey = (key) => typeof key === \"symbol\" ? registeredReference(key) : JSON.stringify(key);\nexport const indexPropAccess = (key, optional = false) => `${optional ? \"?.\" : \"\"}[${key}]`;\nexport class NodeCompiler extends CompiledFunction {\n    traversalKind;\n    optimistic;\n    constructor(ctx) {\n        super(\"data\", \"ctx\");\n        this.traversalKind = ctx.kind;\n        this.optimistic = ctx.optimistic === true;\n    }\n    invoke(node, opts) {\n        const arg = opts?.arg ?? this.data;\n        const requiresContext = typeof node === \"string\" ? true : this.requiresContextFor(node);\n        const id = typeof node === \"string\" ? node : node.id;\n        if (requiresContext)\n            return `${this.referenceToId(id, opts)}(${arg}, ${this.ctx})`;\n        return `${this.referenceToId(id, opts)}(${arg})`;\n    }\n    referenceToId(id, opts) {\n        const invokedKind = opts?.kind ?? this.traversalKind;\n        const base = `this.${id}${invokedKind}`;\n        return opts?.bind ? `${base}.bind(${opts?.bind})` : base;\n    }\n    requiresContextFor(node) {\n        return this.traversalKind === \"Apply\" || node.allowsRequiresContext;\n    }\n    initializeErrorCount() {\n        return this.const(\"errorCount\", \"ctx.currentErrorCount\");\n    }\n    returnIfFail() {\n        return this.if(\"ctx.currentErrorCount > errorCount\", () => this.return());\n    }\n    returnIfFailFast() {\n        return this.if(\"ctx.failFast && ctx.currentErrorCount > errorCount\", () => this.return());\n    }\n    traverseKey(keyExpression, accessExpression, node) {\n        const requiresContext = this.requiresContextFor(node);\n        if (requiresContext)\n            this.line(`${this.ctx}.path.push(${keyExpression})`);\n        this.check(node, {\n            arg: accessExpression\n        });\n        if (requiresContext)\n            this.line(`${this.ctx}.path.pop()`);\n        return this;\n    }\n    check(node, opts) {\n        return this.traversalKind === \"Allows\" ?\n            this.if(`!${this.invoke(node, opts)}`, () => this.return(false))\n            : this.line(this.invoke(node, opts));\n    }\n}\n", "import { flatMorph, isArray, noSuggest } from \"@ark/util\";\nexport const makeRootAndArrayPropertiesMutable = (o) => \n// this cast should not be required, but it seems TS is referencing\n// the wrong parameters here?\nflatMorph(o, (k, v) => [k, isArray(v) ? [...v] : v]);\nexport const arkKind = noSuggest(\"arkKind\");\nexport const hasArkKind = (value, kind) => value?.[arkKind] === kind;\nexport const isNode = (value) => hasArkKind(value, \"root\") || hasArkKind(value, \"constraint\");\n", "import { flatMorph, printable, throwParseError } from \"@ark/util\";\nimport { compileSerializedValue } from \"./compile.js\";\nimport { isNode } from \"./utils.js\";\nexport const basisKinds = [\"unit\", \"proto\", \"domain\"];\nexport const structuralKinds = [\n    \"required\",\n    \"optional\",\n    \"index\",\n    \"sequence\"\n];\nexport const refinementKinds = [\n    \"pattern\",\n    \"divisor\",\n    \"exactLength\",\n    \"max\",\n    \"min\",\n    \"maxLength\",\n    \"minLength\",\n    \"before\",\n    \"after\"\n];\nexport const constraintKinds = [\n    ...refinementKinds,\n    ...structuralKinds,\n    \"structure\",\n    \"predicate\"\n];\nexport const rootKinds = [\n    \"alias\",\n    \"union\",\n    \"morph\",\n    \"unit\",\n    \"intersection\",\n    \"proto\",\n    \"domain\"\n];\nexport const nodeKinds = [...rootKinds, ...constraintKinds];\nexport const constraintKeys = flatMorph(constraintKinds, (i, kind) => [kind, 1]);\nexport const structureKeys = flatMorph([...structuralKinds, \"undeclared\"], (i, k) => [k, 1]);\nexport const precedenceByKind = flatMorph(nodeKinds, (i, kind) => [kind, i]);\nexport const isNodeKind = (value) => typeof value === \"string\" && value in precedenceByKind;\nexport function assertNodeKind(value, kind) {\n    const valueIsNode = isNode(value);\n    if (!valueIsNode || value.kind !== kind) {\n        throwParseError(`Expected node of kind ${kind} (was ${valueIsNode ? `${value.kind} node` : printable(value)})`);\n    }\n}\nexport const precedenceOfKind = (kind) => precedenceByKind[kind];\nexport const schemaKindsRightOf = (kind) => rootKinds.slice(precedenceOfKind(kind) + 1);\nexport const unionChildKinds = [\n    ...schemaKindsRightOf(\"union\"),\n    \"alias\"\n];\nexport const morphChildKinds = [\n    ...schemaKindsRightOf(\"morph\"),\n    \"alias\"\n];\nexport const defaultValueSerializer = (v) => {\n    if (typeof v === \"string\" || typeof v === \"boolean\" || v === null)\n        return v;\n    if (typeof v === \"number\") {\n        if (Number.isNaN(v))\n            return \"NaN\";\n        if (v === Number.POSITIVE_INFINITY)\n            return \"Infinity\";\n        if (v === Number.NEGATIVE_INFINITY)\n            return \"-Infinity\";\n        return v;\n    }\n    return compileSerializedValue(v);\n};\nexport const compileObjectLiteral = (ctx) => {\n    let result = \"{ \";\n    for (const [k, v] of Object.entries(ctx))\n        result += `${k}: ${compileSerializedValue(v)}, `;\n    return result + \" }\";\n};\nexport const implementNode = (_) => {\n    const implementation = _;\n    if (implementation.hasAssociatedError) {\n        implementation.defaults.expected ??= ctx => \"description\" in ctx ?\n            ctx.description\n            : implementation.defaults.description(ctx);\n        implementation.defaults.actual ??= data => printable(data);\n        implementation.defaults.problem ??= ctx => `must be ${ctx.expected}${ctx.actual ? ` (was ${ctx.actual})` : \"\"}`;\n        implementation.defaults.message ??= ctx => {\n            if (ctx.path.length === 0)\n                return ctx.problem;\n            const problemWithLocation = `${ctx.propString} ${ctx.problem}`;\n            if (problemWithLocation[0] === \"[\") {\n                // clarify paths like [1], [0][1], and [\"key!\"] that could be confusing\n                return `value at ${problemWithLocation}`;\n            }\n            return problemWithLocation;\n        };\n    }\n    return implementation;\n};\n", "import { printable, throwInternalError } from \"@ark/util\";\nclass ToJsonSchemaError extends Error {\n    name = \"ToJsonSchemaError\";\n    code;\n    context;\n    constructor(code, context) {\n        super(printable(context, { quoteKeys: false, indent: 4 }));\n        this.code = code;\n        this.context = context;\n    }\n    hasCode(code) {\n        return this.code === code;\n    }\n}\nconst defaultConfig = {\n    dialect: \"https://json-schema.org/draft/2020-12/schema\",\n    useRefs: false,\n    fallback: {\n        arrayObject: ctx => ToJsonSchema.throw(\"arrayObject\", ctx),\n        arrayPostfix: ctx => ToJsonSchema.throw(\"arrayPostfix\", ctx),\n        defaultValue: ctx => ToJsonSchema.throw(\"defaultValue\", ctx),\n        domain: ctx => ToJsonSchema.throw(\"domain\", ctx),\n        morph: ctx => ToJsonSchema.throw(\"morph\", ctx),\n        patternIntersection: ctx => ToJsonSchema.throw(\"patternIntersection\", ctx),\n        predicate: ctx => ToJsonSchema.throw(\"predicate\", ctx),\n        proto: ctx => ToJsonSchema.throw(\"proto\", ctx),\n        symbolKey: ctx => ToJsonSchema.throw(\"symbolKey\", ctx),\n        unit: ctx => ToJsonSchema.throw(\"unit\", ctx),\n        date: ctx => ToJsonSchema.throw(\"date\", ctx)\n    }\n};\nexport const ToJsonSchema = {\n    Error: ToJsonSchemaError,\n    throw: (...args) => {\n        throw new ToJsonSchema.Error(...args);\n    },\n    throwInternalOperandError: (kind, schema) => throwInternalError(`Unexpected JSON Schema input for ${kind}: ${printable(schema)}`),\n    defaultConfig\n};\n", "import { isNodeKind } from \"./shared/implement.js\";\nimport { $ark } from \"./shared/registry.js\";\nimport { ToJsonSchema } from \"./shared/toJsonSchema.js\";\n// $ark.config could already be set if it were imported previously from the\n// dedicated config entrypoint, in which case we don't want to reinitialize it\n$ark.config ??= {};\nexport const configureSchema = (config) => {\n    const result = Object.assign($ark.config, mergeConfigs($ark.config, config));\n    $ark.resolvedConfig &&= mergeConfigs($ark.resolvedConfig, result);\n    return result;\n};\nexport const mergeConfigs = (base, merged) => {\n    if (!merged)\n        return base;\n    const result = { ...base };\n    let k;\n    for (k in merged) {\n        const keywords = { ...base.keywords };\n        if (k === \"keywords\") {\n            for (const flatAlias in merged[k]) {\n                const v = merged.keywords[flatAlias];\n                if (v === undefined)\n                    continue;\n                keywords[flatAlias] = typeof v === \"string\" ? { description: v } : v;\n            }\n            result.keywords = keywords;\n        }\n        else if (k === \"toJsonSchema\") {\n            result[k] = mergeToJsonSchemaConfigs(base.toJsonSchema, merged.toJsonSchema);\n        }\n        else if (isNodeKind(k)) {\n            result[k] =\n                // not casting this makes TS compute a very inefficient\n                // type that is not needed\n                {\n                    ...base[k],\n                    ...merged[k]\n                };\n        }\n        else\n            result[k] = merged[k];\n    }\n    return result;\n};\nexport const mergeToJsonSchemaConfigs = ((baseConfig, mergedConfig) => {\n    if (!baseConfig)\n        return mergedConfig ?? {};\n    if (!mergedConfig)\n        return baseConfig;\n    const result = { ...baseConfig };\n    let k;\n    for (k in mergedConfig) {\n        if (k === \"fallback\") {\n            result.fallback = mergeFallbacks(baseConfig.fallback, mergedConfig.fallback);\n        }\n        else\n            result[k] = mergedConfig[k];\n    }\n    return result;\n});\nconst mergeFallbacks = (base, merged) => {\n    base = normalizeFallback(base);\n    merged = normalizeFallback(merged);\n    const result = {};\n    let code;\n    for (code in ToJsonSchema.defaultConfig.fallback) {\n        result[code] =\n            merged[code] ??\n                merged.default ??\n                base[code] ??\n                base.default ??\n                ToJsonSchema.defaultConfig.fallback[code];\n    }\n    return result;\n};\nconst normalizeFallback = (fallback) => typeof fallback === \"function\" ? { default: fallback } : (fallback ?? {});\n", "import { CastableBase, ReadonlyArray, ReadonlyPath, append, conflatenateAll, defineProperties, flatMorph, stringifyPath } from \"@ark/util\";\nimport { arkKind } from \"./utils.js\";\nexport class ArkError extends CastableBase {\n    [arkKind] = \"error\";\n    path;\n    data;\n    nodeConfig;\n    input;\n    ctx;\n    // TS gets confused by <code>, so internally we just use the base type for input\n    constructor({ prefixPath, relativePath, ...input }, ctx) {\n        super();\n        this.input = input;\n        this.ctx = ctx;\n        defineProperties(this, input);\n        const data = ctx.data;\n        if (input.code === \"union\") {\n            input.errors = input.errors.flatMap(innerError => {\n                // flatten union errors to avoid repeating context like \"foo must be foo must be\"...\n                const flat = innerError.hasCode(\"union\") ? innerError.errors : [innerError];\n                if (!prefixPath && !relativePath)\n                    return flat;\n                return flat.map(e => e.transform(e => ({\n                    ...e,\n                    path: conflatenateAll(prefixPath, e.path, relativePath)\n                })));\n            });\n        }\n        this.nodeConfig = ctx.config[this.code];\n        const basePath = [...(input.path ?? ctx.path)];\n        if (relativePath)\n            basePath.push(...relativePath);\n        if (prefixPath)\n            basePath.unshift(...prefixPath);\n        this.path = new ReadonlyPath(...basePath);\n        this.data = \"data\" in input ? input.data : data;\n    }\n    transform(f) {\n        return new ArkError(f({\n            data: this.data,\n            path: this.path,\n            ...this.input\n        }), this.ctx);\n    }\n    hasCode(code) {\n        return this.code === code;\n    }\n    get propString() {\n        return stringifyPath(this.path);\n    }\n    get expected() {\n        if (this.input.expected)\n            return this.input.expected;\n        const config = this.meta?.expected ?? this.nodeConfig.expected;\n        return typeof config === \"function\" ? config(this.input) : config;\n    }\n    get actual() {\n        if (this.input.actual)\n            return this.input.actual;\n        const config = this.meta?.actual ?? this.nodeConfig.actual;\n        return typeof config === \"function\" ? config(this.data) : config;\n    }\n    get problem() {\n        if (this.input.problem)\n            return this.input.problem;\n        const config = this.meta?.problem ?? this.nodeConfig.problem;\n        return typeof config === \"function\" ? config(this) : config;\n    }\n    get message() {\n        if (this.input.message)\n            return this.input.message;\n        const config = this.meta?.message ?? this.nodeConfig.message;\n        return typeof config === \"function\" ? config(this) : config;\n    }\n    get flat() {\n        return this.hasCode(\"intersection\") ? [...this.errors] : [this];\n    }\n    toJSON() {\n        return {\n            data: this.data,\n            path: this.path,\n            ...this.input,\n            expected: this.expected,\n            actual: this.actual,\n            problem: this.problem,\n            message: this.message\n        };\n    }\n    toString() {\n        return this.message;\n    }\n    throw() {\n        throw this;\n    }\n}\n/**\n * A ReadonlyArray of `ArkError`s returned by a Type on invalid input.\n *\n * Subsequent errors added at an existing path are merged into an\n * ArkError intersection.\n */\nexport class ArkErrors extends ReadonlyArray {\n    [arkKind] = \"errors\";\n    ctx;\n    constructor(ctx) {\n        super();\n        this.ctx = ctx;\n    }\n    /**\n     * Errors by a pathString representing their location.\n     */\n    byPath = Object.create(null);\n    /**\n     * {@link byPath} flattened so that each value is an array of ArkError instances at that path.\n     *\n     * ✅ Since \"intersection\" errors will be flattened to their constituent `.errors`,\n     * they will never be directly present in this representation.\n     */\n    get flatByPath() {\n        return flatMorph(this.byPath, (k, v) => [k, v.flat]);\n    }\n    /**\n     * {@link byPath} flattened so that each value is an array of problem strings at that path.\n     */\n    get flatProblemsByPath() {\n        return flatMorph(this.byPath, (k, v) => [k, v.flat.map(e => e.problem)]);\n    }\n    /**\n     * All pathStrings at which errors are present mapped to the errors occuring\n     * at that path or any nested path within it.\n     */\n    byAncestorPath = Object.create(null);\n    count = 0;\n    mutable = this;\n    /**\n     * Throw a TraversalError based on these errors.\n     */\n    throw() {\n        throw this.toTraversalError();\n    }\n    /**\n     * Converts ArkErrors to TraversalError, a subclass of `Error` suitable for throwing with nice\n     * formatting.\n     */\n    toTraversalError() {\n        return new TraversalError(this);\n    }\n    /**\n     * Append an ArkError to this array, ignoring duplicates.\n     */\n    add(error) {\n        if (this.includes(error))\n            return;\n        this._add(error);\n    }\n    transform(f) {\n        const result = new ArkErrors(this.ctx);\n        for (const e of this)\n            result.add(f(e));\n        return result;\n    }\n    /**\n     * Add all errors from an ArkErrors instance, ignoring duplicates and\n     * prefixing their paths with that of the current Traversal.\n     */\n    merge(errors) {\n        for (const e of errors) {\n            if (this.includes(e))\n                continue;\n            this._add(new ArkError({ ...e, path: [...this.ctx.path, ...e.path] }, this.ctx));\n        }\n    }\n    /**\n     * @internal\n     */\n    affectsPath(path) {\n        if (this.length === 0)\n            return false;\n        return (\n        // this would occur if there is an existing error at a prefix of path\n        // e.g. the path is [\"foo\", \"bar\"] and there is an error at [\"foo\"]\n        path.stringifyAncestors().some(s => s in this.byPath) ||\n            // this would occur if there is an existing error at a suffix of path\n            // e.g. the path is [\"foo\"] and there is an error at [\"foo\", \"bar\"]\n            path.stringify() in this.byAncestorPath);\n    }\n    /**\n     * A human-readable summary of all errors.\n     */\n    get summary() {\n        return this.toString();\n    }\n    /**\n     * Alias of this ArkErrors instance for StandardSchema compatibility.\n     */\n    get issues() {\n        return this;\n    }\n    toJSON() {\n        return [...this.map(e => e.toJSON())];\n    }\n    toString() {\n        return this.join(\"\\n\");\n    }\n    _add(error) {\n        const existing = this.byPath[error.propString];\n        if (existing) {\n            // If the existing error is an error for a value constrained to \"never\",\n            // then we don't want to intersect the error messages.\n            if (existing.hasCode(\"union\") && existing.errors.length === 0)\n                return;\n            // If the new error is an error for a value constrained to \"never\",\n            // then we want to override any existing errors.\n            const errorIntersection = error.hasCode(\"union\") && error.errors.length === 0 ?\n                error\n                : new ArkError({\n                    code: \"intersection\",\n                    errors: existing.hasCode(\"intersection\") ?\n                        [...existing.errors, error]\n                        : [existing, error]\n                }, this.ctx);\n            const existingIndex = this.indexOf(existing);\n            this.mutable[existingIndex === -1 ? this.length : existingIndex] =\n                errorIntersection;\n            this.byPath[error.propString] = errorIntersection;\n            // add the original error here rather than the intersection\n            // since the intersection is reflected by the array of errors at\n            // this path\n            this.addAncestorPaths(error);\n        }\n        else {\n            this.byPath[error.propString] = error;\n            this.addAncestorPaths(error);\n            this.mutable.push(error);\n        }\n        this.count++;\n    }\n    addAncestorPaths(error) {\n        for (const propString of error.path.stringifyAncestors()) {\n            this.byAncestorPath[propString] = append(this.byAncestorPath[propString], error);\n        }\n    }\n}\nexport class TraversalError extends Error {\n    name = \"TraversalError\";\n    constructor(errors) {\n        if (errors.length === 1)\n            super(errors.summary);\n        else\n            super(\"\\n\" + errors.map(error => `  • ${indent(error)}`).join(\"\\n\"));\n        Object.defineProperty(this, \"arkErrors\", {\n            value: errors,\n            enumerable: false\n        });\n    }\n}\nconst indent = (error) => error.toString().split(\"\\n\").join(\"\\n  \");\n", "import { ReadonlyPath, stringifyPath } from \"@ark/util\";\nimport { ArkError, ArkErrors } from \"./errors.js\";\nimport { isNode } from \"./utils.js\";\nexport class Traversal {\n    /**\n     * #### the path being validated or morphed\n     *\n     * ✅ array indices represented as numbers\n     * ⚠️ mutated during traversal - use `path.slice(0)` to snapshot\n     * 🔗 use {@link propString} for a stringified version\n     */\n    path = [];\n    /**\n     * #### {@link ArkErrors} that will be part of this traversal's finalized result\n     *\n     * ✅ will always be an empty array for a valid traversal\n     */\n    errors = new ArkErrors(this);\n    /**\n     * #### the original value being traversed\n     */\n    root;\n    /**\n     * #### configuration for this traversal\n     *\n     * ✅ options can affect traversal results and error messages\n     * ✅ defaults < global config < scope config\n     * ✅ does not include options configured on individual types\n     */\n    config;\n    queuedMorphs = [];\n    branches = [];\n    seen = {};\n    constructor(root, config) {\n        this.root = root;\n        this.config = config;\n    }\n    /**\n     * #### the data being validated or morphed\n     *\n     * ✅ extracted from {@link root} at {@link path}\n     */\n    get data() {\n        let result = this.root;\n        for (const segment of this.path)\n            result = result?.[segment];\n        return result;\n    }\n    /**\n     * #### a string representing {@link path}\n     *\n     * @propString\n     */\n    get propString() {\n        return stringifyPath(this.path);\n    }\n    /**\n     * #### add an {@link ArkError} and return `false`\n     *\n     * ✅ useful for predicates like `.narrow`\n     */\n    reject(input) {\n        this.error(input);\n        return false;\n    }\n    /**\n     * #### add an {@link ArkError} from a description and return `false`\n     *\n     * ✅ useful for predicates like `.narrow`\n     * 🔗 equivalent to {@link reject}({ expected })\n     */\n    mustBe(expected) {\n        this.error(expected);\n        return false;\n    }\n    error(input) {\n        const errCtx = typeof input === \"object\" ?\n            input.code ?\n                input\n                : { ...input, code: \"predicate\" }\n            : { code: \"predicate\", expected: input };\n        return this.errorFromContext(errCtx);\n    }\n    /**\n     * #### whether {@link currentBranch} (or the traversal root, outside a union) has one or more errors\n     */\n    hasError() {\n        return this.currentErrorCount !== 0;\n    }\n    get currentBranch() {\n        return this.branches.at(-1);\n    }\n    queueMorphs(morphs) {\n        const input = {\n            path: new ReadonlyPath(...this.path),\n            morphs\n        };\n        if (this.currentBranch)\n            this.currentBranch.queuedMorphs.push(input);\n        else\n            this.queuedMorphs.push(input);\n    }\n    finalize(onFail) {\n        if (this.queuedMorphs.length) {\n            if (typeof this.root === \"object\" &&\n                this.root !== null &&\n                this.config.clone)\n                this.root = this.config.clone(this.root);\n            this.applyQueuedMorphs();\n        }\n        if (this.hasError())\n            return onFail ? onFail(this.errors) : this.errors;\n        return this.root;\n    }\n    get currentErrorCount() {\n        return (this.currentBranch ?\n            this.currentBranch.error ?\n                1\n                : 0\n            : this.errors.count);\n    }\n    get failFast() {\n        return this.branches.length !== 0;\n    }\n    pushBranch() {\n        this.branches.push({\n            error: undefined,\n            queuedMorphs: []\n        });\n    }\n    popBranch() {\n        return this.branches.pop();\n    }\n    /**\n     * @internal\n     * Convenience for casting from InternalTraversal to Traversal\n     * for cases where the extra methods on the external type are expected, e.g.\n     * a morph or predicate.\n     */\n    get external() {\n        return this;\n    }\n    errorFromNodeContext(input) {\n        return this.errorFromContext(input);\n    }\n    errorFromContext(errCtx) {\n        const error = new ArkError(errCtx, this);\n        if (this.currentBranch)\n            this.currentBranch.error = error;\n        else\n            this.errors.add(error);\n        return error;\n    }\n    applyQueuedMorphs() {\n        // invoking morphs that are Nodes will reuse this context, potentially\n        // adding additional morphs, so we have to continue looping until\n        // queuedMorphs is empty rather than iterating over the list once\n        while (this.queuedMorphs.length) {\n            const queuedMorphs = this.queuedMorphs;\n            this.queuedMorphs = [];\n            for (const { path, morphs } of queuedMorphs) {\n                // even if we already have an error, apply morphs that are not at a path\n                // with errors to capture potential validation errors\n                if (this.errors.affectsPath(path))\n                    continue;\n                this.applyMorphsAtPath(path, morphs);\n            }\n        }\n    }\n    applyMorphsAtPath(path, morphs) {\n        const key = path.at(-1);\n        let parent;\n        if (key !== undefined) {\n            // find the object on which the key to be morphed exists\n            parent = this.root;\n            for (let pathIndex = 0; pathIndex < path.length - 1; pathIndex++)\n                parent = parent[path[pathIndex]];\n        }\n        this.path = [...path];\n        for (const morph of morphs) {\n            const morphIsNode = isNode(morph);\n            const result = morph(parent === undefined ? this.root : parent[key], this);\n            if (result instanceof ArkError) {\n                // if an ArkError was returned, ensure it has been added to errors\n                this.errors.add(result);\n                // skip any remaining morphs at the current path\n                break;\n            }\n            if (result instanceof ArkErrors) {\n                // if the morph was a direct reference to another node,\n                // errors will have been added directly via this piped context\n                if (!morphIsNode) {\n                    // otherwise, we have to ensure each error has been added\n                    this.errors.merge(result);\n                }\n                // skip any remaining morphs at the current path\n                break;\n            }\n            // if the morph was successful, assign the result to the\n            // corresponding property, or to root if path is empty\n            if (parent === undefined)\n                this.root = result;\n            else\n                parent[key] = result;\n            // if the current morph queued additional morphs,\n            // applying them before subsequent morphs\n            this.applyQueuedMorphs();\n        }\n    }\n}\nexport const traverseKey = (key, fn, \n// ctx will be undefined if this node isn't context-dependent\nctx) => {\n    if (!ctx)\n        return fn();\n    ctx.path.push(key);\n    const result = fn();\n    ctx.path.pop();\n    return result;\n};\n", "import { Callable, appendUnique, flatMorph, includes, isArray, isEmptyObject, isKeyOf, liftArray, printable, stringifyPath, throwError, throwInternalError } from \"@ark/util\";\nimport { basisKinds, constraintKinds, precedenceOfKind, refinementKinds, rootKinds, structuralKinds } from \"./shared/implement.js\";\nimport { $ark } from \"./shared/registry.js\";\nimport { Traversal } from \"./shared/traversal.js\";\nimport { isNode } from \"./shared/utils.js\";\nexport class BaseNode extends Callable {\n    attachments;\n    $;\n    onFail;\n    includesTransform;\n    includesContextualPredicate;\n    isCyclic;\n    allowsRequiresContext;\n    rootApplyStrategy;\n    contextFreeMorph;\n    rootApply;\n    referencesById;\n    shallowReferences;\n    flatRefs;\n    flatMorphs;\n    allows;\n    get shallowMorphs() {\n        return [];\n    }\n    constructor(attachments, $) {\n        super((data, pipedFromCtx, onFail = this.onFail) => {\n            if (pipedFromCtx) {\n                this.traverseApply(data, pipedFromCtx);\n                return pipedFromCtx.hasError() ?\n                    pipedFromCtx.errors\n                    : pipedFromCtx.data;\n            }\n            return this.rootApply(data, onFail);\n        }, { attach: attachments });\n        this.attachments = attachments;\n        this.$ = $;\n        this.onFail = this.meta.onFail ?? this.$.resolvedConfig.onFail;\n        this.includesTransform =\n            this.hasKind(\"morph\") ||\n                (this.hasKind(\"structure\") && this.structuralMorph !== undefined);\n        // if a predicate accepts exactly one arg, we can safely skip passing context\n        // technically, a predicate could be written like `(data, ...[ctx]) => ctx.mustBe(\"malicious\")`\n        // that would break here, but it feels like a pathological case and is better to let people optimize\n        this.includesContextualPredicate =\n            this.hasKind(\"predicate\") && this.inner.predicate.length !== 1;\n        this.isCyclic = this.kind === \"alias\";\n        this.referencesById = { [this.id]: this };\n        this.shallowReferences =\n            this.hasKind(\"structure\") ?\n                [this, ...this.children]\n                : this.children.reduce((acc, child) => appendUniqueNodes(acc, child.shallowReferences), [this]);\n        const isStructural = this.isStructural();\n        this.flatRefs = [];\n        this.flatMorphs = [];\n        for (let i = 0; i < this.children.length; i++) {\n            this.includesTransform ||= this.children[i].includesTransform;\n            this.includesContextualPredicate ||=\n                this.children[i].includesContextualPredicate;\n            this.isCyclic ||= this.children[i].isCyclic;\n            if (!isStructural) {\n                const childFlatRefs = this.children[i].flatRefs;\n                for (let j = 0; j < childFlatRefs.length; j++) {\n                    const childRef = childFlatRefs[j];\n                    if (!this.flatRefs.some(existing => flatRefsAreEqual(existing, childRef))) {\n                        this.flatRefs.push(childRef);\n                        for (const branch of childRef.node.branches) {\n                            if (branch.hasKind(\"morph\") ||\n                                (branch.hasKind(\"intersection\") &&\n                                    branch.structure?.structuralMorph !== undefined)) {\n                                this.flatMorphs.push({\n                                    path: childRef.path,\n                                    propString: childRef.propString,\n                                    node: branch\n                                });\n                            }\n                        }\n                    }\n                }\n            }\n            Object.assign(this.referencesById, this.children[i].referencesById);\n        }\n        this.flatRefs.sort((l, r) => l.path.length > r.path.length ? 1\n            : l.path.length < r.path.length ? -1\n                : l.propString > r.propString ? 1\n                    : l.propString < r.propString ? -1\n                        : l.node.expression < r.node.expression ? -1\n                            : 1);\n        this.allowsRequiresContext =\n            this.includesContextualPredicate || this.isCyclic;\n        this.rootApplyStrategy =\n            !this.allowsRequiresContext && this.flatMorphs.length === 0 ?\n                this.shallowMorphs.length === 0 ? \"allows\"\n                    : (this.shallowMorphs.every(morph => morph.length === 1 || morph.name === \"$arkStructuralMorph\")) ?\n                        this.hasKind(\"union\") ?\n                            // multiple morphs not yet supported for optimistic compilation\n                            this.branches.some(branch => branch.shallowMorphs.length > 1) ?\n                                \"contextual\"\n                                : \"branchedOptimistic\"\n                            : this.shallowMorphs.length > 1 ? \"contextual\"\n                                : \"optimistic\"\n                        : \"contextual\"\n                : \"contextual\";\n        this.rootApply = this.createRootApply();\n        this.allows =\n            this.allowsRequiresContext ?\n                data => this.traverseAllows(data, new Traversal(data, this.$.resolvedConfig))\n                : data => this.traverseAllows(data);\n    }\n    createRootApply() {\n        switch (this.rootApplyStrategy) {\n            case \"allows\":\n                return (data, onFail) => {\n                    if (this.allows(data))\n                        return data;\n                    const ctx = new Traversal(data, this.$.resolvedConfig);\n                    this.traverseApply(data, ctx);\n                    return ctx.finalize(onFail);\n                };\n            case \"contextual\":\n                return (data, onFail) => {\n                    const ctx = new Traversal(data, this.$.resolvedConfig);\n                    this.traverseApply(data, ctx);\n                    return ctx.finalize(onFail);\n                };\n            case \"optimistic\":\n                this.contextFreeMorph = this.shallowMorphs[0];\n                const clone = this.$.resolvedConfig.clone;\n                return (data, onFail) => {\n                    if (this.allows(data)) {\n                        return this.contextFreeMorph((clone &&\n                            ((typeof data === \"object\" && data !== null) ||\n                                typeof data === \"function\")) ?\n                            clone(data)\n                            : data);\n                    }\n                    const ctx = new Traversal(data, this.$.resolvedConfig);\n                    this.traverseApply(data, ctx);\n                    return ctx.finalize(onFail);\n                };\n            case \"branchedOptimistic\":\n                return this.createBranchedOptimisticRootApply();\n            default:\n                this.rootApplyStrategy;\n                return throwInternalError(`Unexpected rootApplyStrategy ${this.rootApplyStrategy}`);\n        }\n    }\n    compiledMeta = compileMeta(this.metaJson);\n    cacheGetter(name, value) {\n        Object.defineProperty(this, name, { value });\n        return value;\n    }\n    get description() {\n        return this.cacheGetter(\"description\", this.meta?.description ??\n            this.$.resolvedConfig[this.kind].description(this));\n    }\n    // we don't cache this currently since it can be updated once a scope finishes\n    // resolving cyclic references, although it may be possible to ensure it is cached safely\n    get references() {\n        return Object.values(this.referencesById);\n    }\n    precedence = precedenceOfKind(this.kind);\n    precompilation;\n    // defined as an arrow function since it is often detached, e.g. when passing to tRPC\n    // otherwise, would run into issues with this binding\n    assert = (data, pipedFromCtx) => this(data, pipedFromCtx, errors => errors.throw());\n    traverse(data, pipedFromCtx) {\n        return this(data, pipedFromCtx, null);\n    }\n    get in() {\n        return this.cacheGetter(\"in\", this.getIo(\"in\"));\n    }\n    get out() {\n        return this.cacheGetter(\"out\", this.getIo(\"out\"));\n    }\n    // Should be refactored to use transform\n    // https://github.com/arktypeio/arktype/issues/1020\n    getIo(ioKind) {\n        if (!this.includesTransform)\n            return this;\n        const ioInner = {};\n        for (const [k, v] of this.innerEntries) {\n            const keySchemaImplementation = this.impl.keys[k];\n            if (keySchemaImplementation.reduceIo)\n                keySchemaImplementation.reduceIo(ioKind, ioInner, v);\n            else if (keySchemaImplementation.child) {\n                const childValue = v;\n                ioInner[k] =\n                    isArray(childValue) ?\n                        childValue.map(child => child[ioKind])\n                        : childValue[ioKind];\n            }\n            else\n                ioInner[k] = v;\n        }\n        return this.$.node(this.kind, ioInner);\n    }\n    toJSON() {\n        return this.json;\n    }\n    toString() {\n        return `Type<${this.expression}>`;\n    }\n    equals(r) {\n        const rNode = isNode(r) ? r : this.$.parseDefinition(r);\n        return this.innerHash === rNode.innerHash;\n    }\n    ifEquals(r) {\n        return this.equals(r) ? this : undefined;\n    }\n    hasKind(kind) {\n        return this.kind === kind;\n    }\n    assertHasKind(kind) {\n        if (this.kind !== kind)\n            throwError(`${this.kind} node was not of asserted kind ${kind}`);\n        return this;\n    }\n    hasKindIn(...kinds) {\n        return kinds.includes(this.kind);\n    }\n    assertHasKindIn(...kinds) {\n        if (!includes(kinds, this.kind))\n            throwError(`${this.kind} node was not one of asserted kinds ${kinds}`);\n        return this;\n    }\n    isBasis() {\n        return includes(basisKinds, this.kind);\n    }\n    isConstraint() {\n        return includes(constraintKinds, this.kind);\n    }\n    isStructural() {\n        return includes(structuralKinds, this.kind);\n    }\n    isRefinement() {\n        return includes(refinementKinds, this.kind);\n    }\n    isRoot() {\n        return includes(rootKinds, this.kind);\n    }\n    isUnknown() {\n        return this.hasKind(\"intersection\") && this.children.length === 0;\n    }\n    isNever() {\n        return this.hasKind(\"union\") && this.children.length === 0;\n    }\n    hasUnit(value) {\n        return this.hasKind(\"unit\") && this.allows(value);\n    }\n    hasOpenIntersection() {\n        return this.impl.intersectionIsOpen;\n    }\n    get nestableExpression() {\n        return this.expression;\n    }\n    select(selector) {\n        const normalized = NodeSelector.normalize(selector);\n        return this._select(normalized);\n    }\n    _select(selector) {\n        let nodes = NodeSelector.applyBoundary[selector.boundary ?? \"references\"](this);\n        if (selector.kind)\n            nodes = nodes.filter(n => n.kind === selector.kind);\n        if (selector.where)\n            nodes = nodes.filter(selector.where);\n        return NodeSelector.applyMethod[selector.method ?? \"filter\"](nodes, this, selector);\n    }\n    transform(mapper, opts) {\n        return this._transform(mapper, this._createTransformContext(opts));\n    }\n    _createTransformContext(opts) {\n        return {\n            root: this,\n            selected: undefined,\n            seen: {},\n            path: [],\n            parseOptions: {\n                prereduced: opts?.prereduced ?? false\n            },\n            undeclaredKeyHandling: undefined,\n            ...opts\n        };\n    }\n    _transform(mapper, ctx) {\n        const $ = ctx.bindScope ?? this.$;\n        if (ctx.seen[this.id])\n            // Cyclic handling needs to be made more robust\n            // https://github.com/arktypeio/arktype/issues/944\n            return this.$.lazilyResolve(ctx.seen[this.id]);\n        if (ctx.shouldTransform?.(this, ctx) === false)\n            return this;\n        let transformedNode;\n        ctx.seen[this.id] = () => transformedNode;\n        if (this.hasKind(\"structure\") &&\n            this.undeclared !== ctx.undeclaredKeyHandling) {\n            ctx = {\n                ...ctx,\n                undeclaredKeyHandling: this.undeclared\n            };\n        }\n        const innerWithTransformedChildren = flatMorph(this.inner, (k, v) => {\n            if (!this.impl.keys[k].child)\n                return [k, v];\n            const children = v;\n            if (!isArray(children)) {\n                const transformed = children._transform(mapper, ctx);\n                return transformed ? [k, transformed] : [];\n            }\n            // if the value was previously explicitly set to an empty list,\n            // (e.g. branches for `never`), ensure it is not pruned\n            if (children.length === 0)\n                return [k, v];\n            const transformed = children.flatMap(n => {\n                const transformedChild = n._transform(mapper, ctx);\n                return transformedChild ?? [];\n            });\n            return transformed.length ? [k, transformed] : [];\n        });\n        delete ctx.seen[this.id];\n        const innerWithMeta = Object.assign(innerWithTransformedChildren, {\n            meta: this.meta\n        });\n        const transformedInner = ctx.selected && !ctx.selected.includes(this) ?\n            innerWithMeta\n            : mapper(this.kind, innerWithMeta, ctx);\n        if (transformedInner === null)\n            return null;\n        if (isNode(transformedInner))\n            return (transformedNode = transformedInner);\n        const transformedKeys = Object.keys(transformedInner);\n        const hasNoTypedKeys = transformedKeys.length === 0 ||\n            (transformedKeys.length === 1 && transformedKeys[0] === \"meta\");\n        if (hasNoTypedKeys &&\n            // if inner was previously an empty object (e.g. unknown) ensure it is not pruned\n            !isEmptyObject(this.inner))\n            return null;\n        if ((this.kind === \"required\" ||\n            this.kind === \"optional\" ||\n            this.kind === \"index\") &&\n            !(\"value\" in transformedInner)) {\n            return ctx.undeclaredKeyHandling ?\n                { ...transformedInner, value: $ark.intrinsic.unknown }\n                : null;\n        }\n        if (this.kind === \"morph\") {\n            ;\n            transformedInner.in ??= $ark.intrinsic\n                .unknown;\n        }\n        return (transformedNode = $.node(this.kind, transformedInner, ctx.parseOptions));\n    }\n    configureReferences(meta, selector = \"references\") {\n        const normalized = NodeSelector.normalize(selector);\n        const mapper = (typeof meta === \"string\" ?\n            (kind, inner) => ({\n                ...inner,\n                meta: { ...inner.meta, description: meta }\n            })\n            : typeof meta === \"function\" ?\n                (kind, inner) => ({ ...inner, meta: meta(inner.meta) })\n                : (kind, inner) => ({\n                    ...inner,\n                    meta: { ...inner.meta, ...meta }\n                }));\n        if (normalized.boundary === \"self\") {\n            return this.$.node(this.kind, mapper(this.kind, { ...this.inner, meta: this.meta }));\n        }\n        const rawSelected = this._select(normalized);\n        const selected = rawSelected && liftArray(rawSelected);\n        const shouldTransform = normalized.boundary === \"child\" ?\n            (node, ctx) => ctx.root.children.includes(node)\n            : normalized.boundary === \"shallow\" ? node => node.kind !== \"structure\"\n                : () => true;\n        return this.$.finalize(this.transform(mapper, {\n            shouldTransform,\n            selected\n        }));\n    }\n}\nconst NodeSelector = {\n    applyBoundary: {\n        self: node => [node],\n        child: node => [...node.children],\n        shallow: node => [...node.shallowReferences],\n        references: node => [...node.references]\n    },\n    applyMethod: {\n        filter: nodes => nodes,\n        assertFilter: (nodes, from, selector) => {\n            if (nodes.length === 0)\n                throwError(writeSelectAssertionMessage(from, selector));\n            return nodes;\n        },\n        find: nodes => nodes[0],\n        assertFind: (nodes, from, selector) => {\n            if (nodes.length === 0)\n                throwError(writeSelectAssertionMessage(from, selector));\n            return nodes[0];\n        }\n    },\n    normalize: (selector) => typeof selector === \"function\" ?\n        { boundary: \"references\", method: \"filter\", where: selector }\n        : typeof selector === \"string\" ?\n            isKeyOf(selector, NodeSelector.applyBoundary) ?\n                { method: \"filter\", boundary: selector }\n                : { boundary: \"references\", method: \"filter\", kind: selector }\n            : { boundary: \"references\", method: \"filter\", ...selector }\n};\nconst writeSelectAssertionMessage = (from, selector) => `${from} had no references matching ${printable(selector)}.`;\nexport const typePathToPropString = (path) => stringifyPath(path, {\n    stringifyNonKey: node => node.expression\n});\nconst referenceMatcher = /\"(\\$ark\\.[^\"]+)\"/g;\nconst compileMeta = (metaJson) => JSON.stringify(metaJson).replaceAll(referenceMatcher, \"$1\");\nexport const flatRef = (path, node) => ({\n    path,\n    node,\n    propString: typePathToPropString(path)\n});\nexport const flatRefsAreEqual = (l, r) => l.propString === r.propString && l.node.equals(r.node);\nexport const appendUniqueFlatRefs = (existing, refs) => appendUnique(existing, refs, {\n    isEqual: flatRefsAreEqual\n});\nexport const appendUniqueNodes = (existing, refs) => appendUnique(existing, refs, {\n    isEqual: (l, r) => l.equals(r)\n});\n", "import { isArray, stringifyPath, throwParseError } from \"@ark/util\";\nimport { $ark } from \"./registry.js\";\nimport { isNode } from \"./utils.js\";\nexport class Disjoint extends Array {\n    static init(kind, l, r, ctx) {\n        return new Disjoint({\n            kind,\n            l,\n            r,\n            path: ctx?.path ?? [],\n            optional: ctx?.optional ?? false\n        });\n    }\n    add(kind, l, r, ctx) {\n        this.push({\n            kind,\n            l,\n            r,\n            path: ctx?.path ?? [],\n            optional: ctx?.optional ?? false\n        });\n        return this;\n    }\n    get summary() {\n        return this.describeReasons();\n    }\n    describeReasons() {\n        if (this.length === 1) {\n            const { path, l, r } = this[0];\n            const pathString = stringifyPath(path);\n            return writeUnsatisfiableExpressionError(`Intersection${pathString && ` at ${pathString}`} of ${describeReasons(l, r)}`);\n        }\n        return `The following intersections result in unsatisfiable types:\\n• ${this.map(({ path, l, r }) => `${path}: ${describeReasons(l, r)}`).join(\"\\n• \")}`;\n    }\n    throw() {\n        return throwParseError(this.describeReasons());\n    }\n    invert() {\n        const result = this.map(entry => ({\n            ...entry,\n            l: entry.r,\n            r: entry.l\n        }));\n        // Workaround for Static Hermes, which doesn't preserve the Array subclass here\n        // https://github.com/arktypeio/arktype/issues/1027\n        if (!(result instanceof Disjoint))\n            return new Disjoint(...result);\n        return result;\n    }\n    withPrefixKey(key, kind) {\n        return this.map(entry => ({\n            ...entry,\n            path: [key, ...entry.path],\n            optional: entry.optional || kind === \"optional\"\n        }));\n    }\n    toNeverIfDisjoint() {\n        return $ark.intrinsic.never;\n    }\n}\nconst describeReasons = (l, r) => `${describeReason(l)} and ${describeReason(r)}`;\nconst describeReason = (value) => isNode(value) ? value.expression\n    : isArray(value) ? value.map(describeReason).join(\" | \") || \"never\"\n        : String(value);\nexport const writeUnsatisfiableExpressionError = (expression) => `${expression} results in an unsatisfiable type`;\n", "import { Disjoint } from \"./disjoint.js\";\nimport { rootKinds } from \"./implement.js\";\nimport { isNode } from \"./utils.js\";\nconst intersectionCache = {};\nexport const intersectNodesRoot = (l, r, $) => intersectOrPipeNodes(l, r, {\n    $,\n    invert: false,\n    pipe: false\n});\nexport const pipeNodesRoot = (l, r, $) => intersectOrPipeNodes(l, r, {\n    $,\n    invert: false,\n    pipe: true\n});\nexport const intersectOrPipeNodes = ((l, r, ctx) => {\n    const operator = ctx.pipe ? \"|>\" : \"&\";\n    const lrCacheKey = `${l.hash}${operator}${r.hash}`;\n    if (intersectionCache[lrCacheKey] !== undefined)\n        return intersectionCache[lrCacheKey];\n    if (!ctx.pipe) {\n        // we can only use this for the commutative & operator\n        const rlCacheKey = `${r.hash}${operator}${l.hash}`;\n        if (intersectionCache[rlCacheKey] !== undefined) {\n            // if the cached result was a Disjoint and the operands originally\n            // appeared in the opposite order, we need to invert it to match\n            const rlResult = intersectionCache[rlCacheKey];\n            const lrResult = rlResult instanceof Disjoint ? rlResult.invert() : rlResult;\n            // add the lr result to the cache directly to bypass this check in the future\n            intersectionCache[lrCacheKey] = lrResult;\n            return lrResult;\n        }\n    }\n    const isPureIntersection = !ctx.pipe || (!l.includesTransform && !r.includesTransform);\n    if (isPureIntersection && l.equals(r))\n        return l;\n    let result = isPureIntersection ? _intersectNodes(l, r, ctx)\n        : l.hasKindIn(...rootKinds) ?\n            // if l is a RootNode, r will be as well\n            _pipeNodes(l, r, ctx)\n            : _intersectNodes(l, r, ctx);\n    if (isNode(result)) {\n        // if the result equals one of the operands, preserve its metadata by\n        // returning the original reference\n        if (l.equals(result))\n            result = l;\n        else if (r.equals(result))\n            result = r;\n    }\n    intersectionCache[lrCacheKey] = result;\n    return result;\n});\nconst _intersectNodes = (l, r, ctx) => {\n    const leftmostKind = l.precedence < r.precedence ? l.kind : r.kind;\n    const implementation = l.impl.intersections[r.kind] ?? r.impl.intersections[l.kind];\n    if (implementation === undefined) {\n        // should be two ConstraintNodes that have no relation\n        // this could also happen if a user directly intersects a Type and a ConstraintNode,\n        // but that is not allowed by the external function signature\n        return null;\n    }\n    else if (leftmostKind === l.kind)\n        return implementation(l, r, ctx);\n    else {\n        let result = implementation(r, l, { ...ctx, invert: !ctx.invert });\n        if (result instanceof Disjoint)\n            result = result.invert();\n        return result;\n    }\n};\nconst _pipeNodes = (l, r, ctx) => l.includesTransform || r.includesTransform ?\n    ctx.invert ?\n        pipeMorphed(r, l, ctx)\n        : pipeMorphed(l, r, ctx)\n    : _intersectNodes(l, r, ctx);\nconst pipeMorphed = (from, to, ctx) => from.distribute(fromBranch => _pipeMorphed(fromBranch, to, ctx), results => {\n    const viableBranches = results.filter(isNode);\n    if (viableBranches.length === 0)\n        return Disjoint.init(\"union\", from.branches, to.branches);\n    // if the input type has changed, create a new node without preserving metadata\n    if (viableBranches.length < from.branches.length ||\n        !from.branches.every((branch, i) => branch.in.equals(viableBranches[i].in)))\n        return ctx.$.parseSchema(viableBranches);\n    // otherwise, the input has not changed so preserve metadata\n    let meta;\n    if (viableBranches.length === 1) {\n        const onlyBranch = viableBranches[0];\n        if (!meta)\n            return onlyBranch;\n        return ctx.$.node(\"morph\", {\n            ...onlyBranch.inner,\n            in: onlyBranch.in.configure(meta, \"self\")\n        });\n    }\n    const schema = {\n        branches: viableBranches\n    };\n    if (meta)\n        schema.meta = meta;\n    return ctx.$.parseSchema(schema);\n});\nconst _pipeMorphed = (from, to, ctx) => {\n    const fromIsMorph = from.hasKind(\"morph\");\n    if (fromIsMorph) {\n        const morphs = [...from.morphs];\n        if (from.lastMorphIfNode) {\n            // still piped from context, so allows appending additional morphs\n            const outIntersection = intersectOrPipeNodes(from.lastMorphIfNode, to, ctx);\n            if (outIntersection instanceof Disjoint)\n                return outIntersection;\n            morphs[morphs.length - 1] = outIntersection;\n        }\n        else\n            morphs.push(to);\n        return ctx.$.node(\"morph\", {\n            morphs,\n            in: from.inner.in\n        });\n    }\n    if (to.hasKind(\"morph\")) {\n        const inTersection = intersectOrPipeNodes(from, to.in, ctx);\n        if (inTersection instanceof Disjoint)\n            return inTersection;\n        return ctx.$.node(\"morph\", {\n            morphs: [to],\n            in: inTersection\n        });\n    }\n    return ctx.$.node(\"morph\", {\n        morphs: [to],\n        in: from\n    });\n};\n", "import { append, appendUnique, capitalize, isArray, throwInternalError, throwParseError } from \"@ark/util\";\nimport { BaseNode } from \"./node.js\";\nimport { Disjoint } from \"./shared/disjoint.js\";\nimport { compileObjectLiteral, constraintKeys } from \"./shared/implement.js\";\nimport { intersectNodesRoot, intersectOrPipeNodes } from \"./shared/intersections.js\";\nimport { $ark } from \"./shared/registry.js\";\nimport { arkKind } from \"./shared/utils.js\";\nexport class BaseConstraint extends BaseNode {\n    constructor(attachments, $) {\n        super(attachments, $);\n        // define as a getter to avoid it being enumerable/spreadable\n        Object.defineProperty(this, arkKind, {\n            value: \"constraint\",\n            enumerable: false\n        });\n    }\n    impliedSiblings;\n    intersect(r) {\n        return intersectNodesRoot(this, r, this.$);\n    }\n}\nexport class InternalPrimitiveConstraint extends BaseConstraint {\n    traverseApply = (data, ctx) => {\n        if (!this.traverseAllows(data, ctx))\n            ctx.errorFromNodeContext(this.errorContext);\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\")\n            js.return(this.compiledCondition);\n        else {\n            js.if(this.compiledNegation, () => js.line(`${js.ctx}.errorFromNodeContext(${this.compiledErrorContext})`));\n        }\n    }\n    get errorContext() {\n        return {\n            code: this.kind,\n            description: this.description,\n            meta: this.meta,\n            ...this.inner\n        };\n    }\n    get compiledErrorContext() {\n        return compileObjectLiteral(this.errorContext);\n    }\n}\nexport const constraintKeyParser = (kind) => (schema, ctx) => {\n    if (isArray(schema)) {\n        if (schema.length === 0) {\n            // Omit empty lists as input\n            return;\n        }\n        const nodes = schema.map(schema => ctx.$.node(kind, schema));\n        // predicate order must be preserved to ensure inputs are narrowed\n        // and checked in the correct order\n        if (kind === \"predicate\")\n            return nodes;\n        return nodes.sort((l, r) => (l.hash < r.hash ? -1 : 1));\n    }\n    const child = ctx.$.node(kind, schema);\n    return (child.hasOpenIntersection() ? [child] : child);\n};\nexport const intersectConstraints = (s) => {\n    const head = s.r.shift();\n    if (!head) {\n        let result = s.l.length === 0 && s.kind === \"structure\" ?\n            $ark.intrinsic.unknown.internal\n            : s.ctx.$.node(s.kind, Object.assign(s.baseInner, unflattenConstraints(s.l)), { prereduced: true });\n        for (const root of s.roots) {\n            if (result instanceof Disjoint)\n                return result;\n            result = intersectOrPipeNodes(root, result, s.ctx);\n        }\n        return result;\n    }\n    let matched = false;\n    for (let i = 0; i < s.l.length; i++) {\n        const result = intersectOrPipeNodes(s.l[i], head, s.ctx);\n        if (result === null)\n            continue;\n        if (result instanceof Disjoint)\n            return result;\n        if (!matched) {\n            if (result.isRoot()) {\n                s.roots.push(result);\n                s.l.splice(i);\n                return intersectConstraints(s);\n            }\n            s.l[i] = result;\n            matched = true;\n        }\n        else if (!s.l.includes(result)) {\n            return throwInternalError(`Unexpectedly encountered multiple distinct intersection results for refinement ${result}`);\n        }\n    }\n    if (!matched)\n        s.l.push(head);\n    if (s.kind === \"intersection\") {\n        if (head.impliedSiblings)\n            for (const node of head.impliedSiblings)\n                appendUnique(s.r, node);\n    }\n    return intersectConstraints(s);\n};\nexport const flattenConstraints = (inner) => {\n    const result = Object.entries(inner)\n        .flatMap(([k, v]) => k in constraintKeys ? v : [])\n        .sort((l, r) => l.precedence < r.precedence ? -1\n        : l.precedence > r.precedence ? 1\n            // preserve order for predicates\n            : l.kind === \"predicate\" && r.kind === \"predicate\" ? 0\n                : l.hash < r.hash ? -1\n                    : 1);\n    return result;\n};\nexport const unflattenConstraints = (constraints) => {\n    const inner = {};\n    for (const constraint of constraints) {\n        if (constraint.hasOpenIntersection()) {\n            inner[constraint.kind] = append(inner[constraint.kind], constraint);\n        }\n        else {\n            if (inner[constraint.kind]) {\n                return throwInternalError(`Unexpected intersection of closed refinements of kind ${constraint.kind}`);\n            }\n            inner[constraint.kind] = constraint;\n        }\n    }\n    return inner;\n};\nexport const throwInvalidOperandError = (...args) => throwParseError(writeInvalidOperandMessage(...args));\nexport const writeInvalidOperandMessage = (kind, expected, actual) => {\n    const actualDescription = actual.hasKind(\"morph\") ? \"a morph\"\n        : actual.isUnknown() ? \"unknown\"\n            : actual.exclude(expected).defaultShortDescription;\n    return `${capitalize(kind)} operand must be ${expected.description} (was ${actualDescription})`;\n};\n", "import { Callable, flatMorph, snapshot, throwParseError } from \"@ark/util\";\nimport { $ark } from \"./shared/registry.js\";\nimport { arkKind } from \"./shared/utils.js\";\nexport const parseGeneric = (paramDefs, bodyDef, $) => new GenericRoot(paramDefs, bodyDef, $, $, null);\nexport class LazyGenericBody extends Callable {\n}\nexport class GenericRoot extends Callable {\n    [arkKind] = \"generic\";\n    paramDefs;\n    bodyDef;\n    $;\n    arg$;\n    baseInstantiation;\n    hkt;\n    description;\n    constructor(paramDefs, bodyDef, $, arg$, hkt) {\n        super((...args) => {\n            const argNodes = flatMorph(this.names, (i, name) => {\n                const arg = this.arg$.parse(args[i]);\n                if (!arg.extends(this.constraints[i])) {\n                    throwParseError(writeUnsatisfiedParameterConstraintMessage(name, this.constraints[i].expression, arg.expression));\n                }\n                return [name, arg];\n            });\n            if (this.defIsLazy()) {\n                const def = this.bodyDef(argNodes);\n                return this.$.parse(def);\n            }\n            return this.$.parse(bodyDef, { args: argNodes });\n        });\n        this.paramDefs = paramDefs;\n        this.bodyDef = bodyDef;\n        this.$ = $;\n        this.arg$ = arg$;\n        this.hkt = hkt;\n        this.description =\n            hkt ?\n                (new hkt().description ?? `a generic type for ${hkt.constructor.name}`)\n                : \"a generic type\";\n        this.baseInstantiation = this(...this.constraints);\n    }\n    defIsLazy() {\n        return this.bodyDef instanceof LazyGenericBody;\n    }\n    cacheGetter(name, value) {\n        Object.defineProperty(this, name, { value });\n        return value;\n    }\n    get json() {\n        return this.cacheGetter(\"json\", {\n            params: this.params.map(param => param[1].isUnknown() ? param[0] : [param[0], param[1].json]),\n            body: snapshot(this.bodyDef)\n        });\n    }\n    get params() {\n        return this.cacheGetter(\"params\", this.paramDefs.map(param => typeof param === \"string\" ?\n            [param, $ark.intrinsic.unknown]\n            : [param[0], this.$.parse(param[1])]));\n    }\n    get names() {\n        return this.cacheGetter(\"names\", this.params.map(e => e[0]));\n    }\n    get constraints() {\n        return this.cacheGetter(\"constraints\", this.params.map(e => e[1]));\n    }\n    get internal() {\n        return this;\n    }\n    get referencesById() {\n        return this.baseInstantiation.internal.referencesById;\n    }\n    get references() {\n        return this.baseInstantiation.internal.references;\n    }\n}\nexport const writeUnsatisfiedParameterConstraintMessage = (name, constraint, arg) => `${name} must be assignable to ${constraint} (was ${arg})`;\n", "import { BaseConstraint } from \"./constraint.js\";\nimport { compileObjectLiteral, implementNode } from \"./shared/implement.js\";\nimport { registeredReference } from \"./shared/registry.js\";\nconst implementation = implementNode({\n    kind: \"predicate\",\n    hasAssociatedError: true,\n    collapsibleKey: \"predicate\",\n    keys: {\n        predicate: {}\n    },\n    normalize: schema => typeof schema === \"function\" ? { predicate: schema } : schema,\n    defaults: {\n        description: node => `valid according to ${node.predicate.name || \"an anonymous predicate\"}`\n    },\n    intersectionIsOpen: true,\n    intersections: {\n        // as long as the narrows in l and r are individually safe to check\n        // in the order they're specified, checking them in the order\n        // resulting from this intersection should also be safe.\n        predicate: () => null\n    }\n});\nexport class PredicateNode extends BaseConstraint {\n    serializedPredicate = registeredReference(this.predicate);\n    compiledCondition = `${this.serializedPredicate}(data, ctx)`;\n    compiledNegation = `!${this.compiledCondition}`;\n    impliedBasis = null;\n    expression = this.serializedPredicate;\n    traverseAllows = this.predicate;\n    errorContext = {\n        code: \"predicate\",\n        description: this.description,\n        meta: this.meta\n    };\n    compiledErrorContext = compileObjectLiteral(this.errorContext);\n    traverseApply = (data, ctx) => {\n        if (!this.predicate(data, ctx.external) && !ctx.hasError())\n            ctx.errorFromNodeContext(this.errorContext);\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            js.return(this.compiledCondition);\n            return;\n        }\n        js.if(`${this.compiledNegation} && !ctx.hasError()`, () => js.line(`ctx.errorFromNodeContext(${this.compiledErrorContext})`));\n    }\n    reduceJsonSchema(base, ctx) {\n        return ctx.fallback.predicate({\n            code: \"predicate\",\n            base,\n            predicate: this.predicate\n        });\n    }\n}\nexport const Predicate = {\n    implementation,\n    Node: PredicateNode\n};\n", "import { throwParseError } from \"@ark/util\";\nimport { InternalPrimitiveConstraint, writeInvalidOperandMessage } from \"../constraint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { $ark } from \"../shared/registry.js\";\nconst implementation = implementNode({\n    kind: \"divisor\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {\n            parse: divisor => Number.isInteger(divisor) ? divisor : (throwParseError(writeNonIntegerDivisorMessage(divisor)))\n        }\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    hasAssociatedError: true,\n    defaults: {\n        description: node => node.rule === 1 ? \"an integer\"\n            : node.rule === 2 ? \"even\"\n                : `a multiple of ${node.rule}`\n    },\n    intersections: {\n        divisor: (l, r, ctx) => ctx.$.node(\"divisor\", {\n            rule: Math.abs((l.rule * r.rule) / greatestCommonDivisor(l.rule, r.rule))\n        })\n    },\n    obviatesBasisDescription: true\n});\nexport class DivisorNode extends InternalPrimitiveConstraint {\n    traverseAllows = data => data % this.rule === 0;\n    compiledCondition = `data % ${this.rule} === 0`;\n    compiledNegation = `data % ${this.rule} !== 0`;\n    impliedBasis = $ark.intrinsic.number.internal;\n    expression = `% ${this.rule}`;\n    reduceJsonSchema(schema) {\n        schema.type = \"integer\";\n        if (this.rule === 1)\n            return schema;\n        schema.multipleOf = this.rule;\n        return schema;\n    }\n}\nexport const Divisor = {\n    implementation,\n    Node: DivisorNode\n};\nexport const writeIndivisibleMessage = (t) => writeInvalidOperandMessage(\"divisor\", $ark.intrinsic.number, t);\nexport const writeNonIntegerDivisorMessage = (divisor) => `divisor must be an integer (was ${divisor})`;\n// https://en.wikipedia.org/wiki/Euclidean_algorithm\nconst greatestCommonDivisor = (l, r) => {\n    let previous;\n    let greatestCommonDivisor = l;\n    let current = r;\n    while (current !== 0) {\n        previous = current;\n        current = greatestCommonDivisor % current;\n        greatestCommonDivisor = previous;\n    }\n    return greatestCommonDivisor;\n};\n", "import { isKeyOf, throwParseError } from \"@ark/util\";\nimport { InternalPrimitiveConstraint } from \"../constraint.js\";\nexport class BaseRange extends InternalPrimitiveConstraint {\n    boundOperandKind = operandKindsByBoundKind[this.kind];\n    compiledActual = this.boundOperandKind === \"value\" ? `data`\n        : this.boundOperandKind === \"length\" ? `data.length`\n            : `data.valueOf()`;\n    comparator = compileComparator(this.kind, this.exclusive);\n    numericLimit = this.rule.valueOf();\n    expression = `${this.comparator} ${this.rule}`;\n    compiledCondition = `${this.compiledActual} ${this.comparator} ${this.numericLimit}`;\n    compiledNegation = `${this.compiledActual} ${negatedComparators[this.comparator]} ${this.numericLimit}`;\n    // we need to compute stringLimit before errorContext, which references it\n    // transitively through description for date bounds\n    stringLimit = this.boundOperandKind === \"date\" ?\n        dateLimitToString(this.numericLimit)\n        : `${this.numericLimit}`;\n    limitKind = this.comparator[\"0\"] === \"<\" ? \"upper\" : \"lower\";\n    isStricterThan(r) {\n        const thisLimitIsStricter = this.limitKind === \"upper\" ?\n            this.numericLimit < r.numericLimit\n            : this.numericLimit > r.numericLimit;\n        return (thisLimitIsStricter ||\n            (this.numericLimit === r.numericLimit &&\n                this.exclusive === true &&\n                !r.exclusive));\n    }\n    overlapsRange(r) {\n        if (this.isStricterThan(r))\n            return false;\n        if (this.numericLimit === r.numericLimit && (this.exclusive || r.exclusive))\n            return false;\n        return true;\n    }\n    overlapIsUnit(r) {\n        return (this.numericLimit === r.numericLimit && !this.exclusive && !r.exclusive);\n    }\n}\nconst negatedComparators = {\n    \"<\": \">=\",\n    \"<=\": \">\",\n    \">\": \"<=\",\n    \">=\": \"<\"\n};\nexport const boundKindPairsByLower = {\n    min: \"max\",\n    minLength: \"maxLength\",\n    after: \"before\"\n};\nexport const parseExclusiveKey = {\n    // omit key with value false since it is the default\n    parse: (flag) => flag || undefined\n};\nexport const createLengthSchemaNormalizer = (kind) => (schema) => {\n    if (typeof schema === \"number\")\n        return { rule: schema };\n    const { exclusive, ...normalized } = schema;\n    return exclusive ?\n        {\n            ...normalized,\n            rule: kind === \"minLength\" ? normalized.rule + 1 : normalized.rule - 1\n        }\n        : normalized;\n};\nexport const createDateSchemaNormalizer = (kind) => (schema) => {\n    if (typeof schema === \"number\" ||\n        typeof schema === \"string\" ||\n        schema instanceof Date)\n        return { rule: schema };\n    const { exclusive, ...normalized } = schema;\n    if (!exclusive)\n        return normalized;\n    const numericLimit = typeof normalized.rule === \"number\" ? normalized.rule\n        : typeof normalized.rule === \"string\" ?\n            new Date(normalized.rule).valueOf()\n            : normalized.rule.valueOf();\n    return exclusive ?\n        {\n            ...normalized,\n            rule: kind === \"after\" ? numericLimit + 1 : numericLimit - 1\n        }\n        : normalized;\n};\nexport const parseDateLimit = (limit) => typeof limit === \"string\" || typeof limit === \"number\" ?\n    new Date(limit)\n    : limit;\nexport const writeInvalidLengthBoundMessage = (kind, limit) => `${kind} bound must be a positive integer (was ${limit})`;\nexport const createLengthRuleParser = (kind) => (limit) => {\n    if (!Number.isInteger(limit) || limit < 0)\n        throwParseError(writeInvalidLengthBoundMessage(kind, limit));\n    return limit;\n};\nconst operandKindsByBoundKind = {\n    min: \"value\",\n    max: \"value\",\n    minLength: \"length\",\n    maxLength: \"length\",\n    after: \"date\",\n    before: \"date\"\n};\nexport const compileComparator = (kind, exclusive) => `${isKeyOf(kind, boundKindPairsByLower) ? \">\" : \"<\"}${exclusive ? \"\" : \"=\"}`;\nexport const dateLimitToString = (limit) => typeof limit === \"string\" ? limit : new Date(limit).toLocaleString();\nexport const writeUnboundableMessage = (root) => `Bounded expression ${root} must be exactly one of number, string, Array, or Date`;\n", "import { describeCollapsibleDate } from \"@ark/util\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { BaseRange, createDateSchemaNormalizer, parseDateLimit } from \"./range.js\";\nconst implementation = implementNode({\n    kind: \"after\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {\n            parse: parseDateLimit,\n            serialize: schema => schema.toISOString()\n        }\n    },\n    normalize: createDateSchemaNormalizer(\"after\"),\n    defaults: {\n        description: node => `${node.collapsibleLimitString} or later`,\n        actual: describeCollapsibleDate\n    },\n    intersections: {\n        after: (l, r) => (l.isStricterThan(r) ? l : r)\n    }\n});\nexport class AfterNode extends BaseRange {\n    impliedBasis = $ark.intrinsic.Date.internal;\n    collapsibleLimitString = describeCollapsibleDate(this.rule);\n    traverseAllows = data => data >= this.rule;\n    reduceJsonSchema(base, ctx) {\n        return ctx.fallback.date({ code: \"date\", base, after: this.rule });\n    }\n}\nexport const After = {\n    implementation,\n    Node: AfterNode\n};\n", "import { describeCollapsibleDate } from \"@ark/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { BaseRange, createDateSchemaNormalizer, parseDateLimit } from \"./range.js\";\nconst implementation = implementNode({\n    kind: \"before\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {\n            parse: parseDateLimit,\n            serialize: schema => schema.toISOString()\n        }\n    },\n    normalize: createDateSchemaNormalizer(\"before\"),\n    defaults: {\n        description: node => `${node.collapsibleLimitString} or earlier`,\n        actual: describeCollapsibleDate\n    },\n    intersections: {\n        before: (l, r) => (l.isStricterThan(r) ? l : r),\n        after: (before, after, ctx) => before.overlapsRange(after) ?\n            before.overlapIsUnit(after) ?\n                ctx.$.node(\"unit\", { unit: before.rule })\n                : null\n            : Disjoint.init(\"range\", before, after)\n    }\n});\nexport class BeforeNode extends BaseRange {\n    collapsibleLimitString = describeCollapsibleDate(this.rule);\n    traverseAllows = data => data <= this.rule;\n    impliedBasis = $ark.intrinsic.Date.internal;\n    reduceJsonSchema(base, ctx) {\n        return ctx.fallback.date({ code: \"date\", base, before: this.rule });\n    }\n}\nexport const Before = {\n    implementation,\n    Node: BeforeNode\n};\n", "import { InternalPrimitiveConstraint } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { ToJsonSchema } from \"../shared/toJsonSchema.js\";\nimport { createLengthRuleParser } from \"./range.js\";\nconst implementation = implementNode({\n    kind: \"exactLength\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {\n            parse: createLengthRuleParser(\"exactLength\")\n        }\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    hasAssociatedError: true,\n    defaults: {\n        description: node => `exactly length ${node.rule}`,\n        actual: data => `${data.length}`\n    },\n    intersections: {\n        exactLength: (l, r, ctx) => Disjoint.init(\"unit\", ctx.$.node(\"unit\", { unit: l.rule }), ctx.$.node(\"unit\", { unit: r.rule }), { path: [\"length\"] }),\n        minLength: (exactLength, minLength) => exactLength.rule >= minLength.rule ?\n            exactLength\n            : Disjoint.init(\"range\", exactLength, minLength),\n        maxLength: (exactLength, maxLength) => exactLength.rule <= maxLength.rule ?\n            exactLength\n            : Disjoint.init(\"range\", exactLength, maxLength)\n    }\n});\nexport class ExactLengthNode extends InternalPrimitiveConstraint {\n    traverseAllows = data => data.length === this.rule;\n    compiledCondition = `data.length === ${this.rule}`;\n    compiledNegation = `data.length !== ${this.rule}`;\n    impliedBasis = $ark.intrinsic.lengthBoundable.internal;\n    expression = `== ${this.rule}`;\n    reduceJsonSchema(schema) {\n        switch (schema.type) {\n            case \"string\":\n                schema.minLength = this.rule;\n                schema.maxLength = this.rule;\n                return schema;\n            case \"array\":\n                schema.minItems = this.rule;\n                schema.maxItems = this.rule;\n                return schema;\n            default:\n                return ToJsonSchema.throwInternalOperandError(\"exactLength\", schema);\n        }\n    }\n}\nexport const ExactLength = {\n    implementation,\n    Node: ExactLengthNode\n};\n", "import { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nconst implementation = implementNode({\n    kind: \"max\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => {\n            if (node.rule === 0)\n                return node.exclusive ? \"negative\" : \"non-positive\";\n            return `${node.exclusive ? \"less than\" : \"at most\"} ${node.rule}`;\n        }\n    },\n    intersections: {\n        max: (l, r) => (l.isStricterThan(r) ? l : r),\n        min: (max, min, ctx) => max.overlapsRange(min) ?\n            max.overlapIsUnit(min) ?\n                ctx.$.node(\"unit\", { unit: max.rule })\n                : null\n            : Disjoint.init(\"range\", max, min)\n    },\n    obviatesBasisDescription: true\n});\nexport class MaxNode extends BaseRange {\n    impliedBasis = $ark.intrinsic.number.internal;\n    traverseAllows = this.exclusive ? data => data < this.rule : data => data <= this.rule;\n    reduceJsonSchema(schema) {\n        if (this.exclusive)\n            schema.exclusiveMaximum = this.rule;\n        else\n            schema.maximum = this.rule;\n        return schema;\n    }\n}\nexport const Max = {\n    implementation,\n    Node: MaxNode\n};\n", "import { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { ToJsonSchema } from \"../shared/toJsonSchema.js\";\nimport { BaseRange, createLengthRuleParser, createLengthSchemaNormalizer } from \"./range.js\";\nconst implementation = implementNode({\n    kind: \"maxLength\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {\n            parse: createLengthRuleParser(\"maxLength\")\n        }\n    },\n    reduce: (inner, $) => inner.rule === 0 ? $.node(\"exactLength\", inner) : undefined,\n    normalize: createLengthSchemaNormalizer(\"maxLength\"),\n    defaults: {\n        description: node => `at most length ${node.rule}`,\n        actual: data => `${data.length}`\n    },\n    intersections: {\n        maxLength: (l, r) => (l.isStricterThan(r) ? l : r),\n        minLength: (max, min, ctx) => max.overlapsRange(min) ?\n            max.overlapIsUnit(min) ?\n                ctx.$.node(\"exactLength\", { rule: max.rule })\n                : null\n            : Disjoint.init(\"range\", max, min)\n    }\n});\nexport class MaxLengthNode extends BaseRange {\n    impliedBasis = $ark.intrinsic.lengthBoundable.internal;\n    traverseAllows = data => data.length <= this.rule;\n    reduceJsonSchema(schema) {\n        switch (schema.type) {\n            case \"string\":\n                schema.maxLength = this.rule;\n                return schema;\n            case \"array\":\n                schema.maxItems = this.rule;\n                return schema;\n            default:\n                return ToJsonSchema.throwInternalOperandError(\"maxLength\", schema);\n        }\n    }\n}\nexport const MaxLength = {\n    implementation,\n    Node: MaxLengthNode\n};\n", "import { implementNode } from \"../shared/implement.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nconst implementation = implementNode({\n    kind: \"min\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => {\n            if (node.rule === 0)\n                return node.exclusive ? \"positive\" : \"non-negative\";\n            return `${node.exclusive ? \"more than\" : \"at least\"} ${node.rule}`;\n        }\n    },\n    intersections: {\n        min: (l, r) => (l.isStricterThan(r) ? l : r)\n    },\n    obviatesBasisDescription: true\n});\nexport class MinNode extends BaseRange {\n    impliedBasis = $ark.intrinsic.number.internal;\n    traverseAllows = this.exclusive ? data => data > this.rule : data => data >= this.rule;\n    reduceJsonSchema(schema) {\n        if (this.exclusive)\n            schema.exclusiveMinimum = this.rule;\n        else\n            schema.minimum = this.rule;\n        return schema;\n    }\n}\nexport const Min = {\n    implementation,\n    Node: MinNode\n};\n", "import { implementNode } from \"../shared/implement.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { ToJsonSchema } from \"../shared/toJsonSchema.js\";\nimport { BaseRange, createLengthRuleParser, createLengthSchemaNormalizer } from \"./range.js\";\nconst implementation = implementNode({\n    kind: \"minLength\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {\n            parse: createLengthRuleParser(\"minLength\")\n        }\n    },\n    reduce: inner => inner.rule === 0 ?\n        // a minimum length of zero is trivially satisfied\n        $ark.intrinsic.unknown\n        : undefined,\n    normalize: createLengthSchemaNormalizer(\"minLength\"),\n    defaults: {\n        description: node => node.rule === 1 ? \"non-empty\" : `at least length ${node.rule}`,\n        // avoid default message like \"must be non-empty (was 0)\"\n        actual: data => (data.length === 0 ? \"\" : `${data.length}`)\n    },\n    intersections: {\n        minLength: (l, r) => (l.isStricterThan(r) ? l : r)\n    }\n});\nexport class MinLengthNode extends BaseRange {\n    impliedBasis = $ark.intrinsic.lengthBoundable.internal;\n    traverseAllows = data => data.length >= this.rule;\n    reduceJsonSchema(schema) {\n        switch (schema.type) {\n            case \"string\":\n                schema.minLength = this.rule;\n                return schema;\n            case \"array\":\n                schema.minItems = this.rule;\n                return schema;\n            default:\n                return ToJsonSchema.throwInternalOperandError(\"minLength\", schema);\n        }\n    }\n}\nexport const MinLength = {\n    implementation,\n    Node: MinLengthNode\n};\n", "import { After } from \"./after.js\";\nimport { Before } from \"./before.js\";\nimport { ExactLength } from \"./exactLength.js\";\nimport { Max } from \"./max.js\";\nimport { MaxLength } from \"./maxLength.js\";\nimport { Min } from \"./min.js\";\nimport { MinLength } from \"./minLength.js\";\nexport const boundImplementationsByKind = {\n    min: Min.implementation,\n    max: Max.implementation,\n    minLength: MinLength.implementation,\n    maxLength: MaxLength.implementation,\n    exactLength: ExactLength.implementation,\n    after: After.implementation,\n    before: Before.implementation\n};\nexport const boundClassesByKind = {\n    min: Min.Node,\n    max: Max.Node,\n    minLength: MinLength.Node,\n    maxLength: MaxLength.Node,\n    exactLength: ExactLength.Node,\n    after: After.Node,\n    before: Before.Node\n};\n", "import { InternalPrimitiveConstraint } from \"../constraint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { $ark } from \"../shared/registry.js\";\nconst implementation = implementNode({\n    kind: \"pattern\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {},\n        flags: {}\n    },\n    normalize: schema => typeof schema === \"string\" ? { rule: schema }\n        : schema instanceof RegExp ?\n            schema.flags ?\n                { rule: schema.source, flags: schema.flags }\n                : { rule: schema.source }\n            : schema,\n    obviatesBasisDescription: true,\n    obviatesBasisExpression: true,\n    hasAssociatedError: true,\n    intersectionIsOpen: true,\n    defaults: {\n        description: node => `matched by ${node.rule}`\n    },\n    intersections: {\n        // for now, non-equal regex are naively intersected:\n        // https://github.com/arktypeio/arktype/issues/853\n        pattern: () => null\n    }\n});\nexport class PatternNode extends InternalPrimitiveConstraint {\n    instance = new RegExp(this.rule, this.flags);\n    expression = `${this.instance}`;\n    traverseAllows = this.instance.test.bind(this.instance);\n    compiledCondition = `${this.expression}.test(data)`;\n    compiledNegation = `!${this.compiledCondition}`;\n    impliedBasis = $ark.intrinsic.string.internal;\n    reduceJsonSchema(base, ctx) {\n        if (base.pattern) {\n            return ctx.fallback.patternIntersection({\n                code: \"patternIntersection\",\n                base: base,\n                pattern: this.rule\n            });\n        }\n        base.pattern = this.rule;\n        return base;\n    }\n}\nexport const Pattern = {\n    implementation,\n    Node: PatternNode\n};\n", "import { domainDescriptions, entriesOf, flatMorph, hasDomain, isArray, isEmptyObject, printable, throwInternalError, throwParseError, unset } from \"@ark/util\";\nimport { nodeClassesByKind, nodeImplementationsByKind } from \"./kinds.js\";\nimport { Disjoint } from \"./shared/disjoint.js\";\nimport { constraintKeys, defaultValueSerializer, isNodeKind, precedenceOfKind } from \"./shared/implement.js\";\nimport { $ark } from \"./shared/registry.js\";\nimport { hasArkKind, isNode } from \"./shared/utils.js\";\nexport const schemaKindOf = (schema, allowedKinds) => {\n    const kind = discriminateRootKind(schema);\n    if (allowedKinds && !allowedKinds.includes(kind)) {\n        return throwParseError(`Root of kind ${kind} should be one of ${allowedKinds}`);\n    }\n    return kind;\n};\nconst discriminateRootKind = (schema) => {\n    if (hasArkKind(schema, \"root\"))\n        return schema.kind;\n    if (typeof schema === \"string\") {\n        return (schema[0] === \"$\" ? \"alias\"\n            : schema in domainDescriptions ? \"domain\"\n                : \"proto\");\n    }\n    if (typeof schema === \"function\")\n        return \"proto\";\n    // throw at end of function\n    if (typeof schema !== \"object\" || schema === null)\n        return throwParseError(writeInvalidSchemaMessage(schema));\n    if (\"morphs\" in schema)\n        return \"morph\";\n    if (\"branches\" in schema || isArray(schema))\n        return \"union\";\n    if (\"unit\" in schema)\n        return \"unit\";\n    if (\"reference\" in schema)\n        return \"alias\";\n    const schemaKeys = Object.keys(schema);\n    if (schemaKeys.length === 0 || schemaKeys.some(k => k in constraintKeys))\n        return \"intersection\";\n    if (\"proto\" in schema)\n        return \"proto\";\n    if (\"domain\" in schema)\n        return \"domain\";\n    return throwParseError(writeInvalidSchemaMessage(schema));\n};\nexport const writeInvalidSchemaMessage = (schema) => `${printable(schema)} is not a valid type schema`;\nconst nodeCountsByPrefix = {};\nconst serializeListableChild = (listableNode) => isArray(listableNode) ?\n    listableNode.map(node => node.collapsibleJson)\n    : listableNode.collapsibleJson;\nexport const nodesByRegisteredId = {};\n$ark.nodesByRegisteredId = nodesByRegisteredId;\nexport const registerNodeId = (prefix) => {\n    nodeCountsByPrefix[prefix] ??= 0;\n    return `${prefix}${++nodeCountsByPrefix[prefix]}`;\n};\nexport const parseNode = (ctx) => {\n    const impl = nodeImplementationsByKind[ctx.kind];\n    const configuredSchema = impl.applyConfig?.(ctx.def, ctx.$.resolvedConfig) ?? ctx.def;\n    const inner = {};\n    const { meta: metaSchema, ...innerSchema } = configuredSchema;\n    const meta = metaSchema === undefined ? {}\n        : typeof metaSchema === \"string\" ? { description: metaSchema }\n            : metaSchema;\n    // ensure node entries are parsed in order of precedence, with non-children\n    // parsed first\n    const innerSchemaEntries = entriesOf(innerSchema)\n        .sort(([lKey], [rKey]) => isNodeKind(lKey) ?\n        isNodeKind(rKey) ? precedenceOfKind(lKey) - precedenceOfKind(rKey)\n            : 1\n        : isNodeKind(rKey) ? -1\n            : lKey < rKey ? -1\n                : 1)\n        .filter(([k, v]) => {\n        // move meta. prefixed props to meta, overwriting existing nested\n        // props of the same name if they exist\n        if (k.startsWith(\"meta.\")) {\n            const metaKey = k.slice(5);\n            meta[metaKey] = v;\n            return false;\n        }\n        return true;\n    });\n    for (const entry of innerSchemaEntries) {\n        const k = entry[0];\n        const keyImpl = impl.keys[k];\n        if (!keyImpl)\n            return throwParseError(`Key ${k} is not valid on ${ctx.kind} schema`);\n        const v = keyImpl.parse ? keyImpl.parse(entry[1], ctx) : entry[1];\n        if (v !== unset && (v !== undefined || keyImpl.preserveUndefined))\n            inner[k] = v;\n    }\n    if (impl.reduce && !ctx.prereduced) {\n        const reduced = impl.reduce(inner, ctx.$);\n        if (reduced) {\n            if (reduced instanceof Disjoint)\n                return reduced.throw();\n            // we can't cache this reduction for now in case the reduction involved\n            // impliedSiblings\n            return withMeta(reduced, meta);\n        }\n    }\n    const node = createNode({\n        id: ctx.id,\n        kind: ctx.kind,\n        inner,\n        meta,\n        $: ctx.$\n    });\n    return node;\n};\nexport const createNode = ({ id, kind, inner, meta, $, ignoreCache }) => {\n    const impl = nodeImplementationsByKind[kind];\n    const innerEntries = entriesOf(inner);\n    const children = [];\n    let innerJson = {};\n    for (const [k, v] of innerEntries) {\n        const keyImpl = impl.keys[k];\n        const serialize = keyImpl.serialize ??\n            (keyImpl.child ? serializeListableChild : defaultValueSerializer);\n        innerJson[k] = serialize(v);\n        if (keyImpl.child === true) {\n            const listableNode = v;\n            if (isArray(listableNode))\n                children.push(...listableNode);\n            else\n                children.push(listableNode);\n        }\n        else if (typeof keyImpl.child === \"function\")\n            children.push(...keyImpl.child(v));\n    }\n    if (impl.finalizeInnerJson)\n        innerJson = impl.finalizeInnerJson(innerJson);\n    let json = { ...innerJson };\n    let metaJson = {};\n    if (!isEmptyObject(meta)) {\n        metaJson = flatMorph(meta, (k, v) => [\n            k,\n            k === \"examples\" ? v : defaultValueSerializer(v)\n        ]);\n        json.meta = possiblyCollapse(metaJson, \"description\", true);\n    }\n    innerJson = possiblyCollapse(innerJson, impl.collapsibleKey, false);\n    const innerHash = JSON.stringify({ kind, ...innerJson });\n    json = possiblyCollapse(json, impl.collapsibleKey, false);\n    const collapsibleJson = possiblyCollapse(json, impl.collapsibleKey, true);\n    const hash = JSON.stringify({ kind, ...json });\n    // we have to wait until after reduction to return a cached entry,\n    // since reduction can add impliedSiblings\n    if ($.nodesByHash[hash] && !ignoreCache)\n        return $.nodesByHash[hash];\n    const attachments = {\n        id,\n        kind,\n        impl,\n        inner,\n        innerEntries,\n        innerJson,\n        innerHash,\n        meta,\n        metaJson,\n        json,\n        hash,\n        collapsibleJson: collapsibleJson,\n        children\n    };\n    if (kind !== \"intersection\") {\n        for (const k in inner)\n            if (k !== \"in\" && k !== \"out\")\n                attachments[k] = inner[k];\n    }\n    const node = new nodeClassesByKind[kind](attachments, $);\n    return ($.nodesByHash[hash] = node);\n};\nexport const withId = (node, id) => {\n    if (node.id === id)\n        return node;\n    if (isNode(nodesByRegisteredId[id]))\n        throwInternalError(`Unexpected attempt to overwrite node id ${id}`);\n    // have to ignore cache to force creation of new potentially cyclic id\n    return createNode({\n        id,\n        kind: node.kind,\n        inner: node.inner,\n        meta: node.meta,\n        $: node.$,\n        ignoreCache: true\n    });\n};\nexport const withMeta = (node, meta, id) => {\n    if (id && isNode(nodesByRegisteredId[id]))\n        throwInternalError(`Unexpected attempt to overwrite node id ${id}`);\n    return createNode({\n        id: id ?? registerNodeId(meta.alias ?? node.kind),\n        kind: node.kind,\n        inner: node.inner,\n        meta,\n        $: node.$\n    });\n};\nconst possiblyCollapse = (json, toKey, allowPrimitive) => {\n    const collapsibleKeys = Object.keys(json);\n    if (collapsibleKeys.length === 1 && collapsibleKeys[0] === toKey) {\n        const collapsed = json[toKey];\n        if (allowPrimitive)\n            return collapsed;\n        if (\n        // if the collapsed value is still an object\n        hasDomain(collapsed, \"object\") &&\n            // and the JSON did not include any implied keys\n            (Object.keys(collapsed).length === 1 || Array.isArray(collapsed))) {\n            // we can replace it with its collapsed value\n            return collapsed;\n        }\n    }\n    return json;\n};\n", "import { append, printable, throwParseError, unset } from \"@ark/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { flatRef } from \"../node.js\";\nimport { compileSerializedValue } from \"../shared/compile.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { intersectOrPipeNodes } from \"../shared/intersections.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { traverseKey } from \"../shared/traversal.js\";\nexport const intersectProps = (l, r, ctx) => {\n    if (l.key !== r.key)\n        return null;\n    const key = l.key;\n    let value = intersectOrPipeNodes(l.value, r.value, ctx);\n    const kind = l.required || r.required ? \"required\" : \"optional\";\n    if (value instanceof Disjoint) {\n        if (kind === \"optional\")\n            value = $ark.intrinsic.never.internal;\n        else {\n            // if either operand was optional, the Disjoint has to be treated as optional\n            return value.withPrefixKey(l.key, l.required && r.required ? \"required\" : \"optional\");\n        }\n    }\n    if (kind === \"required\") {\n        return ctx.$.node(\"required\", {\n            key,\n            value\n        });\n    }\n    const defaultIntersection = l.hasDefault() ?\n        r.hasDefault() ?\n            l.default === r.default ?\n                l.default\n                : throwParseError(writeDefaultIntersectionMessage(l.default, r.default))\n            : l.default\n        : r.hasDefault() ? r.default\n            : unset;\n    return ctx.$.node(\"optional\", {\n        key,\n        value,\n        // unset is stripped during parsing\n        default: defaultIntersection\n    });\n};\nexport class BaseProp extends BaseConstraint {\n    required = this.kind === \"required\";\n    optional = this.kind === \"optional\";\n    impliedBasis = $ark.intrinsic.object.internal;\n    serializedKey = compileSerializedValue(this.key);\n    compiledKey = typeof this.key === \"string\" ? this.key : this.serializedKey;\n    flatRefs = append(this.value.flatRefs.map(ref => flatRef([this.key, ...ref.path], ref.node)), flatRef([this.key], this.value));\n    _transform(mapper, ctx) {\n        ctx.path.push(this.key);\n        const result = super._transform(mapper, ctx);\n        ctx.path.pop();\n        return result;\n    }\n    hasDefault() {\n        return \"default\" in this.inner;\n    }\n    traverseAllows = (data, ctx) => {\n        if (this.key in data) {\n            // ctx will be undefined if this node isn't context-dependent\n            return traverseKey(this.key, () => this.value.traverseAllows(data[this.key], ctx), ctx);\n        }\n        return this.optional;\n    };\n    traverseApply = (data, ctx) => {\n        if (this.key in data) {\n            traverseKey(this.key, () => this.value.traverseApply(data[this.key], ctx), ctx);\n        }\n        else if (this.hasKind(\"required\"))\n            ctx.errorFromNodeContext(this.errorContext);\n    };\n    compile(js) {\n        js.if(`${this.serializedKey} in data`, () => js.traverseKey(this.serializedKey, `data${js.prop(this.key)}`, this.value));\n        if (this.hasKind(\"required\")) {\n            js.else(() => js.traversalKind === \"Apply\" ?\n                js.line(`ctx.errorFromNodeContext(${this.compiledErrorContext})`)\n                : js.return(false));\n        }\n        if (js.traversalKind === \"Allows\")\n            js.return(true);\n    }\n}\nexport const writeDefaultIntersectionMessage = (lValue, rValue) => `Invalid intersection of default values ${printable(lValue)} & ${printable(rValue)}`;\n", "import { hasDomain, isThunk, printable, throwParseError } from \"@ark/util\";\nimport { intrinsic } from \"../intrinsic.js\";\nimport { compileSerializedValue } from \"../shared/compile.js\";\nimport { ArkErrors } from \"../shared/errors.js\";\nimport { defaultValueSerializer, implementNode } from \"../shared/implement.js\";\nimport { registeredReference } from \"../shared/registry.js\";\nimport { traverseKey } from \"../shared/traversal.js\";\nimport { BaseProp, intersectProps } from \"./prop.js\";\nconst implementation = implementNode({\n    kind: \"optional\",\n    hasAssociatedError: false,\n    intersectionIsOpen: true,\n    keys: {\n        key: {},\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.parseSchema(schema)\n        },\n        default: {\n            preserveUndefined: true\n        }\n    },\n    normalize: schema => schema,\n    reduce: (inner, $) => {\n        if ($.resolvedConfig.exactOptionalPropertyTypes === false) {\n            if (!inner.value.allows(undefined)) {\n                return $.node(\"optional\", { ...inner, value: inner.value.or(intrinsic.undefined) }, { prereduced: true });\n            }\n        }\n    },\n    defaults: {\n        description: node => `${node.compiledKey}?: ${node.value.description}`\n    },\n    intersections: {\n        optional: intersectProps\n    }\n});\nexport class OptionalNode extends BaseProp {\n    constructor(...args) {\n        super(...args);\n        if (\"default\" in this.inner)\n            assertDefaultValueAssignability(this.value, this.inner.default, this.key);\n    }\n    get outProp() {\n        if (!this.hasDefault())\n            return this;\n        const { default: defaultValue, ...requiredInner } = this.inner;\n        return this.cacheGetter(\"outProp\", this.$.node(\"required\", requiredInner, { prereduced: true }));\n    }\n    expression = this.hasDefault() ?\n        `${this.compiledKey}: ${this.value.expression} = ${printable(this.inner.default)}`\n        : `${this.compiledKey}?: ${this.value.expression}`;\n    defaultValueMorph = getDefaultableMorph(this);\n    defaultValueMorphRef = this.defaultValueMorph && registeredReference(this.defaultValueMorph);\n}\nexport const Optional = {\n    implementation,\n    Node: OptionalNode\n};\nconst defaultableMorphCache = {};\nconst getDefaultableMorph = (node) => {\n    if (!node.hasDefault())\n        return;\n    const cacheKey = `{${node.compiledKey}: ${node.value.id} = ${defaultValueSerializer(node.default)}}`;\n    return (defaultableMorphCache[cacheKey] ??= computeDefaultValueMorph(node.key, node.value, node.default));\n};\nexport const computeDefaultValueMorph = (key, value, defaultInput) => {\n    if (typeof defaultInput === \"function\") {\n        // if the value has a morph, pipe context through it\n        return value.includesTransform ?\n            (data, ctx) => {\n                traverseKey(key, () => value((data[key] = defaultInput()), ctx), ctx);\n                return data;\n            }\n            : data => {\n                data[key] = defaultInput();\n                return data;\n            };\n    }\n    // non-functional defaults can be safely cached as long as the morph is\n    // guaranteed to be pure and the output is primitive\n    const precomputedMorphedDefault = value.includesTransform ? value.assert(defaultInput) : defaultInput;\n    return hasDomain(precomputedMorphedDefault, \"object\") ?\n        // the type signature only allows this if the value was morphed\n        (data, ctx) => {\n            traverseKey(key, () => value((data[key] = defaultInput), ctx), ctx);\n            return data;\n        }\n        : data => {\n            data[key] = precomputedMorphedDefault;\n            return data;\n        };\n};\nexport const assertDefaultValueAssignability = (node, value, key) => {\n    const wrapped = isThunk(value);\n    if (hasDomain(value, \"object\") && !wrapped)\n        throwParseError(writeNonPrimitiveNonFunctionDefaultValueMessage(key));\n    const out = node.in(wrapped ? value() : value);\n    if (out instanceof ArkErrors) {\n        if (key === null) {\n            // e.g. \"Default must be assignable to number (was string)\"\n            throwParseError(`Default ${out.summary}`);\n        }\n        const atPath = out.transform(e => e.transform(input => ({ ...input, prefixPath: [key] })));\n        // e.g. \"Default for bar must be assignable to number (was string)\"\n        // e.g. \"Default for value at [0] must be assignable to number (was string)\"\n        throwParseError(`Default for ${atPath.summary}`);\n    }\n    return value;\n};\nexport const writeNonPrimitiveNonFunctionDefaultValueMessage = (key) => {\n    const keyDescription = key === null ? \"\"\n        : typeof key === \"number\" ? `for value at [${key}] `\n            : `for ${compileSerializedValue(key)} `;\n    return `Non-primitive default ${keyDescription}must be specified as a function like () => ({my: 'object'})`;\n};\n", "import { arrayEquals, flatMorph, includes, inferred, omit, throwInternalError, throwParseError } from \"@ark/util\";\nimport { mergeToJsonSchemaConfigs } from \"../config.js\";\nimport { throwInvalidOperandError } from \"../constraint.js\";\nimport { BaseNode } from \"../node.js\";\nimport { Disjoint, writeUnsatisfiableExpressionError } from \"../shared/disjoint.js\";\nimport { ArkErrors } from \"../shared/errors.js\";\nimport { structuralKinds } from \"../shared/implement.js\";\nimport { intersectNodesRoot, pipeNodesRoot } from \"../shared/intersections.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { arkKind, hasArkKind } from \"../shared/utils.js\";\nimport { assertDefaultValueAssignability } from \"../structure/optional.js\";\nexport class BaseRoot extends BaseNode {\n    constructor(attachments, $) {\n        super(attachments, $);\n        // define as a getter to avoid it being enumerable/spreadable\n        Object.defineProperty(this, arkKind, { value: \"root\", enumerable: false });\n    }\n    get internal() {\n        return this;\n    }\n    get \"~standard\"() {\n        return {\n            vendor: \"arktype\",\n            version: 1,\n            validate: input => {\n                const out = this(input);\n                if (out instanceof ArkErrors)\n                    return out;\n                return { value: out };\n            }\n        };\n    }\n    as() {\n        return this;\n    }\n    brand(name) {\n        if (name === \"\")\n            return throwParseError(emptyBrandNameMessage);\n        return this;\n    }\n    readonly() {\n        return this;\n    }\n    branches = this.hasKind(\"union\") ? this.inner.branches : [this];\n    distribute(mapBranch, reduceMapped) {\n        const mappedBranches = this.branches.map(mapBranch);\n        return reduceMapped?.(mappedBranches) ?? mappedBranches;\n    }\n    get shortDescription() {\n        return this.meta.description ?? this.defaultShortDescription;\n    }\n    toJsonSchema(opts = {}) {\n        const ctx = mergeToJsonSchemaConfigs(this.$.resolvedConfig.toJsonSchema, opts);\n        ctx.useRefs ||= this.isCyclic;\n        // ensure $schema is the first key if present\n        const schema = typeof ctx.dialect === \"string\" ? { $schema: ctx.dialect } : {};\n        Object.assign(schema, this.toJsonSchemaRecurse(ctx));\n        if (ctx.useRefs) {\n            schema.$defs = flatMorph(this.references, (i, ref) => ref.isRoot() && !ref.alwaysExpandJsonSchema ?\n                [ref.id, ref.toResolvedJsonSchema(ctx)]\n                : []);\n        }\n        return schema;\n    }\n    toJsonSchemaRecurse(ctx) {\n        if (ctx.useRefs && !this.alwaysExpandJsonSchema)\n            return { $ref: `#/$defs/${this.id}` };\n        return this.toResolvedJsonSchema(ctx);\n    }\n    get alwaysExpandJsonSchema() {\n        return (this.isBasis() ||\n            this.kind === \"alias\" ||\n            (this.hasKind(\"union\") && this.isBoolean));\n    }\n    toResolvedJsonSchema(ctx) {\n        const result = this.innerToJsonSchema(ctx);\n        return Object.assign(result, this.metaJson);\n    }\n    intersect(r) {\n        const rNode = this.$.parseDefinition(r);\n        const result = this.rawIntersect(rNode);\n        if (result instanceof Disjoint)\n            return result;\n        return this.$.finalize(result);\n    }\n    rawIntersect(r) {\n        return intersectNodesRoot(this, r, this.$);\n    }\n    toNeverIfDisjoint() {\n        return this;\n    }\n    and(r) {\n        const result = this.intersect(r);\n        return result instanceof Disjoint ? result.throw() : result;\n    }\n    rawAnd(r) {\n        const result = this.rawIntersect(r);\n        return result instanceof Disjoint ? result.throw() : result;\n    }\n    or(r) {\n        const rNode = this.$.parseDefinition(r);\n        return this.$.finalize(this.rawOr(rNode));\n    }\n    rawOr(r) {\n        const branches = [...this.branches, ...r.branches];\n        return this.$.node(\"union\", branches);\n    }\n    map(flatMapEntry) {\n        return this.$.schema(this.applyStructuralOperation(\"map\", [flatMapEntry]));\n    }\n    pick(...keys) {\n        return this.$.schema(this.applyStructuralOperation(\"pick\", keys));\n    }\n    omit(...keys) {\n        return this.$.schema(this.applyStructuralOperation(\"omit\", keys));\n    }\n    required() {\n        return this.$.schema(this.applyStructuralOperation(\"required\", []));\n    }\n    partial() {\n        return this.$.schema(this.applyStructuralOperation(\"partial\", []));\n    }\n    _keyof;\n    keyof() {\n        if (this._keyof)\n            return this._keyof;\n        const result = this.applyStructuralOperation(\"keyof\", []).reduce((result, branch) => result.intersect(branch).toNeverIfDisjoint(), $ark.intrinsic.unknown.internal);\n        if (result.branches.length === 0) {\n            throwParseError(writeUnsatisfiableExpressionError(`keyof ${this.expression}`));\n        }\n        return (this._keyof = this.$.finalize(result));\n    }\n    get props() {\n        if (this.branches.length !== 1)\n            return throwParseError(writeLiteralUnionEntriesMessage(this.expression));\n        return [...this.applyStructuralOperation(\"props\", [])[0]];\n    }\n    merge(r) {\n        const rNode = this.$.parseDefinition(r);\n        return this.$.schema(rNode.distribute(branch => this.applyStructuralOperation(\"merge\", [\n            structureOf(branch) ??\n                throwParseError(writeNonStructuralOperandMessage(\"merge\", branch.expression))\n        ])));\n    }\n    applyStructuralOperation(operation, args) {\n        return this.distribute(branch => {\n            if (branch.equals($ark.intrinsic.object) && operation !== \"merge\")\n                // ideally this wouldn't be a special case, but for now it\n                // allows us to bypass `assertHasKeys` checks on base\n                // instantiations of generics like Pick and Omit. Could\n                // potentially be removed once constraints can reference each other:\n                // https://github.com/arktypeio/arktype/issues/1053\n                return branch;\n            const structure = structureOf(branch);\n            if (!structure) {\n                throwParseError(writeNonStructuralOperandMessage(operation, branch.expression));\n            }\n            if (operation === \"keyof\")\n                return structure.keyof();\n            if (operation === \"get\")\n                return structure.get(...args);\n            if (operation === \"props\")\n                return structure.props;\n            const structuralMethodName = operation === \"required\" ? \"require\"\n                : operation === \"partial\" ? \"optionalize\"\n                    : operation;\n            return this.$.node(\"intersection\", {\n                ...branch.inner,\n                structure: structure[structuralMethodName](...args)\n            });\n        });\n    }\n    get(...path) {\n        if (path[0] === undefined)\n            return this;\n        return this.$.schema(this.applyStructuralOperation(\"get\", path));\n    }\n    extract(r) {\n        const rNode = this.$.parseDefinition(r);\n        return this.$.schema(this.branches.filter(branch => branch.extends(rNode)));\n    }\n    exclude(r) {\n        const rNode = this.$.parseDefinition(r);\n        return this.$.schema(this.branches.filter(branch => !branch.extends(rNode)));\n    }\n    array() {\n        return this.$.schema(this.isUnknown() ?\n            { proto: Array }\n            : {\n                proto: Array,\n                sequence: this\n            }, { prereduced: true });\n    }\n    overlaps(r) {\n        const intersection = this.intersect(r);\n        return !(intersection instanceof Disjoint);\n    }\n    extends(r) {\n        const intersection = this.intersect(r);\n        return (!(intersection instanceof Disjoint) && this.equals(intersection));\n    }\n    ifExtends(r) {\n        return this.extends(r) ? this : undefined;\n    }\n    subsumes(r) {\n        const rNode = this.$.parseDefinition(r);\n        return rNode.extends(this);\n    }\n    configure(meta, selector = \"shallow\") {\n        return this.configureReferences(meta, selector);\n    }\n    describe(description, selector = \"shallow\") {\n        return this.configure({ description }, selector);\n    }\n    // these should ideally be implemented in arktype since they use its syntax\n    // https://github.com/arktypeio/arktype/issues/1223\n    optional() {\n        return [this, \"?\"];\n    }\n    // these should ideally be implemented in arktype since they use its syntax\n    // https://github.com/arktypeio/arktype/issues/1223\n    default(thunkableValue) {\n        assertDefaultValueAssignability(this, thunkableValue, null);\n        return [this, \"=\", thunkableValue];\n    }\n    from(input) {\n        // ideally we might not validate here but for now we need to do determine\n        // which morphs to apply\n        return this.assert(input);\n    }\n    _pipe(...morphs) {\n        const result = morphs.reduce((acc, morph) => acc.rawPipeOnce(morph), this);\n        return this.$.finalize(result);\n    }\n    tryPipe(...morphs) {\n        const result = morphs.reduce((acc, morph) => acc.rawPipeOnce(hasArkKind(morph, \"root\") ? morph : ((In, ctx) => {\n            try {\n                return morph(In, ctx);\n            }\n            catch (e) {\n                return ctx.error({\n                    code: \"predicate\",\n                    predicate: morph,\n                    actual: `aborted due to error:\\n    ${e}\\n`\n                });\n            }\n        })), this);\n        return this.$.finalize(result);\n    }\n    pipe = Object.assign(this._pipe.bind(this), {\n        try: this.tryPipe.bind(this)\n    });\n    to(def) {\n        return this.$.finalize(this.toNode(this.$.parseDefinition(def)));\n    }\n    toNode(root) {\n        const result = pipeNodesRoot(this, root, this.$);\n        if (result instanceof Disjoint)\n            return result.throw();\n        return result;\n    }\n    rawPipeOnce(morph) {\n        if (hasArkKind(morph, \"root\"))\n            return this.toNode(morph);\n        return this.distribute(branch => branch.hasKind(\"morph\") ?\n            this.$.node(\"morph\", {\n                in: branch.inner.in,\n                morphs: [...branch.morphs, morph]\n            })\n            : this.$.node(\"morph\", {\n                in: branch,\n                morphs: [morph]\n            }), this.$.parseSchema);\n    }\n    narrow(predicate) {\n        return this.constrainOut(\"predicate\", predicate);\n    }\n    constrain(kind, schema) {\n        return this._constrain(\"root\", kind, schema);\n    }\n    constrainIn(kind, schema) {\n        return this._constrain(\"in\", kind, schema);\n    }\n    constrainOut(kind, schema) {\n        return this._constrain(\"out\", kind, schema);\n    }\n    _constrain(io, kind, schema) {\n        const constraint = this.$.node(kind, schema);\n        if (constraint.isRoot()) {\n            // if the node reduces to `unknown`, nothing to do (e.g. minLength: 0)\n            return constraint.isUnknown() ? this : (throwInternalError(`Unexpected constraint node ${constraint}`));\n        }\n        const operand = io === \"root\" ? this : this[io];\n        if (operand.hasKind(\"morph\") ||\n            (constraint.impliedBasis && !operand.extends(constraint.impliedBasis))) {\n            return throwInvalidOperandError(kind, constraint.impliedBasis, this);\n        }\n        const partialIntersection = this.$.node(\"intersection\", {\n            // important this is constraint.kind instead of kind in case\n            // the node was reduced during parsing\n            [constraint.kind]: constraint\n        });\n        const result = io === \"out\" ?\n            pipeNodesRoot(this, partialIntersection, this.$)\n            : intersectNodesRoot(this, partialIntersection, this.$);\n        if (result instanceof Disjoint)\n            result.throw();\n        return this.$.finalize(result);\n    }\n    onUndeclaredKey(cfg) {\n        const rule = typeof cfg === \"string\" ? cfg : cfg.rule;\n        const deep = typeof cfg === \"string\" ? false : cfg.deep;\n        return this.$.finalize(this.transform((kind, inner) => kind === \"structure\" ?\n            rule === \"ignore\" ?\n                omit(inner, { undeclared: 1 })\n                : { ...inner, undeclared: rule }\n            : inner, deep ? undefined : ({ shouldTransform: node => !includes(structuralKinds, node.kind) })));\n    }\n    hasEqualMorphs(r) {\n        if (!this.includesTransform && !r.includesTransform)\n            return true;\n        if (!arrayEquals(this.shallowMorphs, r.shallowMorphs))\n            return false;\n        if (!arrayEquals(this.flatMorphs, r.flatMorphs, {\n            isEqual: (l, r) => l.propString === r.propString &&\n                (l.node.hasKind(\"morph\") && r.node.hasKind(\"morph\") ?\n                    l.node.hasEqualMorphs(r.node)\n                    : l.node.hasKind(\"intersection\") && r.node.hasKind(\"intersection\") ?\n                        l.node.structure?.structuralMorphRef ===\n                            r.node.structure?.structuralMorphRef\n                        : false)\n        }))\n            return false;\n        return true;\n    }\n    onDeepUndeclaredKey(behavior) {\n        return this.onUndeclaredKey({ rule: behavior, deep: true });\n    }\n    filter(predicate) {\n        return this.constrainIn(\"predicate\", predicate);\n    }\n    divisibleBy(schema) {\n        return this.constrain(\"divisor\", schema);\n    }\n    matching(schema) {\n        return this.constrain(\"pattern\", schema);\n    }\n    atLeast(schema) {\n        return this.constrain(\"min\", schema);\n    }\n    atMost(schema) {\n        return this.constrain(\"max\", schema);\n    }\n    moreThan(schema) {\n        return this.constrain(\"min\", exclusivizeRangeSchema(schema));\n    }\n    lessThan(schema) {\n        return this.constrain(\"max\", exclusivizeRangeSchema(schema));\n    }\n    atLeastLength(schema) {\n        return this.constrain(\"minLength\", schema);\n    }\n    atMostLength(schema) {\n        return this.constrain(\"maxLength\", schema);\n    }\n    moreThanLength(schema) {\n        return this.constrain(\"minLength\", exclusivizeRangeSchema(schema));\n    }\n    lessThanLength(schema) {\n        return this.constrain(\"maxLength\", exclusivizeRangeSchema(schema));\n    }\n    exactlyLength(schema) {\n        return this.constrain(\"exactLength\", schema);\n    }\n    atOrAfter(schema) {\n        return this.constrain(\"after\", schema);\n    }\n    atOrBefore(schema) {\n        return this.constrain(\"before\", schema);\n    }\n    laterThan(schema) {\n        return this.constrain(\"after\", exclusivizeRangeSchema(schema));\n    }\n    earlierThan(schema) {\n        return this.constrain(\"before\", exclusivizeRangeSchema(schema));\n    }\n}\nexport const emptyBrandNameMessage = `Expected a non-empty brand name after #`;\nexport const exclusivizeRangeSchema = (schema) => (typeof schema === \"object\" && !(schema instanceof Date) ?\n    { ...schema, exclusive: true }\n    : {\n        rule: schema,\n        exclusive: true\n    });\nexport const typeOrTermExtends = (t, base) => hasArkKind(base, \"root\") ?\n    hasArkKind(t, \"root\") ? t.extends(base)\n        : base.allows(t)\n    : hasArkKind(t, \"root\") ? t.hasUnit(base)\n        : base === t;\nconst structureOf = (branch) => {\n    if (branch.hasKind(\"morph\"))\n        return null;\n    if (branch.hasKind(\"intersection\")) {\n        return (branch.inner.structure ??\n            (branch.basis?.domain === \"object\" ?\n                branch.$.bindReference($ark.intrinsic.emptyStructure)\n                : null));\n    }\n    if (branch.isBasis() && branch.domain === \"object\")\n        return branch.$.bindReference($ark.intrinsic.emptyStructure);\n    return null;\n};\nexport const writeLiteralUnionEntriesMessage = (expression) => `Props cannot be extracted from a union. Use .distribute to extract props from each branch instead. Received:\n${expression}`;\nexport const writeNonStructuralOperandMessage = (operation, operand) => `${operation} operand must be an object (was ${operand})`;\n", "import { flatMorph } from \"@ark/util\";\nimport { schemaKindsRightOf } from \"../shared/implement.js\";\nexport const defineRightwardIntersections = (kind, implementation) => flatMorph(schemaKindsRightOf(kind), (i, kind) => [\n    kind,\n    implementation\n]);\n", "import { append, domainDescriptions, printable, throwInternalError, throwParseError } from \"@ark/util\";\nimport { nodesByRegisteredId } from \"../parse.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectOrPipeNodes } from \"../shared/intersections.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { hasArkKind } from \"../shared/utils.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nexport const normalizeAliasSchema = (schema) => typeof schema === \"string\" ? { reference: schema } : schema;\nconst neverIfDisjoint = (result) => result instanceof Disjoint ? $ark.intrinsic.never.internal : result;\nconst implementation = implementNode({\n    kind: \"alias\",\n    hasAssociatedError: false,\n    collapsibleKey: \"reference\",\n    keys: {\n        reference: {\n            serialize: s => (s.startsWith(\"$\") ? s : `$ark.${s}`)\n        },\n        resolve: {}\n    },\n    normalize: normalizeAliasSchema,\n    defaults: {\n        description: node => node.reference\n    },\n    intersections: {\n        alias: (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint(intersectOrPipeNodes(l.resolution, r.resolution, ctx)), `${l.reference}${ctx.pipe ? \"=>\" : \"&\"}${r.reference}`),\n        ...defineRightwardIntersections(\"alias\", (l, r, ctx) => {\n            if (r.isUnknown())\n                return l;\n            if (r.isNever())\n                return r;\n            if (r.isBasis() && !r.overlaps($ark.intrinsic.object)) {\n                // can be more robust as part of https://github.com/arktypeio/arktype/issues/1026\n                return Disjoint.init(\"assignability\", $ark.intrinsic.object, r);\n            }\n            return ctx.$.lazilyResolve(() => neverIfDisjoint(intersectOrPipeNodes(l.resolution, r, ctx)), `${l.reference}${ctx.pipe ? \"=>\" : \"&\"}${r.id}`);\n        })\n    }\n});\nexport class AliasNode extends BaseRoot {\n    expression = this.reference;\n    structure = undefined;\n    get resolution() {\n        const result = this._resolve();\n        return (nodesByRegisteredId[this.id] = result);\n    }\n    _resolve() {\n        if (this.resolve)\n            return this.resolve();\n        if (this.reference[0] === \"$\")\n            return this.$.resolveRoot(this.reference.slice(1));\n        const id = this.reference;\n        let resolution = nodesByRegisteredId[id];\n        const seen = [];\n        while (hasArkKind(resolution, \"context\")) {\n            if (seen.includes(resolution.id)) {\n                return throwParseError(writeShallowCycleErrorMessage(resolution.id, seen));\n            }\n            seen.push(resolution.id);\n            resolution = nodesByRegisteredId[resolution.id];\n        }\n        if (!hasArkKind(resolution, \"root\")) {\n            return throwInternalError(`Unexpected resolution for reference ${this.reference}\nSeen: [${seen.join(\"->\")}] \nResolution: ${printable(resolution)}`);\n        }\n        return resolution;\n    }\n    get resolutionId() {\n        if (this.reference.includes(\"&\") || this.reference.includes(\"=>\"))\n            return this.resolution.id;\n        if (this.reference[0] !== \"$\")\n            return this.reference;\n        const alias = this.reference.slice(1);\n        const resolution = this.$.resolutions[alias];\n        if (typeof resolution === \"string\")\n            return resolution;\n        if (hasArkKind(resolution, \"root\"))\n            return resolution.id;\n        return throwInternalError(`Unexpected resolution for reference ${this.reference}: ${printable(resolution)}`);\n    }\n    get defaultShortDescription() {\n        return domainDescriptions.object;\n    }\n    innerToJsonSchema(ctx) {\n        return this.resolution.toJsonSchemaRecurse(ctx);\n    }\n    traverseAllows = (data, ctx) => {\n        const seen = ctx.seen[this.reference];\n        if (seen?.includes(data))\n            return true;\n        ctx.seen[this.reference] = append(seen, data);\n        return this.resolution.traverseAllows(data, ctx);\n    };\n    traverseApply = (data, ctx) => {\n        const seen = ctx.seen[this.reference];\n        if (seen?.includes(data))\n            return;\n        ctx.seen[this.reference] = append(seen, data);\n        this.resolution.traverseApply(data, ctx);\n    };\n    compile(js) {\n        const id = this.resolutionId;\n        js.if(`ctx.seen.${id} && ctx.seen.${id}.includes(data)`, () => js.return(true));\n        js.if(`!ctx.seen.${id}`, () => js.line(`ctx.seen.${id} = []`));\n        js.line(`ctx.seen.${id}.push(data)`);\n        js.return(js.invoke(id));\n    }\n}\nexport const writeShallowCycleErrorMessage = (name, seen) => `Alias '${name}' has a shallow resolution cycle: ${[...seen, name].join(\"->\")}`;\nexport const Alias = {\n    implementation,\n    Node: AliasNode\n};\n", "import { compileObjectLiteral } from \"../shared/implement.js\";\nimport { BaseRoot } from \"./root.js\";\nexport class InternalBasis extends BaseRoot {\n    traverseApply = (data, ctx) => {\n        if (!this.traverseAllows(data, ctx))\n            ctx.errorFromNodeContext(this.errorContext);\n    };\n    get errorContext() {\n        return {\n            code: this.kind,\n            description: this.description,\n            meta: this.meta,\n            ...this.inner\n        };\n    }\n    get compiledErrorContext() {\n        return compileObjectLiteral(this.errorContext);\n    }\n    compile(js) {\n        if (js.traversalKind === \"Allows\")\n            js.return(this.compiledCondition);\n        else {\n            js.if(this.compiledNegation, () => js.line(`${js.ctx}.errorFromNodeContext(${this.compiledErrorContext})`));\n        }\n    }\n}\n", "import { domainDescriptions, domainOf, hasKey, throwParseError } from \"@ark/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { InternalBasis } from \"./basis.js\";\nconst implementation = implementNode({\n    kind: \"domain\",\n    hasAssociatedError: true,\n    collapsibleKey: \"domain\",\n    keys: {\n        domain: {},\n        numberAllowsNaN: {}\n    },\n    normalize: schema => typeof schema === \"string\" ? { domain: schema }\n        : hasKey(schema, \"numberAllowsNaN\") && schema.domain !== \"number\" ?\n            throwParseError(Domain.writeBadAllowNanMessage(schema.domain))\n            : schema,\n    applyConfig: (schema, config) => (schema.numberAllowsNaN === undefined &&\n        schema.domain === \"number\" &&\n        config.numberAllowsNaN) ?\n        { ...schema, numberAllowsNaN: true }\n        : schema,\n    defaults: {\n        description: node => domainDescriptions[node.domain],\n        actual: data => Number.isNaN(data) ? \"NaN\" : domainDescriptions[domainOf(data)]\n    },\n    intersections: {\n        domain: (l, r) => \n        // since l === r is handled by default, remaining cases are disjoint\n        // outside those including options like numberAllowsNaN\n        l.domain === \"number\" && r.domain === \"number\" ?\n            l.numberAllowsNaN ?\n                r\n                : l\n            : Disjoint.init(\"domain\", l, r)\n    }\n});\nexport class DomainNode extends InternalBasis {\n    requiresNaNCheck = this.domain === \"number\" && !this.numberAllowsNaN;\n    traverseAllows = this.requiresNaNCheck ?\n        data => typeof data === \"number\" && !Number.isNaN(data)\n        : data => domainOf(data) === this.domain;\n    compiledCondition = this.domain === \"object\" ?\n        `((typeof data === \"object\" && data !== null) || typeof data === \"function\")`\n        : `typeof data === \"${this.domain}\"${this.requiresNaNCheck ? \" && !Number.isNaN(data)\" : \"\"}`;\n    compiledNegation = this.domain === \"object\" ?\n        `((typeof data !== \"object\" || data === null) && typeof data !== \"function\")`\n        : `typeof data !== \"${this.domain}\"${this.requiresNaNCheck ? \" || Number.isNaN(data)\" : \"\"}`;\n    expression = this.numberAllowsNaN ? \"number | NaN\" : this.domain;\n    get nestableExpression() {\n        return this.numberAllowsNaN ? `(${this.expression})` : this.expression;\n    }\n    get defaultShortDescription() {\n        return domainDescriptions[this.domain];\n    }\n    innerToJsonSchema(ctx) {\n        if (this.domain === \"bigint\" || this.domain === \"symbol\") {\n            return ctx.fallback.domain({\n                code: \"domain\",\n                base: {},\n                domain: this.domain\n            });\n        }\n        return {\n            type: this.domain\n        };\n    }\n}\nexport const Domain = {\n    implementation,\n    Node: DomainNode,\n    writeBadAllowNanMessage: (actual) => `numberAllowsNaN may only be specified with domain \"number\" (was ${actual})`\n};\n", "import { flatMorph, hasDomain, isEmptyObject, isKeyOf, throwParseError } from \"@ark/util\";\nimport { constraintKeyParser, flattenConstraints, intersectConstraints } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode, structureKeys } from \"../shared/implement.js\";\nimport { intersectOrPipeNodes } from \"../shared/intersections.js\";\nimport { hasArkKind, isNode } from \"../shared/utils.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nconst implementation = implementNode({\n    kind: \"intersection\",\n    hasAssociatedError: true,\n    normalize: rawSchema => {\n        if (isNode(rawSchema))\n            return rawSchema;\n        const { structure, ...schema } = rawSchema;\n        const hasRootStructureKey = !!structure;\n        const normalizedStructure = structure ?? {};\n        const normalized = flatMorph(schema, (k, v) => {\n            if (isKeyOf(k, structureKeys)) {\n                if (hasRootStructureKey) {\n                    throwParseError(`Flattened structure key ${k} cannot be specified alongside a root 'structure' key.`);\n                }\n                normalizedStructure[k] = v;\n                return [];\n            }\n            return [k, v];\n        });\n        if (hasArkKind(normalizedStructure, \"constraint\") ||\n            !isEmptyObject(normalizedStructure))\n            normalized.structure = normalizedStructure;\n        return normalized;\n    },\n    finalizeInnerJson: ({ structure, ...rest }) => hasDomain(structure, \"object\") ? { ...structure, ...rest } : rest,\n    keys: {\n        domain: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"domain\", schema)\n        },\n        proto: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"proto\", schema)\n        },\n        structure: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"structure\", schema),\n            serialize: node => {\n                if (!node.sequence?.minLength)\n                    return node.collapsibleJson;\n                const { sequence, ...structureJson } = node.collapsibleJson;\n                const { minVariadicLength, ...sequenceJson } = sequence;\n                const collapsibleSequenceJson = sequenceJson.variadic && Object.keys(sequenceJson).length === 1 ?\n                    sequenceJson.variadic\n                    : sequenceJson;\n                return { ...structureJson, sequence: collapsibleSequenceJson };\n            }\n        },\n        divisor: {\n            child: true,\n            parse: constraintKeyParser(\"divisor\")\n        },\n        max: {\n            child: true,\n            parse: constraintKeyParser(\"max\")\n        },\n        min: {\n            child: true,\n            parse: constraintKeyParser(\"min\")\n        },\n        maxLength: {\n            child: true,\n            parse: constraintKeyParser(\"maxLength\")\n        },\n        minLength: {\n            child: true,\n            parse: constraintKeyParser(\"minLength\")\n        },\n        exactLength: {\n            child: true,\n            parse: constraintKeyParser(\"exactLength\")\n        },\n        before: {\n            child: true,\n            parse: constraintKeyParser(\"before\")\n        },\n        after: {\n            child: true,\n            parse: constraintKeyParser(\"after\")\n        },\n        pattern: {\n            child: true,\n            parse: constraintKeyParser(\"pattern\")\n        },\n        predicate: {\n            child: true,\n            parse: constraintKeyParser(\"predicate\")\n        }\n    },\n    // leverage reduction logic from intersection and identity to ensure initial\n    // parse result is reduced\n    reduce: (inner, $) => \n    // we cast union out of the result here since that only occurs when intersecting two sequences\n    // that cannot occur when reducing a single intersection schema using unknown\n    intersectIntersections({}, inner, {\n        $,\n        invert: false,\n        pipe: false\n    }),\n    defaults: {\n        description: node => {\n            if (node.children.length === 0)\n                return \"unknown\";\n            if (node.structure)\n                return node.structure.description;\n            const childDescriptions = [];\n            if (node.basis &&\n                !node.refinements.some(r => r.impl.obviatesBasisDescription))\n                childDescriptions.push(node.basis.description);\n            if (node.refinements.length) {\n                const sortedRefinementDescriptions = node.refinements\n                    // override alphabetization to describe min before max\n                    .toSorted((l, r) => (l.kind === \"min\" && r.kind === \"max\" ? -1 : 0))\n                    .map(r => r.description);\n                childDescriptions.push(...sortedRefinementDescriptions);\n            }\n            if (node.inner.predicate) {\n                childDescriptions.push(...node.inner.predicate.map(p => p.description));\n            }\n            return childDescriptions.join(\" and \");\n        },\n        expected: source => `  ◦ ${source.errors.map(e => e.expected).join(\"\\n  ◦ \")}`,\n        problem: ctx => `(${ctx.actual}) must be...\\n${ctx.expected}`\n    },\n    intersections: {\n        intersection: (l, r, ctx) => intersectIntersections(l.inner, r.inner, ctx),\n        ...defineRightwardIntersections(\"intersection\", (l, r, ctx) => {\n            // if l is unknown, return r\n            if (l.children.length === 0)\n                return r;\n            const { domain, proto, ...lInnerConstraints } = l.inner;\n            const lBasis = proto ?? domain;\n            const basis = lBasis ? intersectOrPipeNodes(lBasis, r, ctx) : r;\n            return (basis instanceof Disjoint ? basis\n                : l?.basis?.equals(basis) ?\n                    // if the basis doesn't change, return the original intesection\n                    l\n                    // given we've already precluded l being unknown, the result must\n                    // be an intersection with the new basis result integrated\n                    : l.$.node(\"intersection\", { ...lInnerConstraints, [basis.kind]: basis }, { prereduced: true }));\n        })\n    }\n});\nexport class IntersectionNode extends BaseRoot {\n    basis = this.inner.domain ?? this.inner.proto ?? null;\n    refinements = this.children.filter(node => node.isRefinement());\n    structure = this.inner.structure;\n    expression = writeIntersectionExpression(this);\n    get shallowMorphs() {\n        return this.inner.structure?.structuralMorph ?\n            [this.inner.structure.structuralMorph]\n            : [];\n    }\n    get defaultShortDescription() {\n        return this.basis?.defaultShortDescription ?? \"present\";\n    }\n    innerToJsonSchema(ctx) {\n        return this.children.reduce(\n        // cast is required since TS doesn't know children have compatible schema prerequisites\n        (schema, child) => child.isBasis() ?\n            child.toJsonSchemaRecurse(ctx)\n            : child.reduceJsonSchema(schema, ctx), {});\n    }\n    traverseAllows = (data, ctx) => this.children.every(child => child.traverseAllows(data, ctx));\n    traverseApply = (data, ctx) => {\n        const errorCount = ctx.currentErrorCount;\n        if (this.basis) {\n            this.basis.traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.refinements.length) {\n            for (let i = 0; i < this.refinements.length - 1; i++) {\n                this.refinements[i].traverseApply(data, ctx);\n                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                    return;\n            }\n            this.refinements.at(-1).traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.structure) {\n            this.structure.traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.inner.predicate) {\n            for (let i = 0; i < this.inner.predicate.length - 1; i++) {\n                this.inner.predicate[i].traverseApply(data, ctx);\n                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                    return;\n            }\n            this.inner.predicate.at(-1).traverseApply(data, ctx);\n        }\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            for (const child of this.children)\n                js.check(child);\n            js.return(true);\n            return;\n        }\n        js.initializeErrorCount();\n        if (this.basis) {\n            js.check(this.basis);\n            // we only have to return conditionally if this is not the last check\n            if (this.children.length > 1)\n                js.returnIfFail();\n        }\n        if (this.refinements.length) {\n            for (let i = 0; i < this.refinements.length - 1; i++) {\n                js.check(this.refinements[i]);\n                js.returnIfFailFast();\n            }\n            js.check(this.refinements.at(-1));\n            if (this.structure || this.inner.predicate)\n                js.returnIfFail();\n        }\n        if (this.structure) {\n            js.check(this.structure);\n            if (this.inner.predicate)\n                js.returnIfFail();\n        }\n        if (this.inner.predicate) {\n            for (let i = 0; i < this.inner.predicate.length - 1; i++) {\n                js.check(this.inner.predicate[i]);\n                // since predicates can be chained, we have to fail immediately\n                // if one fails\n                js.returnIfFail();\n            }\n            js.check(this.inner.predicate.at(-1));\n        }\n    }\n}\nexport const Intersection = {\n    implementation,\n    Node: IntersectionNode\n};\nconst writeIntersectionExpression = (node) => {\n    let expression = node.structure?.expression ||\n        `${node.basis && !node.refinements.some(n => n.impl.obviatesBasisExpression) ? node.basis.nestableExpression + \" \" : \"\"}${node.refinements.map(n => n.expression).join(\" & \")}` ||\n        \"unknown\";\n    if (expression === \"Array == 0\")\n        expression = \"[]\";\n    return expression;\n};\nconst intersectIntersections = (l, r, ctx) => {\n    const baseInner = {};\n    const lBasis = l.proto ?? l.domain;\n    const rBasis = r.proto ?? r.domain;\n    const basisResult = lBasis ?\n        rBasis ?\n            intersectOrPipeNodes(lBasis, rBasis, ctx)\n            : lBasis\n        : rBasis;\n    if (basisResult instanceof Disjoint)\n        return basisResult;\n    if (basisResult)\n        baseInner[basisResult.kind] = basisResult;\n    return intersectConstraints({\n        kind: \"intersection\",\n        baseInner,\n        l: flattenConstraints(l),\n        r: flattenConstraints(r),\n        roots: [],\n        ctx\n    });\n};\n", "import { arrayEquals, liftArray, throwParseError } from \"@ark/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectOrPipeNodes } from \"../shared/intersections.js\";\nimport { $ark, registeredReference } from \"../shared/registry.js\";\nimport { hasArkKind } from \"../shared/utils.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nconst implementation = implementNode({\n    kind: \"morph\",\n    hasAssociatedError: false,\n    keys: {\n        in: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.parseSchema(schema)\n        },\n        morphs: {\n            parse: liftArray,\n            serialize: morphs => morphs.map(m => hasArkKind(m, \"root\") ? m.json : registeredReference(m))\n        },\n        declaredIn: {\n            child: false,\n            serialize: node => node.json\n        },\n        declaredOut: {\n            child: false,\n            serialize: node => node.json\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `a morph from ${node.in.description} to ${node.out?.description ?? \"unknown\"}`\n    },\n    intersections: {\n        morph: (l, r, ctx) => {\n            if (!l.hasEqualMorphs(r)) {\n                return throwParseError(writeMorphIntersectionMessage(l.expression, r.expression));\n            }\n            const inTersection = intersectOrPipeNodes(l.in, r.in, ctx);\n            if (inTersection instanceof Disjoint)\n                return inTersection;\n            const baseInner = {\n                morphs: l.morphs\n            };\n            if (l.declaredIn || r.declaredIn) {\n                const declaredIn = intersectOrPipeNodes(l.in, r.in, ctx);\n                // we can't treat this as a normal Disjoint since it's just declared\n                // it should only happen if someone's essentially trying to create a broken type\n                if (declaredIn instanceof Disjoint)\n                    return declaredIn.throw();\n                else\n                    baseInner.declaredIn = declaredIn;\n            }\n            if (l.declaredOut || r.declaredOut) {\n                const declaredOut = intersectOrPipeNodes(l.out, r.out, ctx);\n                if (declaredOut instanceof Disjoint)\n                    return declaredOut.throw();\n                else\n                    baseInner.declaredOut = declaredOut;\n            }\n            // in case from is a union, we need to distribute the branches\n            // to can be a union as any schema is allowed\n            return inTersection.distribute(inBranch => ctx.$.node(\"morph\", {\n                ...baseInner,\n                in: inBranch\n            }), ctx.$.parseSchema);\n        },\n        ...defineRightwardIntersections(\"morph\", (l, r, ctx) => {\n            const inTersection = l.inner.in ? intersectOrPipeNodes(l.inner.in, r, ctx) : r;\n            return (inTersection instanceof Disjoint ? inTersection\n                : inTersection.equals(l.inner.in) ? l\n                    : ctx.$.node(\"morph\", {\n                        ...l.inner,\n                        in: inTersection\n                    }));\n        })\n    }\n});\nexport class MorphNode extends BaseRoot {\n    serializedMorphs = this.morphs.map(registeredReference);\n    compiledMorphs = `[${this.serializedMorphs}]`;\n    lastMorph = this.inner.morphs.at(-1);\n    lastMorphIfNode = hasArkKind(this.lastMorph, \"root\") ? this.lastMorph : undefined;\n    introspectableIn = this.inner.in;\n    introspectableOut = this.lastMorphIfNode ?\n        Object.assign(this.referencesById, this.lastMorphIfNode.referencesById) &&\n            this.lastMorphIfNode.out\n        : undefined;\n    get shallowMorphs() {\n        // if the morph input is a union, it should not contain any other shallow morphs\n        return Array.isArray(this.inner.in?.shallowMorphs) ?\n            [...this.inner.in.shallowMorphs, ...this.morphs]\n            : this.morphs;\n    }\n    get in() {\n        return (this.declaredIn ?? this.inner.in?.in ?? $ark.intrinsic.unknown.internal);\n    }\n    get out() {\n        return (this.declaredOut ??\n            this.introspectableOut ??\n            $ark.intrinsic.unknown.internal);\n    }\n    declareIn(declaredIn) {\n        return this.$.node(\"morph\", {\n            ...this.inner,\n            declaredIn\n        });\n    }\n    declareOut(declaredOut) {\n        return this.$.node(\"morph\", {\n            ...this.inner,\n            declaredOut\n        });\n    }\n    expression = `(In: ${this.in.expression}) => ${this.lastMorphIfNode ? \"To\" : \"Out\"}<${this.out.expression}>`;\n    get defaultShortDescription() {\n        return this.in.meta.description ?? this.in.defaultShortDescription;\n    }\n    innerToJsonSchema(ctx) {\n        return ctx.fallback.morph({\n            code: \"morph\",\n            base: this.in.toJsonSchemaRecurse(ctx),\n            out: this.introspectableOut?.toJsonSchemaRecurse(ctx) ?? null\n        });\n    }\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            if (!this.introspectableIn)\n                return;\n            js.return(js.invoke(this.introspectableIn));\n            return;\n        }\n        if (this.introspectableIn)\n            js.line(js.invoke(this.introspectableIn));\n        js.line(`ctx.queueMorphs(${this.compiledMorphs})`);\n    }\n    traverseAllows = (data, ctx) => !this.introspectableIn || this.introspectableIn.traverseAllows(data, ctx);\n    traverseApply = (data, ctx) => {\n        if (this.introspectableIn)\n            this.introspectableIn.traverseApply(data, ctx);\n        ctx.queueMorphs(this.morphs);\n    };\n    /** Check if the morphs of r are equal to those of this node */\n    hasEqualMorphs(r) {\n        return arrayEquals(this.morphs, r.morphs, {\n            isEqual: (lMorph, rMorph) => lMorph === rMorph ||\n                (hasArkKind(lMorph, \"root\") &&\n                    hasArkKind(rMorph, \"root\") &&\n                    lMorph.equals(rMorph))\n        });\n    }\n}\nexport const Morph = {\n    implementation,\n    Node: MorphNode\n};\nexport const writeMorphIntersectionMessage = (lDescription, rDescription) => `The intersection of distinct morphs at a single path is indeterminate:\nLeft: ${lDescription}\nRight: ${rDescription}`;\n", "import { builtinConstructors, constructorExtends, domainOf, getBuiltinNameOfConstructor, hasKey, objectKindDescriptions, objectKindOrDomainOf, throwParseError } from \"@ark/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { defaultValueSerializer, implementNode } from \"../shared/implement.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { isNode } from \"../shared/utils.js\";\nimport { InternalBasis } from \"./basis.js\";\nconst implementation = implementNode({\n    kind: \"proto\",\n    hasAssociatedError: true,\n    collapsibleKey: \"proto\",\n    keys: {\n        proto: {\n            serialize: ctor => getBuiltinNameOfConstructor(ctor) ?? defaultValueSerializer(ctor)\n        },\n        dateAllowsInvalid: {}\n    },\n    normalize: schema => {\n        const normalized = typeof schema === \"string\" ? { proto: builtinConstructors[schema] }\n            : typeof schema === \"function\" ?\n                isNode(schema) ? schema\n                    : { proto: schema }\n                : typeof schema.proto === \"string\" ?\n                    { ...schema, proto: builtinConstructors[schema.proto] }\n                    : schema;\n        if (typeof normalized.proto !== \"function\")\n            throwParseError(Proto.writeInvalidSchemaMessage(normalized.proto));\n        if (hasKey(normalized, \"dateAllowsInvalid\") && normalized.proto !== Date)\n            throwParseError(Proto.writeBadInvalidDateMessage(normalized.proto));\n        return normalized;\n    },\n    applyConfig: (schema, config) => {\n        if (schema.dateAllowsInvalid === undefined &&\n            schema.proto === Date &&\n            config.dateAllowsInvalid)\n            return { ...schema, dateAllowsInvalid: true };\n        return schema;\n    },\n    defaults: {\n        description: node => node.builtinName ?\n            objectKindDescriptions[node.builtinName]\n            : `an instance of ${node.proto.name}`,\n        actual: data => data instanceof Date && data.toString() === \"Invalid Date\" ?\n            \"an invalid Date\"\n            : objectKindOrDomainOf(data)\n    },\n    intersections: {\n        proto: (l, r) => l.proto === Date && r.proto === Date ?\n            // since l === r is handled by default,\n            // exactly one of l or r must have allow invalid dates\n            l.dateAllowsInvalid ?\n                r\n                : l\n            : constructorExtends(l.proto, r.proto) ? l\n                : constructorExtends(r.proto, l.proto) ? r\n                    : Disjoint.init(\"proto\", l, r),\n        domain: (proto, domain) => domain.domain === \"object\" ?\n            proto\n            : Disjoint.init(\"domain\", $ark.intrinsic.object.internal, domain)\n    }\n});\nexport class ProtoNode extends InternalBasis {\n    builtinName = getBuiltinNameOfConstructor(this.proto);\n    serializedConstructor = this.json.proto;\n    requiresInvalidDateCheck = this.proto === Date && !this.dateAllowsInvalid;\n    traverseAllows = this.requiresInvalidDateCheck ?\n        data => data instanceof Date && data.toString() !== \"Invalid Date\"\n        : data => data instanceof this.proto;\n    compiledCondition = `data instanceof ${this.serializedConstructor}${this.requiresInvalidDateCheck ? ` && data.toString() !== \"Invalid Date\"` : \"\"}`;\n    compiledNegation = `!(${this.compiledCondition})`;\n    innerToJsonSchema(ctx) {\n        switch (this.builtinName) {\n            case \"Array\":\n                return {\n                    type: \"array\"\n                };\n            case \"Date\":\n                return (ctx.fallback.date?.({ code: \"date\", base: {} }) ??\n                    ctx.fallback.proto({ code: \"proto\", base: {}, proto: this.proto }));\n            default:\n                return ctx.fallback.proto({\n                    code: \"proto\",\n                    base: {},\n                    proto: this.proto\n                });\n        }\n    }\n    expression = this.dateAllowsInvalid ? \"Date | InvalidDate\" : this.proto.name;\n    get nestableExpression() {\n        return this.dateAllowsInvalid ? `(${this.expression})` : this.expression;\n    }\n    domain = \"object\";\n    get defaultShortDescription() {\n        return this.description;\n    }\n}\nexport const Proto = {\n    implementation,\n    Node: ProtoNode,\n    writeBadInvalidDateMessage: (actual) => `dateAllowsInvalid may only be specified with constructor Date (was ${actual.name})`,\n    writeInvalidSchemaMessage: (actual) => `instanceOf operand must be a function (was ${domainOf(actual)})`\n};\n", "import { appendUnique, arrayEquals, domainDescriptions, flatMorph, groupBy, hasKey, isArray, jsTypeOfDescriptions, printable, range, throwParseError, unset } from \"@ark/util\";\nimport { compileLiteralPropAccess, compileSerializedValue } from \"../shared/compile.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodesRoot, intersectOrPipeNodes } from \"../shared/intersections.js\";\nimport { $ark, registeredReference } from \"../shared/registry.js\";\nimport { Traversal } from \"../shared/traversal.js\";\nimport { hasArkKind } from \"../shared/utils.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nconst implementation = implementNode({\n    kind: \"union\",\n    hasAssociatedError: true,\n    collapsibleKey: \"branches\",\n    keys: {\n        ordered: {},\n        branches: {\n            child: true,\n            parse: (schema, ctx) => {\n                const branches = [];\n                for (const branchSchema of schema) {\n                    const branchNodes = hasArkKind(branchSchema, \"root\") ?\n                        branchSchema.branches\n                        : ctx.$.parseSchema(branchSchema).branches;\n                    for (const node of branchNodes) {\n                        if (node.hasKind(\"morph\")) {\n                            const matchingMorphIndex = branches.findIndex(matching => matching.hasKind(\"morph\") && matching.hasEqualMorphs(node));\n                            if (matchingMorphIndex === -1)\n                                branches.push(node);\n                            else {\n                                const matchingMorph = branches[matchingMorphIndex];\n                                branches[matchingMorphIndex] = ctx.$.node(\"morph\", {\n                                    ...matchingMorph.inner,\n                                    in: matchingMorph.in.rawOr(node.in)\n                                });\n                            }\n                        }\n                        else\n                            branches.push(node);\n                    }\n                }\n                if (!ctx.def.ordered)\n                    branches.sort((l, r) => (l.hash < r.hash ? -1 : 1));\n                return branches;\n            }\n        }\n    },\n    normalize: schema => (isArray(schema) ? { branches: schema } : schema),\n    reduce: (inner, $) => {\n        const reducedBranches = reduceBranches(inner);\n        if (reducedBranches.length === 1)\n            return reducedBranches[0];\n        if (reducedBranches.length === inner.branches.length)\n            return;\n        return $.node(\"union\", {\n            ...inner,\n            branches: reducedBranches\n        }, { prereduced: true });\n    },\n    defaults: {\n        description: node => node.distribute(branch => branch.description, describeBranches),\n        expected: ctx => {\n            const byPath = groupBy(ctx.errors, \"propString\");\n            const pathDescriptions = Object.entries(byPath).map(([path, errors]) => {\n                const branchesAtPath = [];\n                for (const errorAtPath of errors)\n                    appendUnique(branchesAtPath, errorAtPath.expected);\n                const expected = describeBranches(branchesAtPath);\n                // if there are multiple actual descriptions that differ,\n                // just fall back to printable, which is the most specific\n                const actual = errors.every(e => e.actual === errors[0].actual) ?\n                    errors[0].actual\n                    : printable(errors[0].data);\n                return `${path && `${path} `}must be ${expected}${actual && ` (was ${actual})`}`;\n            });\n            return describeBranches(pathDescriptions);\n        },\n        problem: ctx => ctx.expected,\n        message: ctx => ctx.problem\n    },\n    intersections: {\n        union: (l, r, ctx) => {\n            if (l.isNever !== r.isNever) {\n                // if exactly one operand is never, we can use it to discriminate based on presence\n                return Disjoint.init(\"presence\", l, r);\n            }\n            let resultBranches;\n            if (l.ordered) {\n                if (r.ordered) {\n                    throwParseError(writeOrderedIntersectionMessage(l.expression, r.expression));\n                }\n                resultBranches = intersectBranches(r.branches, l.branches, ctx);\n                if (resultBranches instanceof Disjoint)\n                    resultBranches.invert();\n            }\n            else\n                resultBranches = intersectBranches(l.branches, r.branches, ctx);\n            if (resultBranches instanceof Disjoint)\n                return resultBranches;\n            return ctx.$.parseSchema(l.ordered || r.ordered ?\n                {\n                    branches: resultBranches,\n                    ordered: true\n                }\n                : { branches: resultBranches });\n        },\n        ...defineRightwardIntersections(\"union\", (l, r, ctx) => {\n            const branches = intersectBranches(l.branches, [r], ctx);\n            if (branches instanceof Disjoint)\n                return branches;\n            if (branches.length === 1)\n                return branches[0];\n            return ctx.$.parseSchema(l.ordered ? { branches, ordered: true } : { branches });\n        })\n    }\n});\nexport class UnionNode extends BaseRoot {\n    isBoolean = this.branches.length === 2 &&\n        this.branches[0].hasUnit(false) &&\n        this.branches[1].hasUnit(true);\n    get branchGroups() {\n        const branchGroups = [];\n        let firstBooleanIndex = -1;\n        for (const branch of this.branches) {\n            if (branch.hasKind(\"unit\") && branch.domain === \"boolean\") {\n                if (firstBooleanIndex === -1) {\n                    firstBooleanIndex = branchGroups.length;\n                    branchGroups.push(branch);\n                }\n                else\n                    branchGroups[firstBooleanIndex] = $ark.intrinsic.boolean;\n                continue;\n            }\n            branchGroups.push(branch);\n        }\n        return branchGroups;\n    }\n    unitBranches = this.branches.filter((n) => n.in.hasKind(\"unit\"));\n    discriminant = this.discriminate();\n    discriminantJson = this.discriminant ? discriminantToJson(this.discriminant) : null;\n    expression = this.distribute(n => n.nestableExpression, expressBranches);\n    createBranchedOptimisticRootApply() {\n        return (data, onFail) => {\n            const optimisticResult = this.traverseOptimistic(data);\n            if (optimisticResult !== unset)\n                return optimisticResult;\n            const ctx = new Traversal(data, this.$.resolvedConfig);\n            this.traverseApply(data, ctx);\n            return ctx.finalize(onFail);\n        };\n    }\n    get shallowMorphs() {\n        return this.branches.reduce((morphs, branch) => appendUnique(morphs, branch.shallowMorphs), []);\n    }\n    get defaultShortDescription() {\n        return this.distribute(branch => branch.defaultShortDescription, describeBranches);\n    }\n    innerToJsonSchema(ctx) {\n        // special case to simplify { const: true } | { const: false }\n        // to the canonical JSON Schema representation { type: \"boolean\" }\n        if (this.branchGroups.length === 1 &&\n            this.branchGroups[0].equals($ark.intrinsic.boolean))\n            return { type: \"boolean\" };\n        const jsonSchemaBranches = this.branchGroups.map(group => group.toJsonSchemaRecurse(ctx));\n        if (jsonSchemaBranches.every((branch) => \n        // iff all branches are pure unit values with no metadata,\n        // we can simplify the representation to an enum\n        Object.keys(branch).length === 1 && hasKey(branch, \"const\"))) {\n            return {\n                enum: jsonSchemaBranches.map(branch => branch.const)\n            };\n        }\n        return {\n            anyOf: jsonSchemaBranches\n        };\n    }\n    traverseAllows = (data, ctx) => this.branches.some(b => b.traverseAllows(data, ctx));\n    traverseApply = (data, ctx) => {\n        const errors = [];\n        for (let i = 0; i < this.branches.length; i++) {\n            ctx.pushBranch();\n            this.branches[i].traverseApply(data, ctx);\n            if (!ctx.hasError()) {\n                if (this.branches[i].includesTransform)\n                    return ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs);\n                return ctx.popBranch();\n            }\n            errors.push(ctx.popBranch().error);\n        }\n        ctx.errorFromNodeContext({ code: \"union\", errors, meta: this.meta });\n    };\n    traverseOptimistic = (data) => {\n        for (let i = 0; i < this.branches.length; i++) {\n            const branch = this.branches[i];\n            if (branch.traverseAllows(data)) {\n                if (branch.contextFreeMorph)\n                    return branch.contextFreeMorph(data);\n                // if we're calling this function and the matching branch didn't have\n                // a context-free morph, it shouldn't have morphs at all\n                return data;\n            }\n        }\n        return unset;\n    };\n    compile(js) {\n        if (!this.discriminant ||\n            // if we have a union of two units like `boolean`, the\n            // undiscriminated compilation will be just as fast\n            (this.unitBranches.length === this.branches.length &&\n                this.branches.length === 2))\n            return this.compileIndiscriminable(js);\n        // we need to access the path as optional so we don't throw if it isn't present\n        let condition = this.discriminant.optionallyChainedPropString;\n        if (this.discriminant.kind === \"domain\")\n            condition = `typeof ${condition} === \"object\" ? ${condition} === null ? \"null\" : \"object\" : typeof ${condition} === \"function\" ? \"object\" : typeof ${condition}`;\n        const cases = this.discriminant.cases;\n        const caseKeys = Object.keys(cases);\n        const { optimistic } = js;\n        // only the first layer can be optimistic\n        js.optimistic = false;\n        js.block(`switch(${condition})`, () => {\n            for (const k in cases) {\n                const v = cases[k];\n                const caseCondition = k === \"default\" ? k : `case ${k}`;\n                js.line(`${caseCondition}: return ${v === true ?\n                    optimistic ? js.data\n                        : v\n                    : optimistic ?\n                        `${js.invoke(v)} ? ${v.contextFreeMorph ? `${registeredReference(v.contextFreeMorph)}(${js.data})` : js.data} : \"${unset}\"`\n                        : js.invoke(v)}`);\n            }\n            return js;\n        });\n        if (js.traversalKind === \"Allows\") {\n            js.return(optimistic ? `\"${unset}\"` : false);\n            return;\n        }\n        const expected = describeBranches(this.discriminant.kind === \"domain\" ?\n            caseKeys.map(k => {\n                const jsTypeOf = k.slice(1, -1);\n                return jsTypeOf === \"function\" ?\n                    domainDescriptions.object\n                    : domainDescriptions[jsTypeOf];\n            })\n            : caseKeys);\n        const serializedPathSegments = this.discriminant.path.map(k => typeof k === \"symbol\" ? registeredReference(k) : JSON.stringify(k));\n        const serializedExpected = JSON.stringify(expected);\n        const serializedActual = this.discriminant.kind === \"domain\" ?\n            `${serializedTypeOfDescriptions}[${condition}]`\n            : `${serializedPrintable}(${condition})`;\n        js.line(`ctx.errorFromNodeContext({\n\tcode: \"predicate\",\n\texpected: ${serializedExpected},\n\tactual: ${serializedActual},\n\trelativePath: [${serializedPathSegments}],\n\tmeta: ${this.compiledMeta}\n})`);\n    }\n    compileIndiscriminable(js) {\n        if (js.traversalKind === \"Apply\") {\n            js.const(\"errors\", \"[]\");\n            for (const branch of this.branches) {\n                js.line(\"ctx.pushBranch()\")\n                    .line(js.invoke(branch))\n                    .if(\"!ctx.hasError()\", () => js.return(branch.includesTransform ?\n                    \"ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs)\"\n                    : \"ctx.popBranch()\"))\n                    .line(\"errors.push(ctx.popBranch().error)\");\n            }\n            js.line(`ctx.errorFromNodeContext({ code: \"union\", errors, meta: ${this.compiledMeta} })`);\n        }\n        else {\n            const { optimistic } = js;\n            // only the first layer can be optimistic\n            js.optimistic = false;\n            for (const branch of this.branches) {\n                js.if(`${js.invoke(branch)}`, () => js.return(optimistic ?\n                    branch.contextFreeMorph ?\n                        `${registeredReference(branch.contextFreeMorph)}(${js.data})`\n                        : js.data\n                    : true));\n            }\n            js.return(optimistic ? `\"${unset}\"` : false);\n        }\n    }\n    get nestableExpression() {\n        // avoid adding unnecessary parentheses around boolean since it's\n        // already collapsed to a single keyword\n        return this.isBoolean ? \"boolean\" : `(${this.expression})`;\n    }\n    discriminate() {\n        if (this.branches.length < 2 || this.isCyclic)\n            return null;\n        if (this.unitBranches.length === this.branches.length) {\n            const cases = flatMorph(this.unitBranches, (i, n) => [\n                `${n.in.serializedValue}`,\n                n.hasKind(\"morph\") ? n : true\n            ]);\n            return {\n                kind: \"unit\",\n                path: [],\n                optionallyChainedPropString: \"data\",\n                cases\n            };\n        }\n        const candidates = [];\n        for (let lIndex = 0; lIndex < this.branches.length - 1; lIndex++) {\n            const l = this.branches[lIndex];\n            for (let rIndex = lIndex + 1; rIndex < this.branches.length; rIndex++) {\n                const r = this.branches[rIndex];\n                const result = intersectNodesRoot(l.in, r.in, l.$);\n                if (!(result instanceof Disjoint))\n                    continue;\n                for (const entry of result) {\n                    if (!entry.kind || entry.optional)\n                        continue;\n                    let lSerialized;\n                    let rSerialized;\n                    if (entry.kind === \"domain\") {\n                        const lValue = entry.l;\n                        const rValue = entry.r;\n                        lSerialized = `\"${typeof lValue === \"string\" ? lValue : lValue.domain}\"`;\n                        rSerialized = `\"${typeof rValue === \"string\" ? rValue : rValue.domain}\"`;\n                    }\n                    else if (entry.kind === \"unit\") {\n                        lSerialized = entry.l.serializedValue;\n                        rSerialized = entry.r.serializedValue;\n                    }\n                    else\n                        continue;\n                    const matching = candidates.find(d => arrayEquals(d.path, entry.path) && d.kind === entry.kind);\n                    if (!matching) {\n                        candidates.push({\n                            kind: entry.kind,\n                            cases: {\n                                [lSerialized]: {\n                                    branchIndices: [lIndex],\n                                    condition: entry.l\n                                },\n                                [rSerialized]: {\n                                    branchIndices: [rIndex],\n                                    condition: entry.r\n                                }\n                            },\n                            path: entry.path\n                        });\n                    }\n                    else {\n                        if (matching.cases[lSerialized]) {\n                            matching.cases[lSerialized].branchIndices = appendUnique(matching.cases[lSerialized].branchIndices, lIndex);\n                        }\n                        else {\n                            matching.cases[lSerialized] ??= {\n                                branchIndices: [lIndex],\n                                condition: entry.l\n                            };\n                        }\n                        if (matching.cases[rSerialized]) {\n                            matching.cases[rSerialized].branchIndices = appendUnique(matching.cases[rSerialized].branchIndices, rIndex);\n                        }\n                        else {\n                            matching.cases[rSerialized] ??= {\n                                branchIndices: [rIndex],\n                                condition: entry.r\n                            };\n                        }\n                    }\n                }\n            }\n        }\n        const orderedCandidates = this.ordered ? orderCandidates(candidates, this.branches) : candidates;\n        if (!orderedCandidates.length)\n            return null;\n        const ctx = createCaseResolutionContext(orderedCandidates, this);\n        const cases = {};\n        for (const k in ctx.best.cases) {\n            const resolution = resolveCase(ctx, k);\n            if (resolution === null) {\n                cases[k] = true;\n                continue;\n            }\n            // if all the branches ended up back in pruned, we'd loop if we continued\n            // so just bail out- nothing left to discriminate\n            if (resolution.length === this.branches.length)\n                return null;\n            if (this.ordered) {\n                // ensure the original order of the pruned branches is preserved\n                resolution.sort((l, r) => l.originalIndex - r.originalIndex);\n            }\n            const branches = resolution.map(entry => entry.branch);\n            const caseNode = branches.length === 1 ?\n                branches[0]\n                : this.$.node(\"union\", this.ordered ? { branches, ordered: true } : branches);\n            Object.assign(this.referencesById, caseNode.referencesById);\n            cases[k] = caseNode;\n        }\n        if (ctx.defaultEntries.length) {\n            // we don't have to worry about order here as it is always preserved\n            // within defaultEntries\n            const branches = ctx.defaultEntries.map(entry => entry.branch);\n            cases.default = this.$.node(\"union\", this.ordered ? { branches, ordered: true } : branches, {\n                prereduced: true\n            });\n            Object.assign(this.referencesById, cases.default.referencesById);\n        }\n        return Object.assign(ctx.location, {\n            cases\n        });\n    }\n}\nconst createCaseResolutionContext = (orderedCandidates, node) => {\n    const best = orderedCandidates.sort((l, r) => Object.keys(r.cases).length - Object.keys(l.cases).length)[0];\n    const location = {\n        kind: best.kind,\n        path: best.path,\n        optionallyChainedPropString: optionallyChainPropString(best.path)\n    };\n    const defaultEntries = node.branches.map((branch, originalIndex) => ({\n        originalIndex,\n        branch\n    }));\n    return {\n        best,\n        location,\n        defaultEntries,\n        node\n    };\n};\nconst resolveCase = (ctx, key) => {\n    const caseCtx = ctx.best.cases[key];\n    const discriminantNode = discriminantCaseToNode(caseCtx.condition, ctx.location.path, ctx.node.$);\n    let resolvedEntries = [];\n    const nextDefaults = [];\n    for (let i = 0; i < ctx.defaultEntries.length; i++) {\n        const entry = ctx.defaultEntries[i];\n        if (caseCtx.branchIndices.includes(entry.originalIndex)) {\n            const pruned = pruneDiscriminant(ctx.node.branches[entry.originalIndex], ctx.location);\n            if (pruned === null) {\n                // if any branch of the union has no constraints (i.e. is\n                // unknown), the others won't affect the resolution type, but could still\n                // remove additional cases from defaultEntries\n                resolvedEntries = null;\n            }\n            else {\n                resolvedEntries?.push({\n                    originalIndex: entry.originalIndex,\n                    branch: pruned\n                });\n            }\n        }\n        else if (\n        // we shouldn't need a special case for alias to avoid the below\n        // once alias resolution issues are improved:\n        // https://github.com/arktypeio/arktype/issues/1026\n        entry.branch.hasKind(\"alias\") &&\n            discriminantNode.hasKind(\"domain\") &&\n            discriminantNode.domain === \"object\")\n            resolvedEntries?.push(entry);\n        else {\n            if (entry.branch.in.overlaps(discriminantNode)) {\n                // include cases where an object not including the\n                // discriminant path might have that value present as an undeclared key\n                const overlapping = pruneDiscriminant(entry.branch, ctx.location);\n                resolvedEntries?.push({\n                    originalIndex: entry.originalIndex,\n                    branch: overlapping\n                });\n            }\n            nextDefaults.push(entry);\n        }\n    }\n    ctx.defaultEntries = nextDefaults;\n    return resolvedEntries;\n};\nconst orderCandidates = (candidates, originalBranches) => {\n    const viableCandidates = candidates.filter(candidate => {\n        const caseGroups = Object.values(candidate.cases).map(caseCtx => caseCtx.branchIndices);\n        // compare each group against all subsequent groups.\n        for (let i = 0; i < caseGroups.length - 1; i++) {\n            const currentGroup = caseGroups[i];\n            for (let j = i + 1; j < caseGroups.length; j++) {\n                const nextGroup = caseGroups[j];\n                // for each group pair, check for branches whose order was reversed\n                for (const currentIndex of currentGroup) {\n                    for (const nextIndex of nextGroup) {\n                        if (currentIndex > nextIndex) {\n                            if (originalBranches[currentIndex].overlaps(originalBranches[nextIndex])) {\n                                // if the order was not preserved and the branches overlap,\n                                // this is not a viable discriminant as it cannot guarantee the same behavior\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // branch groups preserved order for non-disjoint pairs and is viable\n        return true;\n    });\n    return viableCandidates;\n};\nconst discriminantCaseToNode = (caseDiscriminant, path, $) => {\n    let node = caseDiscriminant === \"undefined\" ? $.node(\"unit\", { unit: undefined })\n        : caseDiscriminant === \"null\" ? $.node(\"unit\", { unit: null })\n            : caseDiscriminant === \"boolean\" ? $.units([true, false])\n                : caseDiscriminant;\n    for (let i = path.length - 1; i >= 0; i--) {\n        const key = path[i];\n        node = $.node(\"intersection\", typeof key === \"number\" ?\n            {\n                proto: \"Array\",\n                // create unknown for preceding elements (could be optimized with safe imports)\n                sequence: [...range(key).map(_ => ({})), node]\n            }\n            : {\n                domain: \"object\",\n                required: [{ key, value: node }]\n            });\n    }\n    return node;\n};\nconst optionallyChainPropString = (path) => path.reduce((acc, k) => acc + compileLiteralPropAccess(k, true), \"data\");\nconst serializedTypeOfDescriptions = registeredReference(jsTypeOfDescriptions);\nconst serializedPrintable = registeredReference(printable);\nexport const Union = {\n    implementation,\n    Node: UnionNode\n};\nconst discriminantToJson = (discriminant) => ({\n    kind: discriminant.kind,\n    path: discriminant.path.map(k => typeof k === \"string\" ? k : compileSerializedValue(k)),\n    cases: flatMorph(discriminant.cases, (k, node) => [\n        k,\n        node === true ? node\n            : node.hasKind(\"union\") && node.discriminantJson ? node.discriminantJson\n                : node.json\n    ])\n});\nconst describeExpressionOptions = {\n    delimiter: \" | \",\n    finalDelimiter: \" | \"\n};\nconst expressBranches = (expressions) => describeBranches(expressions, describeExpressionOptions);\nexport const describeBranches = (descriptions, opts) => {\n    const delimiter = opts?.delimiter ?? \", \";\n    const finalDelimiter = opts?.finalDelimiter ?? \" or \";\n    if (descriptions.length === 0)\n        return \"never\";\n    if (descriptions.length === 1)\n        return descriptions[0];\n    if ((descriptions.length === 2 &&\n        descriptions[0] === \"false\" &&\n        descriptions[1] === \"true\") ||\n        (descriptions[0] === \"true\" && descriptions[1] === \"false\"))\n        return \"boolean\";\n    // keep track of seen descriptions to avoid duplication\n    const seen = {};\n    const unique = descriptions.filter(s => (seen[s] ? false : (seen[s] = true)));\n    const last = unique.pop();\n    return `${unique.join(delimiter)}${unique.length ? finalDelimiter : \"\"}${last}`;\n};\nexport const intersectBranches = (l, r, ctx) => {\n    // If the corresponding r branch is identified as a subtype of an l branch, the\n    // value at rIndex is set to null so we can avoid including previous/future\n    // intersections in the reduced result.\n    const batchesByR = r.map(() => []);\n    for (let lIndex = 0; lIndex < l.length; lIndex++) {\n        let candidatesByR = {};\n        for (let rIndex = 0; rIndex < r.length; rIndex++) {\n            if (batchesByR[rIndex] === null) {\n                // rBranch is a subtype of an lBranch and\n                // will not yield any distinct intersection\n                continue;\n            }\n            if (l[lIndex].equals(r[rIndex])) {\n                // Combination of subtype and supertype cases\n                batchesByR[rIndex] = null;\n                candidatesByR = {};\n                break;\n            }\n            const branchIntersection = intersectOrPipeNodes(l[lIndex], r[rIndex], ctx);\n            if (branchIntersection instanceof Disjoint) {\n                // Doesn't tell us anything useful about their relationships\n                // with other branches\n                continue;\n            }\n            if (branchIntersection.equals(l[lIndex])) {\n                // If the current l branch is a subtype of r, intersections\n                // with previous and remaining branches of r won't lead to\n                // distinct intersections.\n                batchesByR[rIndex].push(l[lIndex]);\n                candidatesByR = {};\n                break;\n            }\n            if (branchIntersection.equals(r[rIndex])) {\n                // If the current r branch is a subtype of l, set its batch to\n                // null, removing any previous intersections and preventing any\n                // of its remaining intersections from being computed.\n                batchesByR[rIndex] = null;\n            }\n            else {\n                // If neither l nor r is a subtype of the other, add their\n                // intersection as a candidate (could still be removed if it is\n                // determined l or r is a subtype of a remaining branch).\n                candidatesByR[rIndex] = branchIntersection;\n            }\n        }\n        for (const rIndex in candidatesByR) {\n            // batchesByR at rIndex should never be null if it is in candidatesByR\n            batchesByR[rIndex][lIndex] = candidatesByR[rIndex];\n        }\n    }\n    // Compile the reduced intersection result, including:\n    // \t\t1. Remaining candidates resulting from distinct intersections or strict subtypes of r\n    // \t\t2. Original r branches corresponding to indices with a null batch (subtypes of l)\n    const resultBranches = batchesByR.flatMap(\n    // ensure unions returned from branchable intersections like sequence are flattened\n    (batch, i) => batch?.flatMap(branch => branch.branches) ?? r[i]);\n    return resultBranches.length === 0 ?\n        Disjoint.init(\"union\", l, r)\n        : resultBranches;\n};\nexport const reduceBranches = ({ branches, ordered }) => {\n    if (branches.length < 2)\n        return branches;\n    const uniquenessByIndex = branches.map(() => true);\n    for (let i = 0; i < branches.length; i++) {\n        for (let j = i + 1; j < branches.length && uniquenessByIndex[i] && uniquenessByIndex[j]; j++) {\n            if (branches[i].equals(branches[j])) {\n                // if the two branches are equal, only \"j\" is marked as\n                // redundant so at least one copy could still be included in\n                // the final set of branches.\n                uniquenessByIndex[j] = false;\n                continue;\n            }\n            const intersection = intersectNodesRoot(branches[i].in, branches[j].in, branches[0].$);\n            if (intersection instanceof Disjoint)\n                continue;\n            if (!ordered)\n                assertDeterminateOverlap(branches[i], branches[j]);\n            if (intersection.equals(branches[i].in)) {\n                // preserve ordered branches that are a subtype of a subsequent branch\n                uniquenessByIndex[i] = !!ordered;\n            }\n            else if (intersection.equals(branches[j].in))\n                uniquenessByIndex[j] = false;\n        }\n    }\n    return branches.filter((_, i) => uniquenessByIndex[i]);\n};\nconst assertDeterminateOverlap = (l, r) => {\n    if (!l.includesTransform && !r.includesTransform)\n        return;\n    if (!arrayEquals(l.shallowMorphs, r.shallowMorphs)) {\n        throwParseError(writeIndiscriminableMorphMessage(l.expression, r.expression));\n    }\n    if (!arrayEquals(l.flatMorphs, r.flatMorphs, {\n        isEqual: (l, r) => l.propString === r.propString &&\n            (l.node.hasKind(\"morph\") && r.node.hasKind(\"morph\") ?\n                l.node.hasEqualMorphs(r.node)\n                : l.node.hasKind(\"intersection\") && r.node.hasKind(\"intersection\") ?\n                    l.node.structure?.structuralMorphRef ===\n                        r.node.structure?.structuralMorphRef\n                    : false)\n    })) {\n        throwParseError(writeIndiscriminableMorphMessage(l.expression, r.expression));\n    }\n};\nexport const pruneDiscriminant = (discriminantBranch, discriminantCtx) => discriminantBranch.transform((nodeKind, inner) => {\n    if (nodeKind === \"domain\" || nodeKind === \"unit\")\n        return null;\n    return inner;\n}, {\n    shouldTransform: (node, ctx) => {\n        // safe to cast here as index nodes are never discriminants\n        const propString = optionallyChainPropString(ctx.path);\n        if (!discriminantCtx.optionallyChainedPropString.startsWith(propString))\n            return false;\n        if (node.hasKind(\"domain\") && node.domain === \"object\")\n            // if we've already checked a path at least as long as the current one,\n            // we don't need to revalidate that we're in an object\n            return true;\n        if ((node.hasKind(\"domain\") || discriminantCtx.kind === \"unit\") &&\n            propString === discriminantCtx.optionallyChainedPropString)\n            // if the discriminant has already checked the domain at the current path\n            // (or a unit literal, implying a domain), we don't need to recheck it\n            return true;\n        // we don't need to recurse into index nodes as they will never\n        // have a required path therefore can't be used to discriminate\n        return node.children.length !== 0 && node.kind !== \"index\";\n    }\n});\nexport const writeIndiscriminableMorphMessage = (lDescription, rDescription) => `An unordered union of a type including a morph and a type with overlapping input is indeterminate:\nLeft: ${lDescription}\nRight: ${rDescription}`;\nexport const writeOrderedIntersectionMessage = (lDescription, rDescription) => `The intersection of two ordered unions is indeterminate:\nLeft: ${lDescription}\nRight: ${rDescription}`;\n", "import { domainDescriptions, domainOf, printable } from \"@ark/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { defaultValueSerializer, implementNode } from \"../shared/implement.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { InternalBasis } from \"./basis.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nconst implementation = implementNode({\n    kind: \"unit\",\n    hasAssociatedError: true,\n    keys: {\n        unit: {\n            preserveUndefined: true,\n            serialize: schema => schema instanceof Date ?\n                schema.toISOString()\n                : defaultValueSerializer(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => printable(node.unit),\n        problem: ({ expected, actual }) => `${expected === actual ? `must be reference equal to ${expected} (serialized to the same value)` : `must be ${expected} (was ${actual})`}`\n    },\n    intersections: {\n        unit: (l, r) => Disjoint.init(\"unit\", l, r),\n        ...defineRightwardIntersections(\"unit\", (l, r) => {\n            if (r.allows(l.unit))\n                return l;\n            // will always be a disjoint at this point, but we try to use\n            // a domain Disjoint if possible since it's better for discrimination\n            const rBasis = r.hasKind(\"intersection\") ? r.basis : r;\n            if (rBasis) {\n                const rDomain = rBasis.hasKind(\"domain\") ? rBasis : $ark.intrinsic.object;\n                if (l.domain !== rDomain.domain) {\n                    const lDomainDisjointValue = (l.domain === \"undefined\" ||\n                        l.domain === \"null\" ||\n                        l.domain === \"boolean\") ?\n                        l.domain\n                        : $ark.intrinsic[l.domain];\n                    return Disjoint.init(\"domain\", lDomainDisjointValue, rDomain);\n                }\n            }\n            return Disjoint.init(\"assignability\", l, r.hasKind(\"intersection\") ?\n                r.children.find(rConstraint => !rConstraint.allows(l.unit))\n                : r);\n        })\n    }\n});\nexport class UnitNode extends InternalBasis {\n    compiledValue = this.json.unit;\n    serializedValue = typeof this.unit === \"string\" || this.unit instanceof Date ?\n        JSON.stringify(this.compiledValue)\n        : `${this.compiledValue}`;\n    compiledCondition = compileEqualityCheck(this.unit, this.serializedValue);\n    compiledNegation = compileEqualityCheck(this.unit, this.serializedValue, \"negated\");\n    expression = printable(this.unit);\n    domain = domainOf(this.unit);\n    get defaultShortDescription() {\n        return this.domain === \"object\" ?\n            domainDescriptions.object\n            : this.description;\n    }\n    innerToJsonSchema(ctx) {\n        return (\n        // this is the more standard JSON schema representation, especially for Open API\n        this.unit === null ? { type: \"null\" }\n            : $ark.intrinsic.jsonPrimitive.allows(this.unit) ? { const: this.unit }\n                : ctx.fallback.unit({ code: \"unit\", base: {}, unit: this.unit }));\n    }\n    traverseAllows = this.unit instanceof Date ?\n        data => data instanceof Date && data.toISOString() === this.compiledValue\n        : Number.isNaN(this.unit) ? data => Number.isNaN(data)\n            : data => data === this.unit;\n}\nexport const Unit = {\n    implementation,\n    Node: UnitNode\n};\nconst compileEqualityCheck = (unit, serializedValue, negated) => {\n    if (unit instanceof Date) {\n        const condition = `data instanceof Date && data.toISOString() === ${serializedValue}`;\n        return negated ? `!(${condition})` : condition;\n    }\n    if (Number.isNaN(unit))\n        return `${negated ? \"!\" : \"\"}Number.isNaN(data)`;\n    return `data ${negated ? \"!\" : \"=\"}== ${serializedValue}`;\n};\n", "import { append, printable, stringAndSymbolicEntriesOf, throwParseError } from \"@ark/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { flatRef } from \"../node.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectOrPipeNodes } from \"../shared/intersections.js\";\nimport { $ark } from \"../shared/registry.js\";\nimport { traverseKey } from \"../shared/traversal.js\";\nconst implementation = implementNode({\n    kind: \"index\",\n    hasAssociatedError: false,\n    intersectionIsOpen: true,\n    keys: {\n        signature: {\n            child: true,\n            parse: (schema, ctx) => {\n                const key = ctx.$.parseSchema(schema);\n                if (!key.extends($ark.intrinsic.key)) {\n                    return throwParseError(writeInvalidPropertyKeyMessage(key.expression));\n                }\n                const enumerableBranches = key.branches.filter(b => b.hasKind(\"unit\"));\n                if (enumerableBranches.length) {\n                    return throwParseError(writeEnumerableIndexBranches(enumerableBranches.map(b => printable(b.unit))));\n                }\n                return key;\n            }\n        },\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.parseSchema(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `[${node.signature.expression}]: ${node.value.description}`\n    },\n    intersections: {\n        index: (l, r, ctx) => {\n            if (l.signature.equals(r.signature)) {\n                const valueIntersection = intersectOrPipeNodes(l.value, r.value, ctx);\n                const value = valueIntersection instanceof Disjoint ?\n                    $ark.intrinsic.never.internal\n                    : valueIntersection;\n                return ctx.$.node(\"index\", { signature: l.signature, value });\n            }\n            // if r constrains all of l's keys to a subtype of l's value, r is a subtype of l\n            if (l.signature.extends(r.signature) && l.value.subsumes(r.value))\n                return r;\n            // if l constrains all of r's keys to a subtype of r's value, l is a subtype of r\n            if (r.signature.extends(l.signature) && r.value.subsumes(l.value))\n                return l;\n            // other relationships between index signatures can't be generally reduced\n            return null;\n        }\n    }\n});\nexport class IndexNode extends BaseConstraint {\n    impliedBasis = $ark.intrinsic.object.internal;\n    expression = `[${this.signature.expression}]: ${this.value.expression}`;\n    flatRefs = append(this.value.flatRefs.map(ref => flatRef([this.signature, ...ref.path], ref.node)), flatRef([this.signature], this.value));\n    traverseAllows = (data, ctx) => stringAndSymbolicEntriesOf(data).every(entry => {\n        if (this.signature.traverseAllows(entry[0], ctx)) {\n            return traverseKey(entry[0], () => this.value.traverseAllows(entry[1], ctx), ctx);\n        }\n        return true;\n    });\n    traverseApply = (data, ctx) => {\n        for (const entry of stringAndSymbolicEntriesOf(data)) {\n            if (this.signature.traverseAllows(entry[0], ctx)) {\n                traverseKey(entry[0], () => this.value.traverseApply(entry[1], ctx), ctx);\n            }\n        }\n    };\n    _transform(mapper, ctx) {\n        ctx.path.push(this.signature);\n        const result = super._transform(mapper, ctx);\n        ctx.path.pop();\n        return result;\n    }\n    compile() {\n        // this is currently handled by StructureNode\n    }\n}\nexport const Index = {\n    implementation,\n    Node: IndexNode\n};\nexport const writeEnumerableIndexBranches = (keys) => `Index keys ${keys.join(\", \")} should be specified as named props.`;\nexport const writeInvalidPropertyKeyMessage = (indexSchema) => `Indexed key definition '${indexSchema}' must be a string or symbol`;\n", "import { compileObjectLiteral, implementNode } from \"../shared/implement.js\";\nimport { BaseProp, intersectProps } from \"./prop.js\";\nconst implementation = implementNode({\n    kind: \"required\",\n    hasAssociatedError: true,\n    intersectionIsOpen: true,\n    keys: {\n        key: {},\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.parseSchema(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `${node.compiledKey}: ${node.value.description}`,\n        expected: ctx => ctx.missingValueDescription,\n        actual: () => \"missing\"\n    },\n    intersections: {\n        required: intersectProps,\n        optional: intersectProps\n    }\n});\nexport class RequiredNode extends BaseProp {\n    expression = `${this.compiledKey}: ${this.value.expression}`;\n    errorContext = Object.freeze({\n        code: \"required\",\n        missingValueDescription: this.value.defaultShortDescription,\n        relativePath: [this.key],\n        meta: this.meta\n    });\n    compiledErrorContext = compileObjectLiteral(this.errorContext);\n}\nexport const Required = {\n    implementation,\n    Node: RequiredNode\n};\n", "import { append, conflatenate, printable, throwInternalError, throwParseError } from \"@ark/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { appendUniqueFlatRefs, flatRef } from \"../node.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { defaultValueSerializer, implementNode } from \"../shared/implement.js\";\nimport { intersectOrPipeNodes } from \"../shared/intersections.js\";\nimport { $ark, registeredReference } from \"../shared/registry.js\";\nimport { traverseKey } from \"../shared/traversal.js\";\nimport { assertDefaultValueAssignability, computeDefaultValueMorph } from \"./optional.js\";\nimport { writeDefaultIntersectionMessage } from \"./prop.js\";\nconst implementation = implementNode({\n    kind: \"sequence\",\n    hasAssociatedError: false,\n    collapsibleKey: \"variadic\",\n    keys: {\n        prefix: {\n            child: true,\n            parse: (schema, ctx) => {\n                // empty affixes are omitted. an empty array should therefore\n                // be specified as `{ proto: Array, length: 0 }`\n                if (schema.length === 0)\n                    return undefined;\n                return schema.map(element => ctx.$.parseSchema(element));\n            }\n        },\n        optionals: {\n            child: true,\n            parse: (schema, ctx) => {\n                if (schema.length === 0)\n                    return undefined;\n                return schema.map(element => ctx.$.parseSchema(element));\n            }\n        },\n        defaultables: {\n            child: defaultables => defaultables.map(element => element[0]),\n            parse: (defaultables, ctx) => {\n                if (defaultables.length === 0)\n                    return undefined;\n                return defaultables.map(element => {\n                    const node = ctx.$.parseSchema(element[0]);\n                    assertDefaultValueAssignability(node, element[1], null);\n                    return [node, element[1]];\n                });\n            },\n            serialize: defaults => defaults.map(element => [\n                element[0].collapsibleJson,\n                defaultValueSerializer(element[1])\n            ])\n        },\n        variadic: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.parseSchema(schema, ctx)\n        },\n        minVariadicLength: {\n            // minVariadicLength is reflected in the id of this node,\n            // but not its IntersectionNode parent since it is superceded by the minLength\n            // node it implies\n            parse: min => (min === 0 ? undefined : min)\n        },\n        postfix: {\n            child: true,\n            parse: (schema, ctx) => {\n                if (schema.length === 0)\n                    return undefined;\n                return schema.map(element => ctx.$.parseSchema(element));\n            }\n        }\n    },\n    normalize: schema => {\n        if (typeof schema === \"string\")\n            return { variadic: schema };\n        if (\"variadic\" in schema ||\n            \"prefix\" in schema ||\n            \"defaultables\" in schema ||\n            \"optionals\" in schema ||\n            \"postfix\" in schema ||\n            \"minVariadicLength\" in schema) {\n            if (schema.postfix?.length) {\n                if (!schema.variadic)\n                    return throwParseError(postfixWithoutVariadicMessage);\n                if (schema.optionals?.length || schema.defaultables?.length)\n                    return throwParseError(postfixAfterOptionalOrDefaultableMessage);\n            }\n            if (schema.minVariadicLength && !schema.variadic) {\n                return throwParseError(\"minVariadicLength may not be specified without a variadic element\");\n            }\n            return schema;\n        }\n        return { variadic: schema };\n    },\n    reduce: (raw, $) => {\n        let minVariadicLength = raw.minVariadicLength ?? 0;\n        const prefix = raw.prefix?.slice() ?? [];\n        const defaultables = raw.defaultables?.slice() ?? [];\n        const optionals = raw.optionals?.slice() ?? [];\n        const postfix = raw.postfix?.slice() ?? [];\n        if (raw.variadic) {\n            // optional elements equivalent to the variadic parameter are redundant\n            while (optionals.at(-1)?.equals(raw.variadic))\n                optionals.pop();\n            if (optionals.length === 0 && defaultables.length === 0) {\n                // If there are no optional, normalize prefix\n                // elements adjacent and equivalent to variadic:\n                // \t\t{ variadic: number, prefix: [string, number] }\n                // reduces to:\n                // \t\t{ variadic: number, prefix: [string], minVariadicLength: 1 }\n                while (prefix.at(-1)?.equals(raw.variadic)) {\n                    prefix.pop();\n                    minVariadicLength++;\n                }\n            }\n            // Normalize postfix elements adjacent and equivalent to variadic:\n            // \t\t{ variadic: number, postfix: [number, number, 5] }\n            // reduces to:\n            // \t\t{ variadic: number, postfix: [5], minVariadicLength: 2 }\n            while (postfix[0]?.equals(raw.variadic)) {\n                postfix.shift();\n                minVariadicLength++;\n            }\n        }\n        else if (optionals.length === 0 && defaultables.length === 0) {\n            // if there's no variadic, optional or defaultable elements,\n            // postfix can just be appended to prefix\n            prefix.push(...postfix.splice(0));\n        }\n        if (\n        // if any variadic adjacent elements were moved to minVariadicLength\n        minVariadicLength !== raw.minVariadicLength ||\n            // or any postfix elements were moved to prefix\n            (raw.prefix && raw.prefix.length !== prefix.length)) {\n            // reparse the reduced def\n            return $.node(\"sequence\", {\n                ...raw,\n                // empty lists will be omitted during parsing\n                prefix,\n                defaultables,\n                optionals,\n                postfix,\n                minVariadicLength\n            }, { prereduced: true });\n        }\n    },\n    defaults: {\n        description: node => {\n            if (node.isVariadicOnly)\n                return `${node.variadic.nestableExpression}[]`;\n            const innerDescription = node.tuple\n                .map(element => element.kind === \"defaultables\" ?\n                `${element.node.nestableExpression} = ${printable(element.default)}`\n                : element.kind === \"optionals\" ?\n                    `${element.node.nestableExpression}?`\n                    : element.kind === \"variadic\" ?\n                        `...${element.node.nestableExpression}[]`\n                        : element.node.expression)\n                .join(\", \");\n            return `[${innerDescription}]`;\n        }\n    },\n    intersections: {\n        sequence: (l, r, ctx) => {\n            const rootState = _intersectSequences({\n                l: l.tuple,\n                r: r.tuple,\n                disjoint: new Disjoint(),\n                result: [],\n                fixedVariants: [],\n                ctx\n            });\n            const viableBranches = rootState.disjoint.length === 0 ?\n                [rootState, ...rootState.fixedVariants]\n                : rootState.fixedVariants;\n            return (viableBranches.length === 0 ? rootState.disjoint\n                : viableBranches.length === 1 ?\n                    ctx.$.node(\"sequence\", sequenceTupleToInner(viableBranches[0].result))\n                    : ctx.$.node(\"union\", viableBranches.map(state => ({\n                        proto: Array,\n                        sequence: sequenceTupleToInner(state.result)\n                    }))));\n        }\n        // exactLength, minLength, and maxLength don't need to be defined\n        // here since impliedSiblings guarantees they will be added\n        // directly to the IntersectionNode parent of the SequenceNode\n        // they exist on\n    }\n});\nexport class SequenceNode extends BaseConstraint {\n    impliedBasis = $ark.intrinsic.Array.internal;\n    tuple = sequenceInnerToTuple(this.inner);\n    prefixLength = this.prefix?.length ?? 0;\n    defaultablesLength = this.defaultables?.length ?? 0;\n    optionalsLength = this.optionals?.length ?? 0;\n    postfixLength = this.postfix?.length ?? 0;\n    defaultablesAndOptionals = [];\n    prevariadic = this.tuple.filter((el) => {\n        if (el.kind === \"defaultables\" || el.kind === \"optionals\") {\n            // populate defaultablesAndOptionals while filtering prevariadic\n            this.defaultablesAndOptionals.push(el.node);\n            return true;\n        }\n        return el.kind === \"prefix\";\n    });\n    variadicOrPostfix = conflatenate(this.variadic && [this.variadic], this.postfix);\n    // have to wait until prevariadic and variadicOrPostfix are set to calculate\n    flatRefs = this.addFlatRefs();\n    addFlatRefs() {\n        appendUniqueFlatRefs(this.flatRefs, this.prevariadic.flatMap((element, i) => append(element.node.flatRefs.map(ref => flatRef([`${i}`, ...ref.path], ref.node)), flatRef([`${i}`], element.node))));\n        appendUniqueFlatRefs(this.flatRefs, this.variadicOrPostfix.flatMap(element => \n        // a postfix index can't be directly represented as a type\n        // key, so we just use the same matcher for variadic\n        append(element.flatRefs.map(ref => flatRef([$ark.intrinsic.nonNegativeIntegerString.internal, ...ref.path], ref.node)), flatRef([$ark.intrinsic.nonNegativeIntegerString.internal], element))));\n        return this.flatRefs;\n    }\n    isVariadicOnly = this.prevariadic.length + this.postfixLength === 0;\n    minVariadicLength = this.inner.minVariadicLength ?? 0;\n    minLength = this.prefixLength + this.minVariadicLength + this.postfixLength;\n    minLengthNode = this.minLength === 0 ?\n        null\n        // cast is safe here as the only time this would not be a\n        // MinLengthNode would be when minLength is 0\n        : this.$.node(\"minLength\", this.minLength);\n    maxLength = this.variadic ? null : this.tuple.length;\n    maxLengthNode = this.maxLength === null ? null : this.$.node(\"maxLength\", this.maxLength);\n    impliedSiblings = this.minLengthNode ?\n        this.maxLengthNode ?\n            [this.minLengthNode, this.maxLengthNode]\n            : [this.minLengthNode]\n        : this.maxLengthNode ? [this.maxLengthNode]\n            : [];\n    defaultValueMorphs = getDefaultableMorphs(this);\n    defaultValueMorphsReference = this.defaultValueMorphs.length ?\n        registeredReference(this.defaultValueMorphs)\n        : undefined;\n    elementAtIndex(data, index) {\n        if (index < this.prevariadic.length)\n            return this.tuple[index];\n        const firstPostfixIndex = data.length - this.postfixLength;\n        if (index >= firstPostfixIndex)\n            return { kind: \"postfix\", node: this.postfix[index - firstPostfixIndex] };\n        return {\n            kind: \"variadic\",\n            node: this.variadic ??\n                throwInternalError(`Unexpected attempt to access index ${index} on ${this}`)\n        };\n    }\n    // minLength/maxLength should be checked by Intersection before either traversal\n    traverseAllows = (data, ctx) => {\n        for (let i = 0; i < data.length; i++) {\n            if (!this.elementAtIndex(data, i).node.traverseAllows(data[i], ctx))\n                return false;\n        }\n        return true;\n    };\n    traverseApply = (data, ctx) => {\n        let i = 0;\n        for (; i < data.length; i++) {\n            traverseKey(i, () => this.elementAtIndex(data, i).node.traverseApply(data[i], ctx), ctx);\n        }\n    };\n    get element() {\n        return this.cacheGetter(\"element\", this.$.node(\"union\", this.children));\n    }\n    // minLength/maxLength compilation should be handled by Intersection\n    compile(js) {\n        if (this.prefix) {\n            for (const [i, node] of this.prefix.entries())\n                js.traverseKey(`${i}`, `data[${i}]`, node);\n        }\n        for (const [i, node] of this.defaultablesAndOptionals.entries()) {\n            const dataIndex = `${i + this.prefixLength}`;\n            js.if(`${dataIndex} >= ${js.data}.length`, () => js.traversalKind === \"Allows\" ? js.return(true) : js.return());\n            js.traverseKey(dataIndex, `data[${dataIndex}]`, node);\n        }\n        if (this.variadic) {\n            if (this.postfix) {\n                js.const(\"firstPostfixIndex\", `${js.data}.length${this.postfix ? `- ${this.postfix.length}` : \"\"}`);\n            }\n            js.for(`i < ${this.postfix ? \"firstPostfixIndex\" : \"data.length\"}`, () => js.traverseKey(\"i\", \"data[i]\", this.variadic), this.prevariadic.length);\n            if (this.postfix) {\n                for (const [i, node] of this.postfix.entries()) {\n                    const keyExpression = `firstPostfixIndex + ${i}`;\n                    js.traverseKey(keyExpression, `data[${keyExpression}]`, node);\n                }\n            }\n        }\n        if (js.traversalKind === \"Allows\")\n            js.return(true);\n    }\n    _transform(mapper, ctx) {\n        ctx.path.push($ark.intrinsic.nonNegativeIntegerString.internal);\n        const result = super._transform(mapper, ctx);\n        ctx.path.pop();\n        return result;\n    }\n    // this depends on tuple so needs to come after it\n    expression = this.description;\n    reduceJsonSchema(schema, ctx) {\n        if (this.prevariadic.length) {\n            schema.prefixItems = this.prevariadic.map(el => {\n                const valueSchema = el.node.toJsonSchemaRecurse(ctx);\n                if (el.kind === \"defaultables\") {\n                    const value = typeof el.default === \"function\" ? el.default() : el.default;\n                    valueSchema.default =\n                        $ark.intrinsic.jsonData.allows(value) ?\n                            value\n                            : ctx.fallback.defaultValue({\n                                code: \"defaultValue\",\n                                base: valueSchema,\n                                value\n                            });\n                }\n                return valueSchema;\n            });\n        }\n        // by default JSON schema prefixElements are optional\n        // add minLength here if there are any required prefix elements\n        if (this.minLength)\n            schema.minItems = this.minLength;\n        if (this.variadic) {\n            // alias schema for narrowing (Object.assign mutates anyways)\n            const variadicSchema = Object.assign(schema, {\n                items: this.variadic.toJsonSchemaRecurse(ctx)\n            });\n            // maxLength constraint will be enforced by items: false\n            // for non-variadic arrays\n            if (this.maxLength)\n                variadicSchema.maxItems = this.maxLength;\n            // postfix can only be present if variadic is present so nesting this is fine\n            if (this.postfix) {\n                const elements = this.postfix.map(el => el.toJsonSchemaRecurse(ctx));\n                schema = ctx.fallback.arrayPostfix({\n                    code: \"arrayPostfix\",\n                    base: variadicSchema,\n                    elements\n                });\n            }\n        }\n        else {\n            schema.items = false;\n            // delete maxItems constraint that will have been added by the\n            // base intersection node to enforce fixed length\n            delete schema.maxItems;\n        }\n        return schema;\n    }\n}\nconst defaultableMorphsCache = {};\nconst getDefaultableMorphs = (node) => {\n    if (!node.defaultables)\n        return [];\n    const morphs = [];\n    let cacheKey = \"[\";\n    const lastDefaultableIndex = node.prefixLength + node.defaultablesLength - 1;\n    for (let i = node.prefixLength; i <= lastDefaultableIndex; i++) {\n        const [elementNode, defaultValue] = node.defaultables[i - node.prefixLength];\n        morphs.push(computeDefaultValueMorph(i, elementNode, defaultValue));\n        cacheKey += `${i}: ${elementNode.id} = ${defaultValueSerializer(defaultValue)}, `;\n    }\n    cacheKey += \"]\";\n    return (defaultableMorphsCache[cacheKey] ??= morphs);\n};\nexport const Sequence = {\n    implementation,\n    Node: SequenceNode\n};\nconst sequenceInnerToTuple = (inner) => {\n    const tuple = [];\n    if (inner.prefix)\n        for (const node of inner.prefix)\n            tuple.push({ kind: \"prefix\", node });\n    if (inner.defaultables) {\n        for (const [node, defaultValue] of inner.defaultables)\n            tuple.push({ kind: \"defaultables\", node, default: defaultValue });\n    }\n    if (inner.optionals)\n        for (const node of inner.optionals)\n            tuple.push({ kind: \"optionals\", node });\n    if (inner.variadic)\n        tuple.push({ kind: \"variadic\", node: inner.variadic });\n    if (inner.postfix)\n        for (const node of inner.postfix)\n            tuple.push({ kind: \"postfix\", node });\n    return tuple;\n};\nconst sequenceTupleToInner = (tuple) => tuple.reduce((result, element) => {\n    if (element.kind === \"variadic\")\n        result.variadic = element.node;\n    else if (element.kind === \"defaultables\") {\n        result.defaultables = append(result.defaultables, [\n            [element.node, element.default]\n        ]);\n    }\n    else\n        result[element.kind] = append(result[element.kind], element.node);\n    return result;\n}, {});\nexport const postfixAfterOptionalOrDefaultableMessage = \"A postfix required element cannot follow an optional or defaultable element\";\nexport const postfixWithoutVariadicMessage = \"A postfix element requires a variadic element\";\nconst _intersectSequences = (s) => {\n    const [lHead, ...lTail] = s.l;\n    const [rHead, ...rTail] = s.r;\n    if (!lHead || !rHead)\n        return s;\n    const lHasPostfix = lTail.at(-1)?.kind === \"postfix\";\n    const rHasPostfix = rTail.at(-1)?.kind === \"postfix\";\n    const kind = lHead.kind === \"prefix\" || rHead.kind === \"prefix\" ? \"prefix\"\n        : lHead.kind === \"postfix\" || rHead.kind === \"postfix\" ? \"postfix\"\n            : lHead.kind === \"variadic\" && rHead.kind === \"variadic\" ? \"variadic\"\n                // if either operand has postfix elements, the full-length\n                // intersection can't include optional elements (though they may\n                // exist in some of the fixed length variants)\n                : lHasPostfix || rHasPostfix ? \"prefix\"\n                    : lHead.kind === \"defaultables\" || rHead.kind === \"defaultables\" ?\n                        \"defaultables\"\n                        : \"optionals\";\n    if (lHead.kind === \"prefix\" && rHead.kind === \"variadic\" && rHasPostfix) {\n        const postfixBranchResult = _intersectSequences({\n            ...s,\n            fixedVariants: [],\n            r: rTail.map(element => ({ ...element, kind: \"prefix\" }))\n        });\n        if (postfixBranchResult.disjoint.length === 0)\n            s.fixedVariants.push(postfixBranchResult);\n    }\n    else if (rHead.kind === \"prefix\" &&\n        lHead.kind === \"variadic\" &&\n        lHasPostfix) {\n        const postfixBranchResult = _intersectSequences({\n            ...s,\n            fixedVariants: [],\n            l: lTail.map(element => ({ ...element, kind: \"prefix\" }))\n        });\n        if (postfixBranchResult.disjoint.length === 0)\n            s.fixedVariants.push(postfixBranchResult);\n    }\n    const result = intersectOrPipeNodes(lHead.node, rHead.node, s.ctx);\n    if (result instanceof Disjoint) {\n        if (kind === \"prefix\" || kind === \"postfix\") {\n            s.disjoint.push(...result.withPrefixKey(\n            // ideally we could handle disjoint paths more precisely here,\n            // but not trivial to serialize postfix elements as keys\n            kind === \"prefix\" ? s.result.length : `-${lTail.length + 1}`, \"required\"));\n            s.result = [...s.result, { kind, node: $ark.intrinsic.never.internal }];\n        }\n        else if (kind === \"optionals\" || kind === \"defaultables\") {\n            // if the element result is optional and unsatisfiable, the\n            // intersection can still be satisfied as long as the tuple\n            // ends before the disjoint element would occur\n            return s;\n        }\n        else {\n            // if the element is variadic and unsatisfiable, the intersection\n            // can be satisfied with a fixed length variant including zero\n            // variadic elements\n            return _intersectSequences({\n                ...s,\n                fixedVariants: [],\n                // if there were any optional elements, there will be no postfix elements\n                // so this mapping will never occur (which would be illegal otherwise)\n                l: lTail.map(element => ({ ...element, kind: \"prefix\" })),\n                r: lTail.map(element => ({ ...element, kind: \"prefix\" }))\n            });\n        }\n    }\n    else if (kind === \"defaultables\") {\n        if (lHead.kind === \"defaultables\" &&\n            rHead.kind === \"defaultables\" &&\n            lHead.default !== rHead.default) {\n            throwParseError(writeDefaultIntersectionMessage(lHead.default, rHead.default));\n        }\n        s.result = [\n            ...s.result,\n            {\n                kind,\n                node: result,\n                default: lHead.kind === \"defaultables\" ? lHead.default\n                    : rHead.kind === \"defaultables\" ? rHead.default\n                        : throwInternalError(`Unexpected defaultable intersection from ${lHead.kind} and ${rHead.kind} elements.`)\n            }\n        ];\n    }\n    else\n        s.result = [...s.result, { kind, node: result }];\n    const lRemaining = s.l.length;\n    const rRemaining = s.r.length;\n    if (lHead.kind !== \"variadic\" ||\n        (lRemaining >= rRemaining &&\n            (rHead.kind === \"variadic\" || rRemaining === 1)))\n        s.l = lTail;\n    if (rHead.kind !== \"variadic\" ||\n        (rRemaining >= lRemaining &&\n            (lHead.kind === \"variadic\" || lRemaining === 1)))\n        s.r = rTail;\n    return _intersectSequences(s);\n};\n", "import { append, conflatenate, flatMorph, printable, spliterate, throwInternalError, throwParseError } from \"@ark/util\";\nimport { BaseConstraint, constraintKeyParser, flattenConstraints, intersectConstraints } from \"../constraint.js\";\nimport { intrinsic } from \"../intrinsic.js\";\nimport { typeOrTermExtends } from \"../roots/root.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodesRoot } from \"../shared/intersections.js\";\nimport { $ark, registeredReference } from \"../shared/registry.js\";\nimport { ToJsonSchema } from \"../shared/toJsonSchema.js\";\nimport { traverseKey } from \"../shared/traversal.js\";\nimport { hasArkKind, isNode, makeRootAndArrayPropertiesMutable } from \"../shared/utils.js\";\nimport { Optional } from \"./optional.js\";\nconst createStructuralWriter = (childStringProp) => (node) => {\n    if (node.props.length || node.index) {\n        const parts = node.index?.map(index => index[childStringProp]) ?? [];\n        for (const prop of node.props)\n            parts.push(prop[childStringProp]);\n        if (node.undeclared)\n            parts.push(`+ (undeclared): ${node.undeclared}`);\n        const objectLiteralDescription = `{ ${parts.join(\", \")} }`;\n        return node.sequence ?\n            `${objectLiteralDescription} & ${node.sequence.description}`\n            : objectLiteralDescription;\n    }\n    return node.sequence?.description ?? \"{}\";\n};\nconst structuralDescription = createStructuralWriter(\"description\");\nconst structuralExpression = createStructuralWriter(\"expression\");\nconst intersectPropsAndIndex = (l, r, $) => {\n    const kind = l.required ? \"required\" : \"optional\";\n    if (!r.signature.allows(l.key))\n        return null;\n    const value = intersectNodesRoot(l.value, r.value, $);\n    if (value instanceof Disjoint) {\n        return kind === \"optional\" ?\n            $.node(\"optional\", {\n                key: l.key,\n                value: $ark.intrinsic.never.internal\n            })\n            : value.withPrefixKey(l.key, l.kind);\n    }\n    return null;\n};\nconst implementation = implementNode({\n    kind: \"structure\",\n    hasAssociatedError: false,\n    normalize: schema => schema,\n    applyConfig: (schema, config) => {\n        if (!schema.undeclared && config.onUndeclaredKey !== \"ignore\") {\n            return {\n                ...schema,\n                undeclared: config.onUndeclaredKey\n            };\n        }\n        return schema;\n    },\n    keys: {\n        required: {\n            child: true,\n            parse: constraintKeyParser(\"required\"),\n            reduceIo: (ioKind, inner, nodes) => {\n                // ensure we don't overwrite nodes added by optional\n                inner.required = append(inner.required, nodes.map(node => node[ioKind]));\n                return;\n            }\n        },\n        optional: {\n            child: true,\n            parse: constraintKeyParser(\"optional\"),\n            reduceIo: (ioKind, inner, nodes) => {\n                if (ioKind === \"in\") {\n                    inner.optional = nodes.map(node => node.in);\n                    return;\n                }\n                for (const node of nodes) {\n                    inner[node.outProp.kind] = append(inner[node.outProp.kind], node.outProp.out);\n                }\n            }\n        },\n        index: {\n            child: true,\n            parse: constraintKeyParser(\"index\")\n        },\n        sequence: {\n            child: true,\n            parse: constraintKeyParser(\"sequence\")\n        },\n        undeclared: {\n            parse: behavior => (behavior === \"ignore\" ? undefined : behavior),\n            reduceIo: (ioKind, inner, value) => {\n                if (value !== \"delete\")\n                    return;\n                // if base is \"delete\", undeclared keys are \"ignore\" (i.e. unconstrained)\n                // on input and \"reject\" on output\n                if (ioKind === \"in\")\n                    delete inner.undeclared;\n                else\n                    inner.undeclared = \"reject\";\n            }\n        }\n    },\n    defaults: {\n        description: structuralDescription\n    },\n    intersections: {\n        structure: (l, r, ctx) => {\n            const lInner = { ...l.inner };\n            const rInner = { ...r.inner };\n            const disjointResult = new Disjoint();\n            if (l.undeclared) {\n                const lKey = l.keyof();\n                for (const k of r.requiredKeys) {\n                    if (!lKey.allows(k)) {\n                        disjointResult.add(\"presence\", $ark.intrinsic.never.internal, r.propsByKey[k].value, {\n                            path: [k]\n                        });\n                    }\n                }\n                if (rInner.optional)\n                    rInner.optional = rInner.optional.filter(n => lKey.allows(n.key));\n                if (rInner.index) {\n                    rInner.index = rInner.index.flatMap(n => {\n                        if (n.signature.extends(lKey))\n                            return n;\n                        const indexOverlap = intersectNodesRoot(lKey, n.signature, ctx.$);\n                        if (indexOverlap instanceof Disjoint)\n                            return [];\n                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);\n                        if (normalized.required) {\n                            rInner.required = conflatenate(rInner.required, normalized.required);\n                        }\n                        if (normalized.optional) {\n                            rInner.optional = conflatenate(rInner.optional, normalized.optional);\n                        }\n                        return normalized.index ?? [];\n                    });\n                }\n            }\n            if (r.undeclared) {\n                const rKey = r.keyof();\n                for (const k of l.requiredKeys) {\n                    if (!rKey.allows(k)) {\n                        disjointResult.add(\"presence\", l.propsByKey[k].value, $ark.intrinsic.never.internal, {\n                            path: [k]\n                        });\n                    }\n                }\n                if (lInner.optional)\n                    lInner.optional = lInner.optional.filter(n => rKey.allows(n.key));\n                if (lInner.index) {\n                    lInner.index = lInner.index.flatMap(n => {\n                        if (n.signature.extends(rKey))\n                            return n;\n                        const indexOverlap = intersectNodesRoot(rKey, n.signature, ctx.$);\n                        if (indexOverlap instanceof Disjoint)\n                            return [];\n                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);\n                        if (normalized.required) {\n                            lInner.required = conflatenate(lInner.required, normalized.required);\n                        }\n                        if (normalized.optional) {\n                            lInner.optional = conflatenate(lInner.optional, normalized.optional);\n                        }\n                        return normalized.index ?? [];\n                    });\n                }\n            }\n            const baseInner = {};\n            if (l.undeclared || r.undeclared) {\n                baseInner.undeclared =\n                    l.undeclared === \"reject\" || r.undeclared === \"reject\" ?\n                        \"reject\"\n                        : \"delete\";\n            }\n            const childIntersectionResult = intersectConstraints({\n                kind: \"structure\",\n                baseInner,\n                l: flattenConstraints(lInner),\n                r: flattenConstraints(rInner),\n                roots: [],\n                ctx\n            });\n            if (childIntersectionResult instanceof Disjoint)\n                disjointResult.push(...childIntersectionResult);\n            if (disjointResult.length)\n                return disjointResult;\n            return childIntersectionResult;\n        }\n    },\n    reduce: (inner, $) => {\n        if (inner.index) {\n            if (!(inner.required || inner.optional))\n                return;\n            let updated = false;\n            const requiredProps = inner.required ?? [];\n            const optionalProps = inner.optional ?? [];\n            const newOptionalProps = [...optionalProps];\n            for (const index of inner.index) {\n                for (const requiredProp of requiredProps) {\n                    const intersection = intersectPropsAndIndex(requiredProp, index, $);\n                    if (intersection instanceof Disjoint)\n                        return intersection;\n                }\n                for (const [indx, optionalProp] of optionalProps.entries()) {\n                    const intersection = intersectPropsAndIndex(optionalProp, index, $);\n                    if (intersection instanceof Disjoint)\n                        return intersection;\n                    if (intersection === null)\n                        continue;\n                    newOptionalProps[indx] = intersection;\n                    updated = true;\n                }\n            }\n            if (updated) {\n                return $.node(\"structure\", { ...inner, optional: newOptionalProps }, { prereduced: true });\n            }\n        }\n    }\n});\nexport class StructureNode extends BaseConstraint {\n    impliedBasis = $ark.intrinsic.object.internal;\n    impliedSiblings = this.children.flatMap(n => n.impliedSiblings ?? []);\n    props = conflatenate(this.required, this.optional);\n    propsByKey = flatMorph(this.props, (i, node) => [node.key, node]);\n    propsByKeyReference = registeredReference(this.propsByKey);\n    expression = structuralExpression(this);\n    requiredKeys = this.required?.map(node => node.key) ?? [];\n    optionalKeys = this.optional?.map(node => node.key) ?? [];\n    literalKeys = [...this.requiredKeys, ...this.optionalKeys];\n    _keyof;\n    keyof() {\n        if (this._keyof)\n            return this._keyof;\n        let branches = this.$.units(this.literalKeys).branches;\n        if (this.index) {\n            for (const { signature } of this.index)\n                branches = branches.concat(signature.branches);\n        }\n        return (this._keyof = this.$.node(\"union\", branches));\n    }\n    map(flatMapProp) {\n        return this.$.node(\"structure\", this.props\n            .flatMap(flatMapProp)\n            .reduce((structureInner, mapped) => {\n            const originalProp = this.propsByKey[mapped.key];\n            if (isNode(mapped)) {\n                if (mapped.kind !== \"required\" && mapped.kind !== \"optional\") {\n                    return throwParseError(`Map result must have kind \"required\" or \"optional\" (was ${mapped.kind})`);\n                }\n                structureInner[mapped.kind] = append(structureInner[mapped.kind], mapped);\n                return structureInner;\n            }\n            const mappedKind = mapped.kind ?? originalProp?.kind ?? \"required\";\n            // extract the inner keys from the map result in case a node was spread,\n            // which would otherwise lead to invalid keys\n            const mappedPropInner = flatMorph(mapped, (k, v) => (k in Optional.implementation.keys ? [k, v] : []));\n            structureInner[mappedKind] = append(structureInner[mappedKind], this.$.node(mappedKind, mappedPropInner));\n            return structureInner;\n        }, {}));\n    }\n    assertHasKeys(keys) {\n        const invalidKeys = keys.filter(k => !typeOrTermExtends(k, this.keyof()));\n        if (invalidKeys.length) {\n            return throwParseError(writeInvalidKeysMessage(this.expression, invalidKeys));\n        }\n    }\n    get(indexer, ...path) {\n        let value;\n        let required = false;\n        const key = indexerToKey(indexer);\n        if ((typeof key === \"string\" || typeof key === \"symbol\") &&\n            this.propsByKey[key]) {\n            value = this.propsByKey[key].value;\n            required = this.propsByKey[key].required;\n        }\n        if (this.index) {\n            for (const n of this.index) {\n                if (typeOrTermExtends(key, n.signature))\n                    value = value?.and(n.value) ?? n.value;\n            }\n        }\n        if (this.sequence &&\n            typeOrTermExtends(key, $ark.intrinsic.nonNegativeIntegerString)) {\n            if (hasArkKind(key, \"root\")) {\n                if (this.sequence.variadic)\n                    // if there is a variadic element and we're accessing an index, return a union\n                    // of all possible elements. If there is no variadic expression, we're in a tuple\n                    // so this access wouldn't be safe based on the array indices\n                    value = value?.and(this.sequence.element) ?? this.sequence.element;\n            }\n            else {\n                const index = Number.parseInt(key);\n                if (index < this.sequence.prevariadic.length) {\n                    const fixedElement = this.sequence.prevariadic[index].node;\n                    value = value?.and(fixedElement) ?? fixedElement;\n                    required ||= index < this.sequence.prefixLength;\n                }\n                else if (this.sequence.variadic) {\n                    // ideally we could return something more specific for postfix\n                    // but there is no way to represent it using an index alone\n                    const nonFixedElement = this.$.node(\"union\", this.sequence.variadicOrPostfix);\n                    value = value?.and(nonFixedElement) ?? nonFixedElement;\n                }\n            }\n        }\n        if (!value) {\n            if (this.sequence?.variadic &&\n                hasArkKind(key, \"root\") &&\n                key.extends($ark.intrinsic.number)) {\n                return throwParseError(writeNumberIndexMessage(key.expression, this.sequence.expression));\n            }\n            return throwParseError(writeInvalidKeysMessage(this.expression, [key]));\n        }\n        const result = value.get(...path);\n        return required ? result : result.or($ark.intrinsic.undefined);\n    }\n    pick(...keys) {\n        this.assertHasKeys(keys);\n        return this.$.node(\"structure\", this.filterKeys(\"pick\", keys));\n    }\n    omit(...keys) {\n        this.assertHasKeys(keys);\n        return this.$.node(\"structure\", this.filterKeys(\"omit\", keys));\n    }\n    optionalize() {\n        const { required, ...inner } = this.inner;\n        return this.$.node(\"structure\", {\n            ...inner,\n            optional: this.props.map(prop => prop.hasKind(\"required\") ? this.$.node(\"optional\", prop.inner) : prop)\n        });\n    }\n    require() {\n        const { optional, ...inner } = this.inner;\n        return this.$.node(\"structure\", {\n            ...inner,\n            required: this.props.map(prop => prop.hasKind(\"optional\") ?\n                {\n                    key: prop.key,\n                    value: prop.value\n                }\n                : prop)\n        });\n    }\n    merge(r) {\n        const inner = this.filterKeys(\"omit\", [r.keyof()]);\n        if (r.required)\n            inner.required = append(inner.required, r.required);\n        if (r.optional)\n            inner.optional = append(inner.optional, r.optional);\n        if (r.index)\n            inner.index = append(inner.index, r.index);\n        if (r.sequence)\n            inner.sequence = r.sequence;\n        if (r.undeclared)\n            inner.undeclared = r.undeclared;\n        else\n            delete inner.undeclared;\n        return this.$.node(\"structure\", inner);\n    }\n    filterKeys(operation, keys) {\n        const result = makeRootAndArrayPropertiesMutable(this.inner);\n        const shouldKeep = (key) => {\n            const matchesKey = keys.some(k => typeOrTermExtends(key, k));\n            return operation === \"pick\" ? matchesKey : !matchesKey;\n        };\n        if (result.required)\n            result.required = result.required.filter(prop => shouldKeep(prop.key));\n        if (result.optional)\n            result.optional = result.optional.filter(prop => shouldKeep(prop.key));\n        if (result.index)\n            result.index = result.index.filter(index => shouldKeep(index.signature));\n        return result;\n    }\n    traverseAllows = (data, ctx) => this._traverse(\"Allows\", data, ctx);\n    traverseApply = (data, ctx) => this._traverse(\"Apply\", data, ctx);\n    _traverse = (traversalKind, data, ctx) => {\n        const errorCount = ctx?.currentErrorCount ?? 0;\n        for (let i = 0; i < this.props.length; i++) {\n            if (traversalKind === \"Allows\") {\n                if (!this.props[i].traverseAllows(data, ctx))\n                    return false;\n            }\n            else {\n                this.props[i].traverseApply(data, ctx);\n                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                    return false;\n            }\n        }\n        if (this.sequence) {\n            if (traversalKind === \"Allows\") {\n                if (!this.sequence.traverseAllows(data, ctx))\n                    return false;\n            }\n            else {\n                this.sequence.traverseApply(data, ctx);\n                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                    return false;\n            }\n        }\n        if (this.index || this.undeclared === \"reject\") {\n            const keys = Object.keys(data);\n            keys.push(...Object.getOwnPropertySymbols(data));\n            for (let i = 0; i < keys.length; i++) {\n                const k = keys[i];\n                if (this.index) {\n                    for (const node of this.index) {\n                        if (node.signature.traverseAllows(k, ctx)) {\n                            if (traversalKind === \"Allows\") {\n                                const result = traverseKey(k, () => node.value.traverseAllows(data[k], ctx), ctx);\n                                if (!result)\n                                    return false;\n                            }\n                            else {\n                                traverseKey(k, () => node.value.traverseApply(data[k], ctx), ctx);\n                                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                                    return false;\n                            }\n                        }\n                    }\n                }\n                if (this.undeclared === \"reject\" && !this.declaresKey(k)) {\n                    if (traversalKind === \"Allows\")\n                        return false;\n                    // this should have its own error code:\n                    // https://github.com/arktypeio/arktype/issues/1403\n                    ctx.errorFromNodeContext({\n                        code: \"predicate\",\n                        expected: \"removed\",\n                        actual: \"\",\n                        relativePath: [k],\n                        meta: this.meta\n                    });\n                    if (ctx.failFast)\n                        return false;\n                }\n            }\n        }\n        // added additional ctx check here to address\n        // https://github.com/arktypeio/arktype/issues/1346\n        if (this.structuralMorph && ctx && !ctx.hasError())\n            ctx.queueMorphs([this.structuralMorph]);\n        return true;\n    };\n    get defaultable() {\n        return this.cacheGetter(\"defaultable\", this.optional?.filter(o => o.hasDefault()) ?? []);\n    }\n    declaresKey = (k) => k in this.propsByKey ||\n        this.index?.some(n => n.signature.allows(k)) ||\n        (this.sequence !== undefined &&\n            $ark.intrinsic.nonNegativeIntegerString.allows(k));\n    _compileDeclaresKey(js) {\n        const parts = [];\n        if (this.props.length)\n            parts.push(`k in ${this.propsByKeyReference}`);\n        if (this.index) {\n            for (const index of this.index)\n                parts.push(js.invoke(index.signature, { kind: \"Allows\", arg: \"k\" }));\n        }\n        if (this.sequence)\n            parts.push(\"$ark.intrinsic.nonNegativeIntegerString.allows(k)\");\n        // if parts is empty, this is a structure like { \"+\": \"reject\" }\n        // that declares no keys, so return false\n        return parts.join(\" || \") || \"false\";\n    }\n    get structuralMorph() {\n        return this.cacheGetter(\"structuralMorph\", getPossibleMorph(this));\n    }\n    structuralMorphRef = this.structuralMorph && registeredReference(this.structuralMorph);\n    compile(js) {\n        if (js.traversalKind === \"Apply\")\n            js.initializeErrorCount();\n        for (const prop of this.props) {\n            js.check(prop);\n            if (js.traversalKind === \"Apply\")\n                js.returnIfFailFast();\n        }\n        if (this.sequence) {\n            js.check(this.sequence);\n            if (js.traversalKind === \"Apply\")\n                js.returnIfFailFast();\n        }\n        if (this.index || this.undeclared === \"reject\") {\n            js.const(\"keys\", \"Object.keys(data)\");\n            js.line(\"keys.push(...Object.getOwnPropertySymbols(data))\");\n            js.for(\"i < keys.length\", () => this.compileExhaustiveEntry(js));\n        }\n        if (js.traversalKind === \"Allows\")\n            return js.return(true);\n        // always queue deleteUndeclared on valid traversal for \"delete\"\n        if (this.structuralMorphRef) {\n            // added additional ctx check here to address\n            // https://github.com/arktypeio/arktype/issues/1346\n            js.if(\"ctx && !ctx.hasError()\", () => {\n                js.line(`ctx.queueMorphs([`);\n                precompileMorphs(js, this);\n                return js.line(\"])\");\n            });\n        }\n    }\n    compileExhaustiveEntry(js) {\n        js.const(\"k\", \"keys[i]\");\n        if (this.index) {\n            for (const node of this.index) {\n                js.if(`${js.invoke(node.signature, { arg: \"k\", kind: \"Allows\" })}`, () => js.traverseKey(\"k\", \"data[k]\", node.value));\n            }\n        }\n        if (this.undeclared === \"reject\") {\n            js.if(`!(${this._compileDeclaresKey(js)})`, () => {\n                if (js.traversalKind === \"Allows\")\n                    return js.return(false);\n                return js\n                    .line(`ctx.errorFromNodeContext({ code: \"predicate\", expected: \"removed\", actual: \"\", relativePath: [k], meta: ${this.compiledMeta} })`)\n                    .if(\"ctx.failFast\", () => js.return());\n            });\n        }\n        return js;\n    }\n    reduceJsonSchema(schema, ctx) {\n        switch (schema.type) {\n            case \"object\":\n                return this.reduceObjectJsonSchema(schema, ctx);\n            case \"array\":\n                const arraySchema = this.sequence?.reduceJsonSchema(schema, ctx) ?? schema;\n                if (this.props.length || this.index) {\n                    return ctx.fallback.arrayObject({\n                        code: \"arrayObject\",\n                        base: arraySchema,\n                        object: this.reduceObjectJsonSchema({ type: \"object\" }, ctx)\n                    });\n                }\n                return arraySchema;\n            default:\n                return ToJsonSchema.throwInternalOperandError(\"structure\", schema);\n        }\n    }\n    reduceObjectJsonSchema(schema, ctx) {\n        if (this.props.length) {\n            schema.properties = {};\n            for (const prop of this.props) {\n                const valueSchema = prop.value.toJsonSchemaRecurse(ctx);\n                if (typeof prop.key === \"symbol\") {\n                    ctx.fallback.symbolKey({\n                        code: \"symbolKey\",\n                        base: schema,\n                        key: prop.key,\n                        value: valueSchema,\n                        optional: prop.optional\n                    });\n                    continue;\n                }\n                if (prop.hasDefault()) {\n                    const value = typeof prop.default === \"function\" ? prop.default() : prop.default;\n                    valueSchema.default =\n                        $ark.intrinsic.jsonData.allows(value) ?\n                            value\n                            : ctx.fallback.defaultValue({\n                                code: \"defaultValue\",\n                                base: valueSchema,\n                                value\n                            });\n                }\n                schema.properties[prop.key] = valueSchema;\n            }\n            if (this.requiredKeys.length && schema.properties) {\n                schema.required = this.requiredKeys.filter((k) => typeof k === \"string\" && k in schema.properties);\n            }\n        }\n        if (this.index) {\n            for (const index of this.index) {\n                const valueJsonSchema = index.value.toJsonSchemaRecurse(ctx);\n                if (index.signature.equals($ark.intrinsic.string)) {\n                    schema.additionalProperties = valueJsonSchema;\n                    continue;\n                }\n                for (const keyBranch of index.signature.branches) {\n                    if (!keyBranch.extends($ark.intrinsic.string)) {\n                        schema = ctx.fallback.symbolKey({\n                            code: \"symbolKey\",\n                            base: schema,\n                            key: null,\n                            value: valueJsonSchema,\n                            optional: false\n                        });\n                        continue;\n                    }\n                    let keySchema = { type: \"string\" };\n                    if (keyBranch.hasKind(\"morph\")) {\n                        keySchema = ctx.fallback.morph({\n                            code: \"morph\",\n                            base: keyBranch.in.toJsonSchemaRecurse(ctx),\n                            out: keyBranch.out.toJsonSchemaRecurse(ctx)\n                        });\n                    }\n                    if (!keyBranch.hasKind(\"intersection\")) {\n                        return throwInternalError(`Unexpected index branch kind ${keyBranch.kind}.`);\n                    }\n                    const { pattern } = keyBranch.inner;\n                    if (pattern) {\n                        const keySchemaWithPattern = Object.assign(keySchema, {\n                            pattern: pattern[0].rule\n                        });\n                        for (let i = 1; i < pattern.length; i++) {\n                            keySchema = ctx.fallback.patternIntersection({\n                                code: \"patternIntersection\",\n                                base: keySchemaWithPattern,\n                                pattern: pattern[i].rule\n                            });\n                        }\n                        schema.patternProperties ??= {};\n                        schema.patternProperties[keySchemaWithPattern.pattern] =\n                            valueJsonSchema;\n                    }\n                }\n            }\n        }\n        if (this.undeclared && !schema.additionalProperties)\n            schema.additionalProperties = false;\n        return schema;\n    }\n}\nconst defaultableMorphsCache = {};\nconst constructStructuralMorphCacheKey = (node) => {\n    let cacheKey = \"\";\n    for (let i = 0; i < node.defaultable.length; i++)\n        cacheKey += node.defaultable[i].defaultValueMorphRef;\n    if (node.sequence?.defaultValueMorphsReference)\n        cacheKey += node.sequence?.defaultValueMorphsReference;\n    if (node.undeclared === \"delete\") {\n        cacheKey += \"delete !(\";\n        if (node.required)\n            for (const n of node.required)\n                cacheKey += n.compiledKey + \" | \";\n        if (node.optional)\n            for (const n of node.optional)\n                cacheKey += n.compiledKey + \" | \";\n        if (node.index)\n            for (const index of node.index)\n                cacheKey += index.signature.id + \" | \";\n        if (node.sequence) {\n            if (node.sequence.maxLength === null)\n                cacheKey += intrinsic.nonNegativeIntegerString.id;\n            else {\n                for (let i = 0; i < node.sequence.tuple.length; i++)\n                    cacheKey += i + \" | \";\n            }\n        }\n        cacheKey += \")\";\n    }\n    return cacheKey;\n};\nconst getPossibleMorph = (node) => {\n    const cacheKey = constructStructuralMorphCacheKey(node);\n    if (!cacheKey)\n        return undefined;\n    if (defaultableMorphsCache[cacheKey])\n        return defaultableMorphsCache[cacheKey];\n    const $arkStructuralMorph = (data, ctx) => {\n        for (let i = 0; i < node.defaultable.length; i++) {\n            if (!(node.defaultable[i].key in data))\n                node.defaultable[i].defaultValueMorph(data, ctx);\n        }\n        if (node.sequence?.defaultables) {\n            for (let i = data.length - node.sequence.prefixLength; i < node.sequence.defaultables.length; i++)\n                node.sequence.defaultValueMorphs[i](data, ctx);\n        }\n        if (node.undeclared === \"delete\")\n            for (const k in data)\n                if (!node.declaresKey(k))\n                    delete data[k];\n        return data;\n    };\n    return (defaultableMorphsCache[cacheKey] = $arkStructuralMorph);\n};\nconst precompileMorphs = (js, node) => {\n    const requiresContext = node.defaultable.some(node => node.defaultValueMorph.length === 2) ||\n        node.sequence?.defaultValueMorphs.some(morph => morph.length === 2);\n    const args = `(data${requiresContext ? \", ctx\" : \"\"})`;\n    return js.block(`${args} => `, js => {\n        for (let i = 0; i < node.defaultable.length; i++) {\n            const { serializedKey, defaultValueMorphRef } = node.defaultable[i];\n            js.if(`!(${serializedKey} in data)`, js => js.line(`${defaultValueMorphRef}${args}`));\n        }\n        if (node.sequence?.defaultables) {\n            js.for(`i < ${node.sequence.defaultables.length}`, js => js.set(`data[i]`, 5), `data.length - ${node.sequence.prefixLength}`);\n        }\n        if (node.undeclared === \"delete\") {\n            js.forIn(\"data\", js => js.if(`!(${node._compileDeclaresKey(js)})`, js => js.line(`delete data[k]`)));\n        }\n        return js.return(\"data\");\n    });\n};\nexport const Structure = {\n    implementation,\n    Node: StructureNode\n};\nconst indexerToKey = (indexable) => {\n    if (hasArkKind(indexable, \"root\") && indexable.hasKind(\"unit\"))\n        indexable = indexable.unit;\n    if (typeof indexable === \"number\")\n        indexable = `${indexable}`;\n    return indexable;\n};\nexport const writeNumberIndexMessage = (indexExpression, sequenceExpression) => `${indexExpression} is not allowed as an array index on ${sequenceExpression}. Use the 'nonNegativeIntegerString' keyword instead.`;\n/** extract enumerable named props from an index signature */\nexport const normalizeIndex = (signature, value, $) => {\n    const [enumerableBranches, nonEnumerableBranches] = spliterate(signature.branches, k => k.hasKind(\"unit\"));\n    if (!enumerableBranches.length)\n        return { index: $.node(\"index\", { signature, value }) };\n    const normalized = {};\n    for (const n of enumerableBranches) {\n        // since required can be reduced to optional if it has a default or\n        // optional meta on its value, we have to assign it depending on the\n        // compiled kind\n        const prop = $.node(\"required\", { key: n.unit, value });\n        normalized[prop.kind] = append(normalized[prop.kind], prop);\n    }\n    if (nonEnumerableBranches.length) {\n        normalized.index = $.node(\"index\", {\n            signature: nonEnumerableBranches,\n            value\n        });\n    }\n    return normalized;\n};\nexport const typeKeyToString = (k) => hasArkKind(k, \"root\") ? k.expression : printable(k);\nexport const writeInvalidKeysMessage = (o, keys) => `Key${keys.length === 1 ? \"\" : \"s\"} ${keys.map(typeKeyToString).join(\", \")} ${keys.length === 1 ? \"does\" : \"do\"} not exist on ${o}`;\n", "import { deepClone, envHasCsp, flatMorph, withAlphabetizedKeys } from \"@ark/util\";\nimport { mergeConfigs } from \"./config.js\";\nimport { Predicate } from \"./predicate.js\";\nimport { Divisor } from \"./refinements/divisor.js\";\nimport { boundClassesByKind, boundImplementationsByKind } from \"./refinements/kinds.js\";\nimport { Pattern } from \"./refinements/pattern.js\";\nimport { Alias } from \"./roots/alias.js\";\nimport { Domain } from \"./roots/domain.js\";\nimport { Intersection } from \"./roots/intersection.js\";\nimport { Morph } from \"./roots/morph.js\";\nimport { Proto } from \"./roots/proto.js\";\nimport { Union } from \"./roots/union.js\";\nimport { Unit } from \"./roots/unit.js\";\nimport { $ark } from \"./shared/registry.js\";\nimport { ToJsonSchema } from \"./shared/toJsonSchema.js\";\nimport { Index } from \"./structure/index.js\";\nimport { Optional } from \"./structure/optional.js\";\nimport { Required } from \"./structure/required.js\";\nimport { Sequence } from \"./structure/sequence.js\";\nimport { Structure } from \"./structure/structure.js\";\nexport const nodeImplementationsByKind = {\n    ...boundImplementationsByKind,\n    alias: Alias.implementation,\n    domain: Domain.implementation,\n    unit: Unit.implementation,\n    proto: Proto.implementation,\n    union: Union.implementation,\n    morph: Morph.implementation,\n    intersection: Intersection.implementation,\n    divisor: Divisor.implementation,\n    pattern: Pattern.implementation,\n    predicate: Predicate.implementation,\n    required: Required.implementation,\n    optional: Optional.implementation,\n    index: Index.implementation,\n    sequence: Sequence.implementation,\n    structure: Structure.implementation\n};\n$ark.defaultConfig = withAlphabetizedKeys(Object.assign(flatMorph(nodeImplementationsByKind, (kind, implementation) => [\n    kind,\n    implementation.defaults\n]), {\n    jitless: envHasCsp(),\n    clone: deepClone,\n    onUndeclaredKey: \"ignore\",\n    exactOptionalPropertyTypes: true,\n    numberAllowsNaN: false,\n    dateAllowsInvalid: false,\n    onFail: null,\n    keywords: {},\n    toJsonSchema: ToJsonSchema.defaultConfig\n}));\n$ark.resolvedConfig = mergeConfigs($ark.defaultConfig, $ark.config);\nexport const nodeClassesByKind = {\n    ...boundClassesByKind,\n    alias: Alias.Node,\n    domain: Domain.Node,\n    unit: Unit.Node,\n    proto: Proto.Node,\n    union: Union.Node,\n    morph: Morph.Node,\n    intersection: Intersection.Node,\n    divisor: Divisor.Node,\n    pattern: Pattern.Node,\n    predicate: Predicate.Node,\n    required: Required.Node,\n    optional: Optional.Node,\n    index: Index.Node,\n    sequence: Sequence.Node,\n    structure: Structure.Node\n};\n", "import { DynamicBase, flatMorph } from \"@ark/util\";\nimport { arkKind, hasArkKind } from \"./shared/utils.js\";\nexport class RootModule extends DynamicBase {\n    // ensure `[arkKind]` is non-enumerable so it doesn't get spread on import/export\n    get [arkKind]() {\n        return \"module\";\n    }\n}\nexport const bindModule = (module, $) => new RootModule(flatMorph(module, (alias, value) => [\n    alias,\n    hasArkKind(value, \"module\") ?\n        bindModule(value, $)\n        : $.bindReference(value)\n]));\nexport const SchemaModule = RootModule;\n", "import { ParseError, flatMorph, hasDomain, isArray, isThunk, printable, throwInternalError, throwParseError } from \"@ark/util\";\nimport { mergeConfigs } from \"./config.js\";\nimport { GenericRoot, LazyGenericBody } from \"./generic.js\";\nimport { nodeImplementationsByKind } from \"./kinds.js\";\nimport { RootModule, bindModule } from \"./module.js\";\nimport { nodesByRegisteredId, parseNode, registerNodeId, schemaKindOf, withId } from \"./parse.js\";\nimport { Alias } from \"./roots/alias.js\";\nimport { CompiledFunction, NodeCompiler } from \"./shared/compile.js\";\nimport { $ark } from \"./shared/registry.js\";\nimport { Traversal } from \"./shared/traversal.js\";\nimport { arkKind, hasArkKind, isNode } from \"./shared/utils.js\";\nconst schemaBranchesOf = (schema) => isArray(schema) ? schema\n    : \"branches\" in schema && isArray(schema.branches) ? schema.branches\n        : undefined;\nconst throwMismatchedNodeRootError = (expected, actual) => throwParseError(`Node of kind ${actual} is not valid as a ${expected} definition`);\nexport const writeDuplicateAliasError = (alias) => `#${alias} duplicates public alias ${alias}`;\nconst scopesByName = {};\n$ark.ambient ??= {};\nlet rawUnknownUnion;\nconst rootScopeFnName = \"function $\";\nconst precompile = (references) => bindPrecompilation(references, precompileReferences(references));\nconst bindPrecompilation = (references, precompiler) => {\n    const precompilation = precompiler.write(rootScopeFnName, 4);\n    const compiledTraversals = precompiler.compile()();\n    for (const node of references) {\n        if (node.precompilation) {\n            // if node has already been bound to another scope or anonymous type, don't rebind it\n            continue;\n        }\n        node.traverseAllows =\n            compiledTraversals[`${node.id}Allows`].bind(compiledTraversals);\n        if (node.isRoot() && !node.allowsRequiresContext) {\n            // if the reference doesn't require context, we can assign over\n            // it directly to avoid having to initialize it\n            node.allows = node.traverseAllows;\n        }\n        node.traverseApply =\n            compiledTraversals[`${node.id}Apply`].bind(compiledTraversals);\n        if (compiledTraversals[`${node.id}Optimistic`]) {\n            ;\n            node.traverseOptimistic =\n                compiledTraversals[`${node.id}Optimistic`].bind(compiledTraversals);\n        }\n        node.precompilation = precompilation;\n    }\n};\nconst precompileReferences = (references) => new CompiledFunction().return(references.reduce((js, node) => {\n    const allowsCompiler = new NodeCompiler({ kind: \"Allows\" }).indent();\n    node.compile(allowsCompiler);\n    const allowsJs = allowsCompiler.write(`${node.id}Allows`);\n    const applyCompiler = new NodeCompiler({ kind: \"Apply\" }).indent();\n    node.compile(applyCompiler);\n    const applyJs = applyCompiler.write(`${node.id}Apply`);\n    const result = `${js}${allowsJs},\\n${applyJs},\\n`;\n    if (!node.hasKind(\"union\"))\n        return result;\n    const optimisticCompiler = new NodeCompiler({\n        kind: \"Allows\",\n        optimistic: true\n    }).indent();\n    node.compile(optimisticCompiler);\n    const optimisticJs = optimisticCompiler.write(`${node.id}Optimistic`);\n    return `${result}${optimisticJs},\\n`;\n}, \"{\\n\") + \"}\");\nexport class BaseScope {\n    config;\n    resolvedConfig;\n    name;\n    get [arkKind]() {\n        return \"scope\";\n    }\n    referencesById = {};\n    references = [];\n    resolutions = {};\n    exportedNames = [];\n    aliases = {};\n    resolved = false;\n    nodesByHash = {};\n    intrinsic;\n    constructor(\n    /** The set of names defined at the root-level of the scope mapped to their\n     * corresponding definitions.**/\n    def, config) {\n        this.config = mergeConfigs($ark.config, config);\n        this.resolvedConfig = mergeConfigs($ark.resolvedConfig, config);\n        this.name =\n            this.resolvedConfig.name ??\n                `anonymousScope${Object.keys(scopesByName).length}`;\n        if (this.name in scopesByName)\n            throwParseError(`A Scope already named ${this.name} already exists`);\n        scopesByName[this.name] = this;\n        const aliasEntries = Object.entries(def).map(entry => this.preparseOwnAliasEntry(...entry));\n        for (const [k, v] of aliasEntries) {\n            let name = k;\n            if (k[0] === \"#\") {\n                name = k.slice(1);\n                if (name in this.aliases)\n                    throwParseError(writeDuplicateAliasError(name));\n                this.aliases[name] = v;\n            }\n            else {\n                if (name in this.aliases)\n                    throwParseError(writeDuplicateAliasError(k));\n                this.aliases[name] = v;\n                this.exportedNames.push(name);\n            }\n            if (!hasArkKind(v, \"module\") &&\n                !hasArkKind(v, \"generic\") &&\n                !isThunk(v)) {\n                const preparsed = this.preparseOwnDefinitionFormat(v, { alias: name });\n                this.resolutions[name] =\n                    hasArkKind(preparsed, \"root\") ?\n                        this.bindReference(preparsed)\n                        : this.createParseContext(preparsed).id;\n            }\n        }\n        // reduce union of all possible values reduces to unknown\n        rawUnknownUnion ??= this.node(\"union\", {\n            branches: [\n                \"string\",\n                \"number\",\n                \"object\",\n                \"bigint\",\n                \"symbol\",\n                { unit: true },\n                { unit: false },\n                { unit: undefined },\n                { unit: null }\n            ]\n        }, { prereduced: true });\n        this.nodesByHash[rawUnknownUnion.hash] = this.node(\"intersection\", {}, { prereduced: true });\n        this.intrinsic =\n            $ark.intrinsic ?\n                flatMorph($ark.intrinsic, (k, v) => \n                // don't include cyclic aliases from JSON scope\n                k.startsWith(\"json\") ? [] : [k, this.bindReference(v)])\n                // intrinsic won't be available during bootstrapping,  so we lie\n                // about the type here as an extrnal convenience\n                : {};\n    }\n    cacheGetter(name, value) {\n        Object.defineProperty(this, name, { value });\n        return value;\n    }\n    get internal() {\n        return this;\n    }\n    // json is populated when the scope is exported, so ensure it is populated\n    // before allowing external access\n    _json;\n    get json() {\n        if (!this._json)\n            this.export();\n        return this._json;\n    }\n    defineSchema(def) {\n        return def;\n    }\n    generic = (...params) => {\n        const $ = this;\n        return (def, possibleHkt) => new GenericRoot(params, possibleHkt ? new LazyGenericBody(def) : def, $, $, possibleHkt ?? null);\n    };\n    units = (values, opts) => {\n        const uniqueValues = [];\n        for (const value of values)\n            if (!uniqueValues.includes(value))\n                uniqueValues.push(value);\n        const branches = uniqueValues.map(unit => this.node(\"unit\", { unit }, opts));\n        return this.node(\"union\", branches, {\n            ...opts,\n            prereduced: true\n        });\n    };\n    lazyResolutions = [];\n    lazilyResolve(resolve, syntheticAlias) {\n        const node = this.node(\"alias\", {\n            reference: syntheticAlias ?? \"synthetic\",\n            resolve\n        }, { prereduced: true });\n        if (!this.resolved)\n            this.lazyResolutions.push(node);\n        return node;\n    }\n    schema = (schema, opts) => this.finalize(this.parseSchema(schema, opts));\n    parseSchema = (schema, opts) => this.node(schemaKindOf(schema), schema, opts);\n    preparseNode(kinds, schema, opts) {\n        let kind = typeof kinds === \"string\" ? kinds : schemaKindOf(schema, kinds);\n        if (isNode(schema) && schema.kind === kind)\n            return schema;\n        if (kind === \"alias\" && !opts?.prereduced) {\n            const { reference } = Alias.implementation.normalize(schema, this);\n            if (reference.startsWith(\"$\")) {\n                const resolution = this.resolveRoot(reference.slice(1));\n                schema = resolution;\n                kind = resolution.kind;\n            }\n        }\n        else if (kind === \"union\" && hasDomain(schema, \"object\")) {\n            const branches = schemaBranchesOf(schema);\n            if (branches?.length === 1) {\n                schema = branches[0];\n                kind = schemaKindOf(schema);\n            }\n        }\n        if (isNode(schema) && schema.kind === kind)\n            return schema;\n        const impl = nodeImplementationsByKind[kind];\n        const normalizedSchema = impl.normalize?.(schema, this) ?? schema;\n        // check again after normalization in case a node is a valid collapsed\n        // schema for the kind (e.g. sequence can collapse to element accepting a Node')\n        if (isNode(normalizedSchema)) {\n            return normalizedSchema.kind === kind ?\n                normalizedSchema\n                : throwMismatchedNodeRootError(kind, normalizedSchema.kind);\n        }\n        return {\n            ...opts,\n            $: this,\n            kind,\n            def: normalizedSchema,\n            prefix: opts.alias ?? kind\n        };\n    }\n    bindReference(reference) {\n        let bound;\n        if (isNode(reference)) {\n            bound =\n                reference.$ === this ?\n                    reference\n                    : new reference.constructor(reference.attachments, this);\n        }\n        else {\n            bound =\n                reference.$ === this ?\n                    reference\n                    : new GenericRoot(reference.params, reference.bodyDef, reference.$, this, reference.hkt);\n        }\n        if (!this.resolved) {\n            // we're still parsing the scope itself, so defer compilation but\n            // add the node as a reference\n            Object.assign(this.referencesById, bound.referencesById);\n        }\n        return bound;\n    }\n    resolveRoot(name) {\n        return (this.maybeResolveRoot(name) ??\n            throwParseError(writeUnresolvableMessage(name)));\n    }\n    maybeResolveRoot(name) {\n        const result = this.maybeResolve(name);\n        if (hasArkKind(result, \"generic\"))\n            return;\n        return result;\n    }\n    /** If name is a valid reference to a submodule alias, return its resolution  */\n    maybeResolveSubalias(name) {\n        return (maybeResolveSubalias(this.aliases, name) ??\n            maybeResolveSubalias(this.ambient, name));\n    }\n    get ambient() {\n        return $ark.ambient;\n    }\n    maybeResolve(name) {\n        const cached = this.resolutions[name];\n        if (cached) {\n            if (typeof cached !== \"string\")\n                return this.bindReference(cached);\n            const v = nodesByRegisteredId[cached];\n            if (hasArkKind(v, \"root\"))\n                return (this.resolutions[name] = v);\n            if (hasArkKind(v, \"context\")) {\n                if (v.phase === \"resolving\") {\n                    return this.node(\"alias\", { reference: `$${name}` }, { prereduced: true });\n                }\n                if (v.phase === \"resolved\") {\n                    return throwInternalError(`Unexpected resolved context for was uncached by its scope: ${printable(v)}`);\n                }\n                v.phase = \"resolving\";\n                const node = this.bindReference(this.parseOwnDefinitionFormat(v.def, v));\n                v.phase = \"resolved\";\n                nodesByRegisteredId[node.id] = node;\n                nodesByRegisteredId[v.id] = node;\n                return (this.resolutions[name] = node);\n            }\n            return throwInternalError(`Unexpected nodesById entry for ${cached}: ${printable(v)}`);\n        }\n        let def = this.aliases[name] ?? this.ambient?.[name];\n        if (!def)\n            return this.maybeResolveSubalias(name);\n        def = this.normalizeRootScopeValue(def);\n        if (hasArkKind(def, \"generic\"))\n            return (this.resolutions[name] = this.bindReference(def));\n        if (hasArkKind(def, \"module\")) {\n            if (!def.root)\n                throwParseError(writeMissingSubmoduleAccessMessage(name));\n            return (this.resolutions[name] = this.bindReference(def.root));\n        }\n        return (this.resolutions[name] = this.parse(def, {\n            alias: name\n        }));\n    }\n    createParseContext(input) {\n        const id = input.id ?? registerNodeId(input.prefix);\n        return (nodesByRegisteredId[id] = Object.assign(input, {\n            [arkKind]: \"context\",\n            $: this,\n            id,\n            phase: \"unresolved\"\n        }));\n    }\n    traversal(root) {\n        return new Traversal(root, this.resolvedConfig);\n    }\n    import(...names) {\n        return new RootModule(flatMorph(this.export(...names), (alias, value) => [\n            `#${alias}`,\n            value\n        ]));\n    }\n    precompilation;\n    _exportedResolutions;\n    _exports;\n    export(...names) {\n        if (!this._exports) {\n            this._exports = {};\n            for (const name of this.exportedNames) {\n                const def = this.aliases[name];\n                this._exports[name] =\n                    hasArkKind(def, \"module\") ?\n                        bindModule(def, this)\n                        : bootstrapAliasReferences(this.maybeResolve(name));\n            }\n            // force node.resolution getter evaluation\n            // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n            for (const node of this.lazyResolutions)\n                node.resolution;\n            this._exportedResolutions = resolutionsOfModule(this, this._exports);\n            this._json = resolutionsToJson(this._exportedResolutions);\n            Object.assign(this.resolutions, this._exportedResolutions);\n            this.references = Object.values(this.referencesById);\n            if (!this.resolvedConfig.jitless) {\n                const precompiler = precompileReferences(this.references);\n                this.precompilation = precompiler.write(rootScopeFnName, 4);\n                bindPrecompilation(this.references, precompiler);\n            }\n            this.resolved = true;\n        }\n        const namesToExport = names.length ? names : this.exportedNames;\n        return new RootModule(flatMorph(namesToExport, (_, name) => [\n            name,\n            this._exports[name]\n        ]));\n    }\n    resolve(name) {\n        return this.export()[name];\n    }\n    node = (kinds, nodeSchema, opts = {}) => {\n        const ctxOrNode = this.preparseNode(kinds, nodeSchema, opts);\n        if (isNode(ctxOrNode))\n            return this.bindReference(ctxOrNode);\n        const ctx = this.createParseContext(ctxOrNode);\n        const node = parseNode(ctx);\n        const bound = this.bindReference(node);\n        return (nodesByRegisteredId[ctx.id] = bound);\n    };\n    parse = (def, opts = {}) => this.finalize(this.parseDefinition(def, opts));\n    parseDefinition(def, opts = {}) {\n        if (hasArkKind(def, \"root\"))\n            return this.bindReference(def);\n        const ctxInputOrNode = this.preparseOwnDefinitionFormat(def, opts);\n        if (hasArkKind(ctxInputOrNode, \"root\"))\n            return this.bindReference(ctxInputOrNode);\n        const ctx = this.createParseContext(ctxInputOrNode);\n        nodesByRegisteredId[ctx.id] = ctx;\n        let node = this.bindReference(this.parseOwnDefinitionFormat(def, ctx));\n        // if the node is recursive e.g. { box: \"this\" }, we need to make sure it\n        // has the original id from context so that its references compile correctly\n        if (node.isCyclic)\n            node = withId(node, ctx.id);\n        nodesByRegisteredId[ctx.id] = node;\n        return node;\n    }\n    finalize(node) {\n        bootstrapAliasReferences(node);\n        if (!node.precompilation && !this.resolvedConfig.jitless)\n            precompile(node.references);\n        return node;\n    }\n}\nexport class SchemaScope extends BaseScope {\n    parseOwnDefinitionFormat(def, ctx) {\n        return parseNode(ctx);\n    }\n    preparseOwnDefinitionFormat(schema, opts) {\n        return this.preparseNode(schemaKindOf(schema), schema, opts);\n    }\n    preparseOwnAliasEntry(k, v) {\n        return [k, v];\n    }\n    normalizeRootScopeValue(v) {\n        return v;\n    }\n}\nconst bootstrapAliasReferences = (resolution) => {\n    const aliases = resolution.references.filter(node => node.hasKind(\"alias\"));\n    for (const aliasNode of aliases) {\n        Object.assign(aliasNode.referencesById, aliasNode.resolution.referencesById);\n        for (const ref of resolution.references) {\n            if (aliasNode.id in ref.referencesById)\n                Object.assign(ref.referencesById, aliasNode.referencesById);\n        }\n    }\n    return resolution;\n};\nconst resolutionsToJson = (resolutions) => flatMorph(resolutions, (k, v) => [\n    k,\n    hasArkKind(v, \"root\") || hasArkKind(v, \"generic\") ? v.json\n        : hasArkKind(v, \"module\") ? resolutionsToJson(v)\n            : throwInternalError(`Unexpected resolution ${printable(v)}`)\n]);\nconst maybeResolveSubalias = (base, name) => {\n    const dotIndex = name.indexOf(\".\");\n    if (dotIndex === -1)\n        return;\n    const dotPrefix = name.slice(0, dotIndex);\n    const prefixSchema = base[dotPrefix];\n    // if the name includes \".\", but the prefix is not an alias, it\n    // might be something like a decimal literal, so just fall through to return\n    if (prefixSchema === undefined)\n        return;\n    if (!hasArkKind(prefixSchema, \"module\"))\n        return throwParseError(writeNonSubmoduleDotMessage(dotPrefix));\n    const subalias = name.slice(dotIndex + 1);\n    const resolution = prefixSchema[subalias];\n    if (resolution === undefined)\n        return maybeResolveSubalias(prefixSchema, subalias);\n    if (hasArkKind(resolution, \"root\") || hasArkKind(resolution, \"generic\"))\n        return resolution;\n    if (hasArkKind(resolution, \"module\")) {\n        return (resolution.root ??\n            throwParseError(writeMissingSubmoduleAccessMessage(name)));\n    }\n    throwInternalError(`Unexpected resolution for alias '${name}': ${printable(resolution)}`);\n};\nexport const schemaScope = (aliases, config) => new SchemaScope(aliases, config);\nexport const rootSchemaScope = new SchemaScope({});\nexport const parseAsSchema = (def, opts) => {\n    try {\n        return rootSchema(def, opts);\n    }\n    catch (e) {\n        if (e instanceof ParseError)\n            return e;\n        throw e;\n    }\n};\nconst resolutionsOfModule = ($, typeSet) => {\n    const result = {};\n    for (const k in typeSet) {\n        const v = typeSet[k];\n        if (hasArkKind(v, \"module\")) {\n            const innerResolutions = resolutionsOfModule($, v);\n            const prefixedResolutions = flatMorph(innerResolutions, (innerK, innerV) => [`${k}.${innerK}`, innerV]);\n            Object.assign(result, prefixedResolutions);\n        }\n        else if (hasArkKind(v, \"root\") || hasArkKind(v, \"generic\"))\n            result[k] = v;\n        else\n            throwInternalError(`Unexpected scope resolution ${printable(v)}`);\n    }\n    return result;\n};\nexport const writeUnresolvableMessage = (token) => `'${token}' is unresolvable`;\nexport const writeNonSubmoduleDotMessage = (name) => `'${name}' must reference a module to be accessed using dot syntax`;\nexport const writeMissingSubmoduleAccessMessage = (name) => `Reference to submodule '${name}' must specify an alias`;\n// ensure the scope is resolved so JIT will be applied to future types\nrootSchemaScope.export();\nexport const rootSchema = rootSchemaScope.schema;\nexport const node = rootSchemaScope.node;\nexport const defineSchema = rootSchemaScope.defineSchema;\nexport const genericNode = rootSchemaScope.generic;\n", "import { registeredReference } from \"../shared/registry.js\";\nexport const arrayIndexSource = `^(?:0|[1-9]\\\\d*)$`;\nexport const arrayIndexMatcher = new RegExp(arrayIndexSource);\nexport const arrayIndexMatcherReference = registeredReference(arrayIndexMatcher);\n", "import { node, schemaScope } from \"./scope.js\";\nimport { $ark } from \"./shared/registry.js\";\nimport { arrayIndexSource } from \"./structure/shared.js\";\nconst intrinsicBases = schemaScope({\n    bigint: \"bigint\",\n    // since we know this won't be reduced, it can be safely cast to a union\n    boolean: [{ unit: false }, { unit: true }],\n    false: { unit: false },\n    never: [],\n    null: { unit: null },\n    number: \"number\",\n    object: \"object\",\n    string: \"string\",\n    symbol: \"symbol\",\n    true: { unit: true },\n    unknown: {},\n    undefined: { unit: undefined },\n    Array,\n    Date\n}, { prereducedAliases: true }).export();\n$ark.intrinsic = { ...intrinsicBases };\nconst intrinsicRoots = schemaScope({\n    integer: {\n        domain: \"number\",\n        divisor: 1\n    },\n    lengthBoundable: [\"string\", Array],\n    key: [\"string\", \"symbol\"],\n    nonNegativeIntegerString: { domain: \"string\", pattern: arrayIndexSource }\n}, { prereducedAliases: true }).export();\n// needed to parse index signatures for JSON\nObject.assign($ark.intrinsic, intrinsicRoots);\nconst intrinsicJson = schemaScope({\n    jsonPrimitive: [\n        \"string\",\n        \"number\",\n        { unit: true },\n        { unit: false },\n        { unit: null }\n    ],\n    jsonObject: {\n        domain: \"object\",\n        index: {\n            signature: \"string\",\n            value: \"$jsonData\"\n        }\n    },\n    jsonData: [\"$jsonPrimitive\", \"$jsonObject\"]\n}, { prereducedAliases: true }).export();\nexport const intrinsic = {\n    ...intrinsicBases,\n    ...intrinsicRoots,\n    ...intrinsicJson,\n    emptyStructure: node(\"structure\", {}, { prereduced: true })\n};\n$ark.intrinsic = { ...intrinsic };\n", "// eslint-disable-next-line @typescript-eslint/no-restricted-imports\nimport { configureSchema } from \"@ark/schema/config\";\nexport const configure = configureSchema;\n", "import { throwParseError, tryParseNumber } from \"@ark/util\";\nexport const isDateLiteral = (value) => typeof value === \"string\" &&\n    value[0] === \"d\" &&\n    (value[1] === \"'\" || value[1] === '\"') &&\n    value.at(-1) === value[1];\nexport const isValidDate = (d) => d.toString() !== \"Invalid Date\";\nexport const extractDateLiteralSource = (literal) => literal.slice(2, -1);\nexport const writeInvalidDateMessage = (source) => `'${source}' could not be parsed by the Date constructor`;\nexport const tryParseDate = (source, errorOnFail) => maybeParseDate(source, errorOnFail);\nconst maybeParseDate = (source, errorOnFail) => {\n    const stringParsedDate = new Date(source);\n    if (isValidDate(stringParsedDate))\n        return stringParsedDate;\n    const epochMillis = tryParseNumber(source);\n    if (epochMillis !== undefined) {\n        const numberParsedDate = new Date(epochMillis);\n        if (isValidDate(numberParsedDate))\n            return numberParsedDate;\n    }\n    return errorOnFail ?\n        throwParseError(errorOnFail === true ? writeInvalidDateMessage(source) : errorOnFail)\n        : undefined;\n};\n", "import { isKeyOf, throwParseError } from \"@ark/util\";\nimport { tryParseDate, writeInvalidDateMessage } from \"./date.js\";\nexport const parseEnclosed = (s, enclosing) => {\n    const enclosed = s.scanner.shiftUntil(untilLookaheadIsClosing[enclosingTokens[enclosing]]);\n    if (s.scanner.lookahead === \"\")\n        return s.error(writeUnterminatedEnclosedMessage(enclosed, enclosing));\n    // Shift the scanner one additional time for the second enclosing token\n    s.scanner.shift();\n    if (enclosing === \"/\") {\n        try {\n            new RegExp(enclosed);\n        }\n        catch (e) {\n            throwParseError(String(e));\n        }\n        s.root = s.ctx.$.node(\"intersection\", {\n            domain: \"string\",\n            pattern: enclosed\n        }, { prereduced: true });\n    }\n    else if (isKeyOf(enclosing, enclosingQuote))\n        s.root = s.ctx.$.node(\"unit\", { unit: enclosed });\n    else {\n        const date = tryParseDate(enclosed, writeInvalidDateMessage(enclosed));\n        s.root = s.ctx.$.node(\"unit\", { meta: enclosed, unit: date });\n    }\n};\nexport const enclosingQuote = {\n    \"'\": 1,\n    '\"': 1\n};\nexport const enclosingChar = {\n    \"/\": 1,\n    \"'\": 1,\n    '\"': 1\n};\nexport const enclosingTokens = {\n    \"d'\": \"'\",\n    'd\"': '\"',\n    \"'\": \"'\",\n    '\"': '\"',\n    \"/\": \"/\"\n};\nexport const untilLookaheadIsClosing = {\n    \"'\": scanner => scanner.lookahead === `'`,\n    '\"': scanner => scanner.lookahead === `\"`,\n    \"/\": scanner => scanner.lookahead === `/`\n};\nconst enclosingCharDescriptions = {\n    '\"': \"double-quote\",\n    \"'\": \"single-quote\",\n    \"/\": \"forward slash\"\n};\nexport const writeUnterminatedEnclosedMessage = (fragment, enclosingStart) => `${enclosingStart}${fragment} requires a closing ${enclosingCharDescriptions[enclosingTokens[enclosingStart]]}`;\n", "export const writePrefixedPrivateReferenceMessage = (name) => `Private type references should not include '#'. Use '${name}' instead.`;\nexport const shallowOptionalMessage = \"Optional definitions like 'string?' are only valid as properties in an object or tuple\";\nexport const shallowDefaultableMessage = \"Defaultable definitions like 'number = 0' are only valid as properties in an object or tuple\";\n", "export const minComparators = {\n    \">\": true,\n    \">=\": true\n};\nexport const maxComparators = {\n    \"<\": true,\n    \"<=\": true\n};\nexport const comparators = {\n    \">\": true,\n    \">=\": true,\n    \"<\": true,\n    \"<=\": true,\n    \"==\": true\n};\nexport const invertedComparators = {\n    \"<\": \">\",\n    \">\": \"<\",\n    \"<=\": \">=\",\n    \">=\": \"<=\",\n    \"==\": \"==\"\n};\nexport const writeUnmatchedGroupCloseMessage = (unscanned) => `Unmatched )${(unscanned === \"\" ? \"\" : ` before ${unscanned}`)}`;\nexport const writeUnclosedGroupMessage = (missingChar) => `Missing ${missingChar}`;\nexport const writeOpenRangeMessage = (min, comparator) => `Left bounds are only valid when paired with right bounds (try ...${comparator}${min})`;\nexport const writeUnpairableComparatorMessage = (comparator) => `Left-bounded expressions must specify their limits using < or <= (was ${comparator})`;\nexport const writeMultipleLeftBoundsMessage = (openLimit, openComparator, limit, comparator) => `An expression may have at most one left bound (parsed ${openLimit}${invertedComparators[openComparator]}, ${limit}${invertedComparators[comparator]})`;\n", "import { writeUnclosedGroupMessage } from \"../../reduce/shared.js\";\nexport const parseGenericArgs = (name, g, s) => _parseGenericArgs(name, g, s, []);\nconst _parseGenericArgs = (name, g, s, argNodes) => {\n    const argState = s.parseUntilFinalizer();\n    argNodes.push(argState.root);\n    if (argState.finalizer === \">\") {\n        if (argNodes.length !== g.params.length) {\n            return s.error(writeInvalidGenericArgCountMessage(name, g.names, argNodes.map(arg => arg.expression)));\n        }\n        return argNodes;\n    }\n    if (argState.finalizer === \",\")\n        return _parseGenericArgs(name, g, s, argNodes);\n    return argState.error(writeUnclosedGroupMessage(\">\"));\n};\nexport const writeInvalidGenericArgCountMessage = (name, params, argDefs) => `${name}<${params.join(\", \")}> requires exactly ${params.length} args (got ${argDefs.length}${argDefs.length === 0 ? \"\" : `: ${argDefs.join(\", \")}`})`;\n", "import { hasArkKind, writeUnresolvableMessage } from \"@ark/schema\";\nimport { printable, throwParseError, tryParseWellFormedBigint, tryParseWellFormedNumber } from \"@ark/util\";\nimport { writePrefixedPrivateReferenceMessage } from \"../../ast/validate.js\";\nimport { parseGenericArgs, writeInvalidGenericArgCountMessage } from \"./genericArgs.js\";\nexport const parseUnenclosed = (s) => {\n    const token = s.scanner.shiftUntilNextTerminator();\n    if (token === \"keyof\")\n        s.addPrefix(\"keyof\");\n    else\n        s.root = unenclosedToNode(s, token);\n};\nexport const parseGenericInstantiation = (name, g, s) => {\n    s.scanner.shiftUntilNonWhitespace();\n    const lookahead = s.scanner.shift();\n    if (lookahead !== \"<\")\n        return s.error(writeInvalidGenericArgCountMessage(name, g.names, []));\n    const parsedArgs = parseGenericArgs(name, g, s);\n    return g(...parsedArgs);\n};\nconst unenclosedToNode = (s, token) => maybeParseReference(s, token) ??\n    maybeParseUnenclosedLiteral(s, token) ??\n    s.error(token === \"\" ?\n        s.scanner.lookahead === \"#\" ?\n            writePrefixedPrivateReferenceMessage(s.shiftedByOne().scanner.shiftUntilNextTerminator())\n            : writeMissingOperandMessage(s)\n        : writeUnresolvableMessage(token));\nconst maybeParseReference = (s, token) => {\n    if (s.ctx.args?.[token]) {\n        const arg = s.ctx.args[token];\n        if (typeof arg !== \"string\")\n            return arg;\n        return s.ctx.$.node(\"alias\", { reference: arg }, { prereduced: true });\n    }\n    const resolution = s.ctx.$.maybeResolve(token);\n    if (hasArkKind(resolution, \"root\"))\n        return resolution;\n    if (resolution === undefined)\n        return;\n    if (hasArkKind(resolution, \"generic\"))\n        return parseGenericInstantiation(token, resolution, s);\n    return throwParseError(`Unexpected resolution ${printable(resolution)}`);\n};\nconst maybeParseUnenclosedLiteral = (s, token) => {\n    const maybeNumber = tryParseWellFormedNumber(token);\n    if (maybeNumber !== undefined)\n        return s.ctx.$.node(\"unit\", { unit: maybeNumber });\n    const maybeBigint = tryParseWellFormedBigint(token);\n    if (maybeBigint !== undefined)\n        return s.ctx.$.node(\"unit\", { unit: maybeBigint });\n};\nexport const writeMissingOperandMessage = (s) => {\n    const operator = s.previousOperator();\n    return operator ?\n        writeMissingRightOperandMessage(operator, s.scanner.unscanned)\n        : writeExpressionExpectedMessage(s.scanner.unscanned);\n};\nexport const writeMissingRightOperandMessage = (token, unscanned = \"\") => `Token '${token}' requires a right operand${unscanned ? ` before '${unscanned}'` : \"\"}`;\nexport const writeExpressionExpectedMessage = (unscanned) => `Expected an expression${unscanned ? ` before '${unscanned}'` : \"\"}`;\n", "import { whitespaceChars } from \"@ark/util\";\nimport { enclosingChar, enclosingQuote, parseEnclosed } from \"./enclosed.js\";\nimport { parseUnenclosed, writeMissingOperandMessage } from \"./unenclosed.js\";\nexport const parseOperand = (s) => s.scanner.lookahead === \"\" ? s.error(writeMissingOperandMessage(s))\n    : s.scanner.lookahead === \"(\" ? s.shiftedByOne().reduceGroupOpen()\n        : s.scanner.lookaheadIsIn(enclosingChar) ? parseEnclosed(s, s.scanner.shift())\n            : s.scanner.lookaheadIsIn(whitespaceChars) ? parseOperand(s.shiftedByOne())\n                : s.scanner.lookahead === \"d\" ?\n                    s.scanner.nextLookahead in enclosingQuote ?\n                        parseEnclosed(s, `${s.scanner.shift()}${s.scanner.shift()}`)\n                        : parseUnenclosed(s)\n                    : parseUnenclosed(s);\n", "import { isKeyOf, Scanner, whitespaceChars } from \"@ark/util\";\nexport class ArkTypeScanner extends Scanner {\n    shiftUntilNextTerminator() {\n        this.shiftUntilNonWhitespace();\n        return this.shiftUntil(() => this.lookahead in ArkTypeScanner.terminatingChars);\n    }\n    static terminatingChars = {\n        \"<\": 1,\n        \">\": 1,\n        \"=\": 1,\n        \"|\": 1,\n        \"&\": 1,\n        \")\": 1,\n        \"[\": 1,\n        \"%\": 1,\n        \",\": 1,\n        \":\": 1,\n        \"?\": 1,\n        \"#\": 1,\n        ...whitespaceChars\n    };\n    static finalizingLookaheads = {\n        \">\": 1,\n        \",\": 1,\n        \"\": 1,\n        \"=\": 1,\n        \"?\": 1\n    };\n    static lookaheadIsFinalizing = (lookahead, unscanned) => lookahead === \">\" ?\n        unscanned[0] === \"=\" ?\n            // >== would only occur in an expression like Array<number>==5\n            // otherwise, >= would only occur as part of a bound like number>=5\n            unscanned[1] === \"=\"\n            // if > is the end of a generic instantiation, the next token will be\n            // an operator or the end of the string\n            : unscanned.trimStart() === \"\" ||\n                isKeyOf(unscanned.trimStart()[0], ArkTypeScanner.terminatingChars)\n        // \"=\" is a finalizer on its own (representing a default value),\n        // but not with a second \"=\" (an equality comparator)\n        : lookahead === \"=\" ? unscanned[0] !== \"=\"\n            // \",\" and \"?\" are unambiguously finalizers\n            : lookahead === \",\" || lookahead === \"?\";\n}\n", "import { $ark, writeUnboundableMessage } from \"@ark/schema\";\nimport { isKeyOf, throwParseError } from \"@ark/util\";\nimport { invertedComparators, maxComparators, writeUnpairableComparatorMessage } from \"../../reduce/shared.js\";\nimport { extractDateLiteralSource, isDateLiteral } from \"../operand/date.js\";\nexport const parseBound = (s, start) => {\n    const comparator = shiftComparator(s, start);\n    if (s.root.hasKind(\"unit\")) {\n        if (typeof s.root.unit === \"number\") {\n            s.reduceLeftBound(s.root.unit, comparator);\n            s.unsetRoot();\n            return;\n        }\n        if (s.root.unit instanceof Date) {\n            const literal = `d'${s.root.description ?? s.root.unit.toISOString()}'`;\n            s.unsetRoot();\n            s.reduceLeftBound(literal, comparator);\n            return;\n        }\n    }\n    return parseRightBound(s, comparator);\n};\nexport const comparatorStartChars = {\n    \"<\": 1,\n    \">\": 1,\n    \"=\": 1\n};\nconst shiftComparator = (s, start) => s.scanner.lookaheadIs(\"=\") ?\n    `${start}${s.scanner.shift()}`\n    : start;\nexport const writeIncompatibleRangeMessage = (l, r) => `Bound kinds ${l} and ${r} are incompatible`;\nexport const getBoundKinds = (comparator, limit, root, boundKind) => {\n    if (root.extends($ark.intrinsic.number)) {\n        if (typeof limit !== \"number\") {\n            return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));\n        }\n        return (comparator === \"==\" ? [\"min\", \"max\"]\n            : comparator[0] === \">\" ? [\"min\"]\n                : [\"max\"]);\n    }\n    if (root.extends($ark.intrinsic.lengthBoundable)) {\n        if (typeof limit !== \"number\") {\n            return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));\n        }\n        return (comparator === \"==\" ? [\"exactLength\"]\n            : comparator[0] === \">\" ? [\"minLength\"]\n                : [\"maxLength\"]);\n    }\n    if (root.extends($ark.intrinsic.Date)) {\n        // allow either numeric or date limits\n        return (comparator === \"==\" ? [\"after\", \"before\"]\n            : comparator[0] === \">\" ? [\"after\"]\n                : [\"before\"]);\n    }\n    return throwParseError(writeUnboundableMessage(root.expression));\n};\nconst openLeftBoundToRoot = (leftBound) => ({\n    rule: isDateLiteral(leftBound.limit) ?\n        extractDateLiteralSource(leftBound.limit)\n        : leftBound.limit,\n    exclusive: leftBound.comparator.length === 1\n});\nexport const parseRightBound = (s, comparator) => {\n    // store the node that will be bounded\n    const previousRoot = s.unsetRoot();\n    const previousScannerIndex = s.scanner.location;\n    s.parseOperand();\n    const limitNode = s.unsetRoot();\n    // after parsing the next operand, use the locations to get the\n    // token from which it was parsed\n    const limitToken = s.scanner.sliceChars(previousScannerIndex, s.scanner.location);\n    s.root = previousRoot;\n    if (!limitNode.hasKind(\"unit\") ||\n        (typeof limitNode.unit !== \"number\" && !(limitNode.unit instanceof Date)))\n        return s.error(writeInvalidLimitMessage(comparator, limitToken, \"right\"));\n    const limit = limitNode.unit;\n    // apply the newly-parsed right bound\n    const exclusive = comparator.length === 1;\n    const boundKinds = getBoundKinds(comparator, typeof limit === \"number\" ? limit : limitToken, previousRoot, \"right\");\n    for (const kind of boundKinds) {\n        s.constrainRoot(kind, comparator === \"==\" ? { rule: limit } : { rule: limit, exclusive });\n    }\n    if (!s.branches.leftBound)\n        return;\n    // if there's an open left bound, perform additional validation and apply it\n    if (!isKeyOf(comparator, maxComparators))\n        return s.error(writeUnpairableComparatorMessage(comparator));\n    const lowerBoundKind = getBoundKinds(s.branches.leftBound.comparator, s.branches.leftBound.limit, previousRoot, \"left\");\n    s.constrainRoot(lowerBoundKind[0], openLeftBoundToRoot(s.branches.leftBound));\n    s.branches.leftBound = null;\n};\nexport const writeInvalidLimitMessage = (comparator, limit, boundKind) => `Comparator ${boundKind === \"left\" ? invertedComparators[comparator] : comparator} must be ${boundKind === \"left\" ? \"preceded\" : \"followed\"} by a corresponding literal (was ${limit})`;\n", "export const parseBrand = (s) => {\n    s.scanner.shiftUntilNonWhitespace();\n    const brandName = s.scanner.shiftUntilNextTerminator();\n    s.root = s.root.brand(brandName);\n};\n", "import { tryParseInteger } from \"@ark/util\";\nexport const parseDivisor = (s) => {\n    const divisorToken = s.scanner.shiftUntilNextTerminator();\n    const divisor = tryParseInteger(divisorToken, {\n        errorOnFail: writeInvalidDivisorMessage(divisorToken)\n    });\n    if (divisor === 0)\n        s.error(writeInvalidDivisorMessage(0));\n    s.root = s.root.constrain(\"divisor\", divisor);\n};\nexport const writeInvalidDivisorMessage = (divisor) => `% operator must be followed by a non-zero integer literal (was ${divisor})`;\n", "import { isKeyOf, whitespaceChars } from \"@ark/util\";\nimport { ArkTypeScanner } from \"../scanner.js\";\nimport { comparatorStartChars, parseBound } from \"./bounds.js\";\nimport { parseBrand } from \"./brand.js\";\nimport { parseDivisor } from \"./divisor.js\";\nexport const parseOperator = (s) => {\n    const lookahead = s.scanner.shift();\n    return (lookahead === \"\" ? s.finalize(\"\")\n        : lookahead === \"[\" ?\n            s.scanner.shift() === \"]\" ?\n                s.setRoot(s.root.array())\n                : s.error(incompleteArrayTokenMessage)\n            : lookahead === \"|\" ?\n                s.scanner.lookahead === \">\" ?\n                    s.shiftedByOne().pushRootToBranch(\"|>\")\n                    : s.pushRootToBranch(lookahead)\n                : lookahead === \"&\" ? s.pushRootToBranch(lookahead)\n                    : lookahead === \")\" ? s.finalizeGroup()\n                        : ArkTypeScanner.lookaheadIsFinalizing(lookahead, s.scanner.unscanned) ?\n                            s.finalize(lookahead)\n                            : isKeyOf(lookahead, comparatorStartChars) ? parseBound(s, lookahead)\n                                : lookahead === \"%\" ? parseDivisor(s)\n                                    : lookahead === \"#\" ? parseBrand(s)\n                                        : lookahead in whitespaceChars ? parseOperator(s)\n                                            : s.error(writeUnexpectedCharacterMessage(lookahead)));\n};\nexport const writeUnexpectedCharacterMessage = (char, shouldBe = \"\") => `'${char}' is not allowed here${shouldBe && ` (should be ${shouldBe})`}`;\nexport const incompleteArrayTokenMessage = `Missing expected ']'`;\n", "export const parseDefault = (s) => {\n    // store the node that will be bounded\n    const baseNode = s.unsetRoot();\n    s.parseOperand();\n    const defaultNode = s.unsetRoot();\n    // after parsing the next operand, use the locations to get the\n    // token from which it was parsed\n    if (!defaultNode.hasKind(\"unit\"))\n        return s.error(writeNonLiteralDefaultMessage(defaultNode.expression));\n    const defaultValue = defaultNode.unit instanceof Date ?\n        () => new Date(defaultNode.unit)\n        : defaultNode.unit;\n    return [baseNode, \"=\", defaultValue];\n};\nexport const writeNonLiteralDefaultMessage = (defaultDef) => `Default value '${defaultDef}' must a literal value`;\n", "import { throwInternalError, throwParseError } from \"@ark/util\";\nimport { DynamicState } from \"./reduce/dynamic.js\";\nimport { parseDefault } from \"./shift/operator/default.js\";\nimport { writeUnexpectedCharacterMessage } from \"./shift/operator/operator.js\";\nimport { ArkTypeScanner } from \"./shift/scanner.js\";\nexport const parseString = (def, ctx) => {\n    const aliasResolution = ctx.$.maybeResolveRoot(def);\n    if (aliasResolution)\n        return aliasResolution;\n    if (def.endsWith(\"[]\")) {\n        const possibleElementResolution = ctx.$.maybeResolveRoot(def.slice(0, -2));\n        if (possibleElementResolution)\n            return possibleElementResolution.array();\n    }\n    const s = new DynamicState(new ArkTypeScanner(def), ctx);\n    const node = fullStringParse(s);\n    if (s.finalizer === \">\")\n        throwParseError(writeUnexpectedCharacterMessage(\">\"));\n    return node;\n};\nexport const fullStringParse = (s) => {\n    s.parseOperand();\n    let result = parseUntilFinalizer(s).root;\n    if (!result) {\n        return throwInternalError(`Root was unexpectedly unset after parsing string '${s.scanner.scanned}'`);\n    }\n    if (s.finalizer === \"=\")\n        result = parseDefault(s);\n    else if (s.finalizer === \"?\")\n        result = [result, \"?\"];\n    s.scanner.shiftUntilNonWhitespace();\n    if (s.scanner.lookahead) {\n        // throw a parse error if non-whitespace characters made it here without being parsed\n        throwParseError(writeUnexpectedCharacterMessage(s.scanner.lookahead));\n    }\n    return result;\n};\nexport const parseUntilFinalizer = (s) => {\n    while (s.finalizer === undefined)\n        next(s);\n    return s;\n};\nconst next = (s) => s.hasRoot() ? s.parseOperator() : s.parseOperand();\n", "import { isKeyOf, throwInternalError, throwParseError } from \"@ark/util\";\nimport { parseOperand } from \"../shift/operand/operand.js\";\nimport { parseOperator } from \"../shift/operator/operator.js\";\nimport { parseUntilFinalizer } from \"../string.js\";\nimport { invertedComparators, minComparators, writeMultipleLeftBoundsMessage, writeOpenRangeMessage, writeUnclosedGroupMessage, writeUnmatchedGroupCloseMessage, writeUnpairableComparatorMessage } from \"./shared.js\";\nexport class DynamicState {\n    // set root type to `any` so that all constraints can be applied\n    root;\n    branches = {\n        prefixes: [],\n        leftBound: null,\n        intersection: null,\n        union: null,\n        pipe: null\n    };\n    finalizer;\n    groups = [];\n    scanner;\n    ctx;\n    constructor(scanner, ctx) {\n        this.scanner = scanner;\n        this.ctx = ctx;\n    }\n    error(message) {\n        return throwParseError(message);\n    }\n    hasRoot() {\n        return this.root !== undefined;\n    }\n    setRoot(root) {\n        this.root = root;\n    }\n    unsetRoot() {\n        const value = this.root;\n        this.root = undefined;\n        return value;\n    }\n    constrainRoot(...args) {\n        this.root = this.root.constrain(args[0], args[1]);\n    }\n    finalize(finalizer) {\n        if (this.groups.length)\n            return this.error(writeUnclosedGroupMessage(\")\"));\n        this.finalizeBranches();\n        this.finalizer = finalizer;\n    }\n    reduceLeftBound(limit, comparator) {\n        const invertedComparator = invertedComparators[comparator];\n        if (!isKeyOf(invertedComparator, minComparators))\n            return this.error(writeUnpairableComparatorMessage(comparator));\n        if (this.branches.leftBound) {\n            return this.error(writeMultipleLeftBoundsMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator, limit, invertedComparator));\n        }\n        this.branches.leftBound = {\n            comparator: invertedComparator,\n            limit\n        };\n    }\n    finalizeBranches() {\n        this.assertRangeUnset();\n        if (this.branches.pipe) {\n            this.pushRootToBranch(\"|>\");\n            this.root = this.branches.pipe;\n            return;\n        }\n        if (this.branches.union) {\n            this.pushRootToBranch(\"|\");\n            this.root = this.branches.union;\n            return;\n        }\n        if (this.branches.intersection) {\n            this.pushRootToBranch(\"&\");\n            this.root = this.branches.intersection;\n            return;\n        }\n        this.applyPrefixes();\n    }\n    finalizeGroup() {\n        this.finalizeBranches();\n        const topBranchState = this.groups.pop();\n        if (!topBranchState)\n            return this.error(writeUnmatchedGroupCloseMessage(this.scanner.unscanned));\n        this.branches = topBranchState;\n    }\n    addPrefix(prefix) {\n        this.branches.prefixes.push(prefix);\n    }\n    applyPrefixes() {\n        while (this.branches.prefixes.length) {\n            const lastPrefix = this.branches.prefixes.pop();\n            this.root =\n                lastPrefix === \"keyof\" ?\n                    this.root.keyof()\n                    : throwInternalError(`Unexpected prefix '${lastPrefix}'`);\n        }\n    }\n    pushRootToBranch(token) {\n        this.assertRangeUnset();\n        this.applyPrefixes();\n        const root = this.root;\n        this.root = undefined;\n        this.branches.intersection =\n            this.branches.intersection?.rawAnd(root) ?? root;\n        if (token === \"&\")\n            return;\n        this.branches.union =\n            this.branches.union?.rawOr(this.branches.intersection) ??\n                this.branches.intersection;\n        this.branches.intersection = null;\n        if (token === \"|\")\n            return;\n        this.branches.pipe =\n            this.branches.pipe?.rawPipeOnce(this.branches.union) ??\n                this.branches.union;\n        this.branches.union = null;\n    }\n    parseUntilFinalizer() {\n        return parseUntilFinalizer(new DynamicState(this.scanner, this.ctx));\n    }\n    parseOperator() {\n        return parseOperator(this);\n    }\n    parseOperand() {\n        return parseOperand(this);\n    }\n    assertRangeUnset() {\n        if (this.branches.leftBound) {\n            return this.error(writeOpenRangeMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator));\n        }\n    }\n    reduceGroupOpen() {\n        this.groups.push(this.branches);\n        this.branches = {\n            prefixes: [],\n            leftBound: null,\n            union: null,\n            intersection: null,\n            pipe: null\n        };\n    }\n    previousOperator() {\n        return (this.branches.leftBound?.comparator ??\n            this.branches.prefixes.at(-1) ??\n            (this.branches.intersection ? \"&\"\n                : this.branches.union ? \"|\"\n                    : this.branches.pipe ? \"|>\"\n                        : undefined));\n    }\n    shiftedByOne() {\n        this.scanner.shift();\n        return this;\n    }\n}\n", "import { GenericRoot } from \"@ark/schema\";\nimport { throwParseError } from \"@ark/util\";\nimport { DynamicState } from \"./parser/reduce/dynamic.js\";\nimport { parseUntilFinalizer } from \"./parser/string.js\";\nexport const Generic = GenericRoot;\nexport const emptyGenericParameterMessage = \"An empty string is not a valid generic parameter name\";\nexport const parseGenericParamName = (scanner, result, ctx) => {\n    scanner.shiftUntilNonWhitespace();\n    const name = scanner.shiftUntilNextTerminator();\n    if (name === \"\") {\n        // if we've reached the end of the string and have parsed at least one\n        // param, return the valid result\n        if (scanner.lookahead === \"\" && result.length)\n            return result;\n        return throwParseError(emptyGenericParameterMessage);\n    }\n    scanner.shiftUntilNonWhitespace();\n    return _parseOptionalConstraint(scanner, name, result, ctx);\n};\nconst extendsToken = \"extends \";\nconst _parseOptionalConstraint = (scanner, name, result, ctx) => {\n    scanner.shiftUntilNonWhitespace();\n    if (scanner.unscanned.startsWith(extendsToken))\n        scanner.jumpForward(extendsToken.length);\n    else {\n        // if we don't have a contraining token here, return now so we can\n        // assume in the rest of the function body we do have a constraint\n        if (scanner.lookahead === \",\")\n            scanner.shift();\n        result.push(name);\n        return parseGenericParamName(scanner, result, ctx);\n    }\n    const s = parseUntilFinalizer(new DynamicState(scanner, ctx));\n    result.push([name, s.root]);\n    return parseGenericParamName(scanner, result, ctx);\n};\n", "import { intrinsic } from \"@ark/schema\";\nimport { Callable, domainOf, throwParseError } from \"@ark/util\";\nexport class InternalMatchParser extends Callable {\n    $;\n    constructor($) {\n        super((...args) => new InternalChainedMatchParser($)(...args), {\n            bind: $\n        });\n        this.$ = $;\n    }\n    in(def) {\n        return new InternalChainedMatchParser(this.$, def === undefined ? undefined : this.$.parse(def));\n    }\n    at(key, cases) {\n        return new InternalChainedMatchParser(this.$).at(key, cases);\n    }\n    case(when, then) {\n        return new InternalChainedMatchParser(this.$).case(when, then);\n    }\n}\nexport class InternalChainedMatchParser extends Callable {\n    $;\n    in;\n    key;\n    branches = [];\n    constructor($, In) {\n        super(cases => this.caseEntries(Object.entries(cases).map(([k, v]) => k === \"default\" ? [k, v] : [this.$.parse(k), v])));\n        this.$ = $;\n        this.in = In;\n    }\n    at(key, cases) {\n        if (this.key)\n            throwParseError(doubleAtMessage);\n        if (this.branches.length)\n            throwParseError(chainedAtMessage);\n        this.key = key;\n        return cases ? this.match(cases) : this;\n    }\n    case(def, resolver) {\n        return this.caseEntry(this.$.parse(def), resolver);\n    }\n    caseEntry(node, resolver) {\n        const wrappableNode = this.key ? this.$.parse({ [this.key]: node }) : node;\n        const branch = wrappableNode.pipe(resolver);\n        this.branches.push(branch);\n        return this;\n    }\n    match(cases) {\n        return this(cases);\n    }\n    strings(cases) {\n        return this.caseEntries(Object.entries(cases).map(([k, v]) => k === \"default\" ?\n            [k, v]\n            : [this.$.node(\"unit\", { unit: k }), v]));\n    }\n    caseEntries(entries) {\n        for (let i = 0; i < entries.length; i++) {\n            const [k, v] = entries[i];\n            if (k === \"default\") {\n                if (i !== entries.length - 1) {\n                    throwParseError(`default may only be specified as the last key of a switch definition`);\n                }\n                return this.default(v);\n            }\n            if (typeof v !== \"function\") {\n                return throwParseError(`Value for case \"${k}\" must be a function (was ${domainOf(v)})`);\n            }\n            this.caseEntry(k, v);\n        }\n        return this;\n    }\n    default(defaultCase) {\n        if (typeof defaultCase === \"function\")\n            this.case(intrinsic.unknown, defaultCase);\n        const schema = {\n            branches: this.branches,\n            ordered: true\n        };\n        if (defaultCase === \"never\" || defaultCase === \"assert\")\n            schema.meta = { onFail: throwOnDefault };\n        const cases = this.$.node(\"union\", schema);\n        if (!this.in)\n            return this.$.finalize(cases);\n        let inputValidatedCases = this.in.pipe(cases);\n        if (defaultCase === \"never\" || defaultCase === \"assert\") {\n            inputValidatedCases = inputValidatedCases.configureReferences({\n                onFail: throwOnDefault\n            }, \"self\");\n        }\n        return this.$.finalize(inputValidatedCases);\n    }\n}\nexport const throwOnDefault = errors => errors.throw();\nexport const chainedAtMessage = `A key matcher must be specified before the first case i.e. match.at('foo') or match.in<object>().at('bar')`;\nexport const doubleAtMessage = `At most one key matcher may be specified per expression`;\n", "import { isArray } from \"@ark/util\";\nimport { parseInnerDefinition } from \"./definition.js\";\nexport const parseProperty = (def, ctx) => {\n    if (isArray(def)) {\n        if (def[1] === \"=\")\n            return [ctx.$.parseOwnDefinitionFormat(def[0], ctx), \"=\", def[2]];\n        if (def[1] === \"?\")\n            return [ctx.$.parseOwnDefinitionFormat(def[0], ctx), \"?\"];\n    }\n    // string-embedded defaults/optionals are handled by the string parser\n    return parseInnerDefinition(def, ctx);\n};\n// single quote use here is better for TypeScript's inlined error to avoid escapes\nexport const invalidOptionalKeyKindMessage = `Only required keys may make their values optional, e.g. { [mySymbol]: ['number', '?'] }`;\n// single quote use here is better for TypeScript's inlined error to avoid escapes\nexport const invalidDefaultableKeyKindMessage = `Only required keys may specify default values, e.g. { value: 'number = 0' }`;\n", "import { intrinsic, normalizeIndex } from \"@ark/schema\";\nimport { append, escapeChar, isArray, isEmptyObject, printable, stringAndSymbolicEntriesOf, throwParseError } from \"@ark/util\";\nimport { invalidDefaultableKeyKindMessage, invalidOptionalKeyKindMessage, parseProperty } from \"./property.js\";\nexport const parseObjectLiteral = (def, ctx) => {\n    let spread;\n    const structure = {};\n    // We only allow a spread operator to be used as the first key in an object\n    // because to match JS behavior any keys before the spread are overwritten\n    // by the values in the target object, so there'd be no useful purpose in having it\n    // anywhere except for the beginning.\n    const defEntries = stringAndSymbolicEntriesOf(def);\n    for (const [k, v] of defEntries) {\n        const parsedKey = preparseKey(k);\n        if (parsedKey.kind === \"spread\") {\n            if (!isEmptyObject(structure))\n                return throwParseError(nonLeadingSpreadError);\n            const operand = ctx.$.parseOwnDefinitionFormat(v, ctx);\n            // treat object domain as empty for spreading (useful for generic constraints)\n            if (operand.equals(intrinsic.object))\n                continue;\n            if (!operand.hasKind(\"intersection\") ||\n                // still error on attempts to spread proto nodes like ...Date\n                !operand.basis?.equals(intrinsic.object)) {\n                return throwParseError(writeInvalidSpreadTypeMessage(operand.expression));\n            }\n            spread = operand.structure;\n            continue;\n        }\n        if (parsedKey.kind === \"undeclared\") {\n            if (v !== \"reject\" && v !== \"delete\" && v !== \"ignore\")\n                throwParseError(writeInvalidUndeclaredBehaviorMessage(v));\n            structure.undeclared = v;\n            continue;\n        }\n        const parsedValue = parseProperty(v, ctx);\n        const parsedEntryKey = parsedKey;\n        if (parsedKey.kind === \"required\") {\n            if (!isArray(parsedValue)) {\n                appendNamedProp(structure, \"required\", {\n                    key: parsedKey.normalized,\n                    value: parsedValue\n                }, ctx);\n            }\n            else {\n                appendNamedProp(structure, \"optional\", parsedValue[1] === \"=\" ?\n                    {\n                        key: parsedKey.normalized,\n                        value: parsedValue[0],\n                        default: parsedValue[2]\n                    }\n                    : {\n                        key: parsedKey.normalized,\n                        value: parsedValue[0]\n                    }, ctx);\n            }\n            continue;\n        }\n        if (isArray(parsedValue)) {\n            if (parsedValue[1] === \"?\")\n                throwParseError(invalidOptionalKeyKindMessage);\n            if (parsedValue[1] === \"=\")\n                throwParseError(invalidDefaultableKeyKindMessage);\n        }\n        // value must be a BaseRoot at this point\n        if (parsedKey.kind === \"optional\") {\n            appendNamedProp(structure, \"optional\", {\n                key: parsedKey.normalized,\n                value: parsedValue\n            }, ctx);\n            continue;\n        }\n        // must be index at this point\n        const signature = ctx.$.parseOwnDefinitionFormat(parsedEntryKey.normalized, ctx);\n        const normalized = normalizeIndex(signature, parsedValue, ctx.$);\n        if (normalized.index)\n            structure.index = append(structure.index, normalized.index);\n        if (normalized.required)\n            structure.required = append(structure.required, normalized.required);\n    }\n    const structureNode = ctx.$.node(\"structure\", structure);\n    return ctx.$.parseSchema({\n        domain: \"object\",\n        structure: spread?.merge(structureNode) ?? structureNode\n    });\n};\nconst appendNamedProp = (structure, kind, inner, ctx) => {\n    structure[kind] = append(\n    // doesn't seem like this cast should be necessary\n    structure[kind], ctx.$.node(kind, inner));\n};\nexport const writeInvalidUndeclaredBehaviorMessage = (actual) => `Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${printable(actual)})`;\nexport const nonLeadingSpreadError = \"Spread operator may only be used as the first key in an object\";\nexport const preparseKey = (key) => typeof key === \"symbol\" ? { kind: \"required\", normalized: key }\n    : key.at(-1) === \"?\" ?\n        key.at(-2) === escapeChar ?\n            { kind: \"required\", normalized: `${key.slice(0, -2)}?` }\n            : {\n                kind: \"optional\",\n                normalized: key.slice(0, -1)\n            }\n        : key[0] === \"[\" && key.at(-1) === \"]\" ?\n            { kind: \"index\", normalized: key.slice(1, -1) }\n            : key[0] === escapeChar && key[1] === \"[\" && key.at(-1) === \"]\" ?\n                { kind: \"required\", normalized: key.slice(1) }\n                : key === \"...\" ? { kind: \"spread\" }\n                    : key === \"+\" ? { kind: \"undeclared\" }\n                        : {\n                            kind: \"required\",\n                            normalized: key === \"\\\\...\" ? \"...\"\n                                : key === \"\\\\+\" ? \"+\"\n                                    : key\n                        };\nexport const writeInvalidSpreadTypeMessage = (def) => `Spread operand must resolve to an object literal type (was ${def})`;\n", "import { Disjoint, intersectNodesRoot, pipeNodesRoot } from \"@ark/schema\";\nimport { objectKindOrDomainOf, throwParseError } from \"@ark/util\";\nimport { shallowDefaultableMessage, shallowOptionalMessage } from \"./ast/validate.js\";\nimport { writeMissingRightOperandMessage } from \"./shift/operand/unenclosed.js\";\nexport const maybeParseTupleExpression = (def, ctx) => isIndexZeroExpression(def) ? indexZeroParsers[def[0]](def, ctx)\n    : isIndexOneExpression(def) ? indexOneParsers[def[1]](def, ctx)\n        : null;\nexport const parseKeyOfTuple = (def, ctx) => ctx.$.parseOwnDefinitionFormat(def[1], ctx).keyof();\nconst parseBranchTuple = (def, ctx) => {\n    if (def[2] === undefined)\n        return throwParseError(writeMissingRightOperandMessage(def[1], \"\"));\n    const l = ctx.$.parseOwnDefinitionFormat(def[0], ctx);\n    const r = ctx.$.parseOwnDefinitionFormat(def[2], ctx);\n    if (def[1] === \"|\")\n        return ctx.$.node(\"union\", { branches: [l, r] });\n    const result = def[1] === \"&\" ?\n        intersectNodesRoot(l, r, ctx.$)\n        : pipeNodesRoot(l, r, ctx.$);\n    if (result instanceof Disjoint)\n        return result.throw();\n    return result;\n};\nconst parseArrayTuple = (def, ctx) => ctx.$.parseOwnDefinitionFormat(def[0], ctx).array();\nexport const parseMorphTuple = (def, ctx) => {\n    if (typeof def[2] !== \"function\") {\n        return throwParseError(writeMalformedFunctionalExpressionMessage(\"=>\", def[2]));\n    }\n    return ctx.$.parseOwnDefinitionFormat(def[0], ctx).pipe(def[2]);\n};\nexport const writeMalformedFunctionalExpressionMessage = (operator, value) => `${operator === \":\" ? \"Narrow\" : \"Morph\"} expression requires a function following '${operator}' (was ${typeof value})`;\nexport const parseNarrowTuple = (def, ctx) => {\n    if (typeof def[2] !== \"function\") {\n        return throwParseError(writeMalformedFunctionalExpressionMessage(\":\", def[2]));\n    }\n    return ctx.$.parseOwnDefinitionFormat(def[0], ctx).constrain(\"predicate\", def[2]);\n};\nconst parseAttributeTuple = (def, ctx) => ctx.$.parseOwnDefinitionFormat(def[0], ctx).configureReferences(def[2], \"shallow\");\nconst defineIndexOneParsers = (parsers) => parsers;\nconst postfixParsers = defineIndexOneParsers({\n    \"[]\": parseArrayTuple,\n    \"?\": () => throwParseError(shallowOptionalMessage)\n});\nconst infixParsers = defineIndexOneParsers({\n    \"|\": parseBranchTuple,\n    \"&\": parseBranchTuple,\n    \":\": parseNarrowTuple,\n    \"=>\": parseMorphTuple,\n    \"|>\": parseBranchTuple,\n    \"@\": parseAttributeTuple,\n    // since object and tuple literals parse there via `parseProperty`,\n    // they must be shallow if parsed directly as a tuple expression\n    \"=\": () => throwParseError(shallowDefaultableMessage)\n});\nconst indexOneParsers = { ...postfixParsers, ...infixParsers };\nconst isIndexOneExpression = (def) => indexOneParsers[def[1]] !== undefined;\nconst defineIndexZeroParsers = (parsers) => parsers;\nconst indexZeroParsers = defineIndexZeroParsers({\n    keyof: parseKeyOfTuple,\n    instanceof: (def, ctx) => {\n        if (typeof def[1] !== \"function\") {\n            return throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(def[1])));\n        }\n        const branches = def\n            .slice(1)\n            .map(ctor => typeof ctor === \"function\" ?\n            ctx.$.node(\"proto\", { proto: ctor })\n            : throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(ctor))));\n        return branches.length === 1 ?\n            branches[0]\n            : ctx.$.node(\"union\", { branches });\n    },\n    \"===\": (def, ctx) => ctx.$.units(def.slice(1))\n});\nconst isIndexZeroExpression = (def) => indexZeroParsers[def[0]] !== undefined;\nexport const writeInvalidConstructorMessage = (actual) => `Expected a constructor following 'instanceof' operator (was ${actual})`;\n", "import { $ark, makeRootAndArrayPropertiesMutable, postfixAfterOptionalOrDefaultableMessage } from \"@ark/schema\";\nimport { append, isArray, isEmptyObject, throwParseError } from \"@ark/util\";\nimport { parseProperty } from \"./property.js\";\nexport const parseTupleLiteral = (def, ctx) => {\n    let sequences = [{}];\n    let i = 0;\n    while (i < def.length) {\n        let spread = false;\n        if (def[i] === \"...\" && i < def.length - 1) {\n            spread = true;\n            i++;\n        }\n        const parsedProperty = parseProperty(def[i], ctx);\n        const [valueNode, operator, possibleDefaultValue] = !isArray(parsedProperty) ? [parsedProperty] : parsedProperty;\n        i++;\n        if (spread) {\n            if (!valueNode.extends($ark.intrinsic.Array))\n                return throwParseError(writeNonArraySpreadMessage(valueNode.expression));\n            // a spread must be distributed over branches e.g.:\n            // def: [string, ...(number[] | [true, false])]\n            // nodes: [string, ...number[]] | [string, true, false]\n            sequences = sequences.flatMap(base => \n            // since appendElement mutates base, we have to shallow-ish clone it for each branch\n            valueNode.distribute(branch => appendSpreadBranch(makeRootAndArrayPropertiesMutable(base), branch)));\n        }\n        else {\n            sequences = sequences.map(base => {\n                if (operator === \"?\")\n                    return appendOptionalElement(base, valueNode);\n                if (operator === \"=\")\n                    return appendDefaultableElement(base, valueNode, possibleDefaultValue);\n                return appendRequiredElement(base, valueNode);\n            });\n        }\n    }\n    return ctx.$.parseSchema(sequences.map(sequence => isEmptyObject(sequence) ?\n        {\n            proto: Array,\n            exactLength: 0\n        }\n        : {\n            proto: Array,\n            sequence\n        }));\n};\nconst appendRequiredElement = (base, element) => {\n    if (base.defaultables || base.optionals) {\n        return throwParseError(base.variadic ?\n            // e.g. [boolean = true, ...string[], number]\n            postfixAfterOptionalOrDefaultableMessage\n            // e.g. [string?, number]\n            : requiredPostOptionalMessage);\n    }\n    if (base.variadic) {\n        // e.g. [...string[], number]\n        base.postfix = append(base.postfix, element);\n    }\n    else {\n        // e.g. [string, number]\n        base.prefix = append(base.prefix, element);\n    }\n    return base;\n};\nconst appendOptionalElement = (base, element) => {\n    if (base.variadic)\n        // e.g. [...string[], number?]\n        return throwParseError(optionalOrDefaultableAfterVariadicMessage);\n    // e.g. [string, number?]\n    base.optionals = append(base.optionals, element);\n    return base;\n};\nconst appendDefaultableElement = (base, element, value) => {\n    if (base.variadic)\n        // e.g. [...string[], number = 0]\n        return throwParseError(optionalOrDefaultableAfterVariadicMessage);\n    if (base.optionals)\n        // e.g. [string?, number = 0]\n        return throwParseError(defaultablePostOptionalMessage);\n    // value's assignability to element will be checked when the\n    // sequence is instantiated by @ark/schema\n    // e.g. [string, number = 0]\n    base.defaultables = append(base.defaultables, [[element, value]]);\n    return base;\n};\nconst appendVariadicElement = (base, element) => {\n    // e.g. [...string[], number, ...string[]]\n    if (base.postfix)\n        throwParseError(multipleVariadicMesage);\n    if (base.variadic) {\n        if (!base.variadic.equals(element)) {\n            // e.g. [...string[], ...number[]]\n            throwParseError(multipleVariadicMesage);\n        }\n        // e.g. [...string[], ...string[]]\n        // do nothing, second spread doesn't change the type\n    }\n    else {\n        // e.g. [string, ...number[]]\n        base.variadic = element.internal;\n    }\n    return base;\n};\nconst appendSpreadBranch = (base, branch) => {\n    const spread = branch.select({ method: \"find\", kind: \"sequence\" });\n    if (!spread) {\n        // the only array with no sequence reference is unknown[]\n        return appendVariadicElement(base, $ark.intrinsic.unknown);\n    }\n    if (spread.prefix)\n        for (const node of spread.prefix)\n            appendRequiredElement(base, node);\n    if (spread.optionals)\n        for (const node of spread.optionals)\n            appendOptionalElement(base, node);\n    if (spread.variadic)\n        appendVariadicElement(base, spread.variadic);\n    if (spread.postfix)\n        for (const node of spread.postfix)\n            appendRequiredElement(base, node);\n    return base;\n};\nexport const writeNonArraySpreadMessage = (operand) => `Spread element must be an array (was ${operand})`;\nexport const multipleVariadicMesage = \"A tuple may have at most one variadic element\";\nexport const requiredPostOptionalMessage = \"A required element may not follow an optional element\";\nexport const optionalOrDefaultableAfterVariadicMessage = \"An optional element may not follow a variadic element\";\nexport const spreadOptionalMessage = \"A spread element cannot be optional\";\nexport const spreadDefaultableMessage = \"A spread element cannot have a default\";\nexport const defaultablePostOptionalMessage = \"A defaultable element may not follow an optional element without a default\";\n", "import { hasArkKind } from \"@ark/schema\";\nimport { domainOf, hasDomain, isThunk, objectKindOf, printable, throwParseError } from \"@ark/util\";\nimport { parseObjectLiteral } from \"./objectLiteral.js\";\nimport { parseString } from \"./string.js\";\nimport { maybeParseTupleExpression } from \"./tupleExpressions.js\";\nimport { parseTupleLiteral } from \"./tupleLiteral.js\";\nconst parseCache = {};\nexport const parseInnerDefinition = (def, ctx) => {\n    if (typeof def === \"string\") {\n        if (ctx.args && Object.keys(ctx.args).some(k => def.includes(k))) {\n            // we can only rely on the cache if there are no contextual\n            // resolutions like \"this\" or generic args\n            return parseString(def, ctx);\n        }\n        const scopeCache = (parseCache[ctx.$.name] ??= {});\n        return (scopeCache[def] ??= parseString(def, ctx));\n    }\n    return hasDomain(def, \"object\") ?\n        parseObject(def, ctx)\n        : throwParseError(writeBadDefinitionTypeMessage(domainOf(def)));\n};\nexport const parseObject = (def, ctx) => {\n    const objectKind = objectKindOf(def);\n    switch (objectKind) {\n        case undefined:\n            if (hasArkKind(def, \"root\"))\n                return def;\n            return parseObjectLiteral(def, ctx);\n        case \"Array\":\n            return parseTuple(def, ctx);\n        case \"RegExp\":\n            return ctx.$.node(\"intersection\", {\n                domain: \"string\",\n                pattern: def\n            }, { prereduced: true });\n        case \"Function\": {\n            const resolvedDef = isThunk(def) ? def() : def;\n            if (hasArkKind(resolvedDef, \"root\"))\n                return resolvedDef;\n            return throwParseError(writeBadDefinitionTypeMessage(\"Function\"));\n        }\n        default:\n            return throwParseError(writeBadDefinitionTypeMessage(objectKind ?? printable(def)));\n    }\n};\nexport const parseTuple = (def, ctx) => maybeParseTupleExpression(def, ctx) ?? parseTupleLiteral(def, ctx);\nexport const writeBadDefinitionTypeMessage = (actual) => `Type definitions must be strings or objects (was ${actual})`;\n", "import { ArkErrors, BaseRoot, GenericRoot } from \"@ark/schema\";\nimport { Callable, Hkt } from \"@ark/util\";\nexport class InternalTypeParser extends Callable {\n    constructor($) {\n        const attach = Object.assign({\n            errors: ArkErrors,\n            hkt: Hkt,\n            $: $,\n            raw: $.parse,\n            module: $.constructor.module,\n            scope: $.constructor.scope,\n            define: $.define,\n            match: $.match,\n            generic: $.generic,\n            schema: $.schema,\n            // this won't be defined during bootstrapping, but externally always will be\n            keywords: $.ambient,\n            unit: $.unit,\n            enumerated: $.enumerated,\n            instanceOf: $.instanceOf,\n            valueOf: $.valueOf,\n            or: $.or,\n            and: $.and,\n            merge: $.merge,\n            pipe: $.pipe\n        }, \n        // also won't be defined during bootstrapping\n        $.ambientAttachments);\n        super((...args) => {\n            if (args.length === 1) {\n                // treat as a simple definition\n                return $.parse(args[0]);\n            }\n            if (args.length === 2 &&\n                typeof args[0] === \"string\" &&\n                args[0][0] === \"<\" &&\n                args[0].at(-1) === \">\") {\n                // if there are exactly two args, the first of which looks like <${string}>,\n                // treat as a generic\n                const paramString = args[0].slice(1, -1);\n                const params = $.parseGenericParams(paramString, {});\n                return new GenericRoot(params, args[1], $, $, null);\n            }\n            // otherwise, treat as a tuple expression. technically, this also allows\n            // non-expression tuple definitions to be parsed, but it's not a supported\n            // part of the API as specified by the associated types\n            return $.parse(args);\n        }, {\n            bind: $,\n            attach\n        });\n    }\n}\nexport const Type = BaseRoot;\n", "import { $ark, BaseScope, hasArkKind, parseGeneric } from \"@ark/schema\";\nimport { enumValues, flatMorph, isArray, isThunk, throwParseError } from \"@ark/util\";\nimport { parseGenericParamName } from \"./generic.js\";\nimport { InternalMatchParser } from \"./match.js\";\nimport { shallowDefaultableMessage, shallowOptionalMessage } from \"./parser/ast/validate.js\";\nimport { parseInnerDefinition } from \"./parser/definition.js\";\nimport { ArkTypeScanner } from \"./parser/shift/scanner.js\";\nimport { InternalTypeParser } from \"./type.js\";\nexport const $arkTypeRegistry = $ark;\nexport class InternalScope extends BaseScope {\n    get ambientAttachments() {\n        if (!$arkTypeRegistry.typeAttachments)\n            return;\n        return this.cacheGetter(\"ambientAttachments\", flatMorph($arkTypeRegistry.typeAttachments, (k, v) => [\n            k,\n            this.bindReference(v)\n        ]));\n    }\n    preparseOwnAliasEntry(alias, def) {\n        const firstParamIndex = alias.indexOf(\"<\");\n        if (firstParamIndex === -1) {\n            if (hasArkKind(def, \"module\") || hasArkKind(def, \"generic\"))\n                return [alias, def];\n            const qualifiedName = this.name === \"ark\" ? alias\n                : alias === \"root\" ? this.name\n                    : `${this.name}.${alias}`;\n            const config = this.resolvedConfig.keywords?.[qualifiedName];\n            if (config)\n                def = [def, \"@\", config];\n            return [alias, def];\n        }\n        if (alias.at(-1) !== \">\") {\n            throwParseError(`'>' must be the last character of a generic declaration in a scope`);\n        }\n        const name = alias.slice(0, firstParamIndex);\n        const paramString = alias.slice(firstParamIndex + 1, -1);\n        return [\n            name,\n            // use a thunk definition for the generic so that we can parse\n            // constraints within the current scope\n            () => {\n                const params = this.parseGenericParams(paramString, { alias: name });\n                const generic = parseGeneric(params, def, this);\n                return generic;\n            }\n        ];\n    }\n    parseGenericParams(def, opts) {\n        return parseGenericParamName(new ArkTypeScanner(def), [], this.createParseContext({\n            ...opts,\n            def,\n            prefix: \"generic\"\n        }));\n    }\n    normalizeRootScopeValue(resolution) {\n        if (isThunk(resolution) && !hasArkKind(resolution, \"generic\"))\n            return resolution();\n        return resolution;\n    }\n    preparseOwnDefinitionFormat(def, opts) {\n        return {\n            ...opts,\n            def,\n            prefix: opts.alias ?? \"type\"\n        };\n    }\n    parseOwnDefinitionFormat(def, ctx) {\n        const isScopeAlias = ctx.alias && ctx.alias in this.aliases;\n        // if the definition being parsed is not a scope alias and is not a\n        // generic instantiation (i.e. opts don't include args), add `this` as a resolution.\n        // if we're parsing a nested string, ctx.args will have already been set\n        if (!isScopeAlias && !ctx.args)\n            ctx.args = { this: ctx.id };\n        const result = parseInnerDefinition(def, ctx);\n        if (isArray(result)) {\n            if (result[1] === \"=\")\n                return throwParseError(shallowDefaultableMessage);\n            if (result[1] === \"?\")\n                return throwParseError(shallowOptionalMessage);\n        }\n        return result;\n    }\n    unit = value => this.units([value]);\n    valueOf = tsEnum => this.units(enumValues(tsEnum));\n    enumerated = (...values) => this.units(values);\n    instanceOf = ctor => this.node(\"proto\", { proto: ctor }, { prereduced: true });\n    or = (...defs) => this.schema(defs.map(def => this.parse(def)));\n    and = (...defs) => defs.reduce((node, def) => node.and(this.parse(def)), this.intrinsic.unknown);\n    merge = (...defs) => defs.reduce((node, def) => node.merge(this.parse(def)), this.intrinsic.object);\n    pipe = (...morphs) => this.intrinsic.unknown.pipe(...morphs);\n    match = new InternalMatchParser(this);\n    declare = () => ({\n        type: this.type\n    });\n    define(def) {\n        return def;\n    }\n    type = new InternalTypeParser(this);\n    static scope = ((def, config = {}) => new InternalScope(def, config));\n    static module = ((def, config = {}) => this.scope(def, config).export());\n}\nexport const scope = Object.assign(InternalScope.scope, {\n    define: def => def\n});\nexport const Scope = InternalScope;\n", "import { genericNode, intrinsic } from \"@ark/schema\";\nimport { Hkt } from \"@ark/util\";\nimport { Scope } from \"../scope.js\";\nclass MergeHkt extends Hkt {\n    description = 'merge an object\\'s properties onto another like `Merge(User, { isAdmin: \"true\" })`';\n}\nconst Merge = genericNode([\"base\", intrinsic.object], [\"props\", intrinsic.object])(args => args.base.merge(args.props), MergeHkt);\nexport const arkBuiltins = Scope.module({\n    Key: intrinsic.key,\n    Merge\n});\n", "import { genericNode, intrinsic, rootSchema } from \"@ark/schema\";\nimport { Hkt, liftArray } from \"@ark/util\";\nimport { Scope } from \"../scope.js\";\nclass liftFromHkt extends Hkt {\n}\nconst liftFrom = genericNode(\"element\")(args => {\n    const nonArrayElement = args.element.exclude(intrinsic.Array);\n    const lifted = nonArrayElement.array();\n    return nonArrayElement\n        .rawOr(lifted)\n        .pipe(liftArray)\n        .distribute(branch => branch.assertHasKind(\"morph\").declareOut(lifted), rootSchema);\n}, liftFromHkt);\nexport const arkArray = Scope.module({\n    root: intrinsic.Array,\n    readonly: \"root\",\n    index: intrinsic.nonNegativeIntegerString,\n    liftFrom\n}, {\n    name: \"Array\"\n});\n", "import { rootSchema } from \"@ark/schema\";\nimport { registry } from \"@ark/util\";\nimport { Scope } from \"../scope.js\";\nconst value = rootSchema([\"string\", registry.FileConstructor]);\nconst parsedFormDataValue = value.rawOr(value.array());\nconst parsed = rootSchema({\n    meta: \"an object representing parsed form data\",\n    domain: \"object\",\n    index: {\n        signature: \"string\",\n        value: parsedFormDataValue\n    }\n});\nexport const arkFormData = Scope.module({\n    root: [\"instanceof\", FormData],\n    value,\n    parsed,\n    parse: rootSchema({\n        in: FormData,\n        morphs: (data) => {\n            const result = {};\n            for (const [k, v] of data) {\n                if (k in result) {\n                    const existing = result[k];\n                    if (typeof existing === \"string\" ||\n                        existing instanceof registry.FileConstructor)\n                        result[k] = [existing, v];\n                    else\n                        existing.push(v);\n                }\n                else\n                    result[k] = v;\n            }\n            return result;\n        },\n        declaredOut: parsed\n    })\n}, {\n    name: \"FormData\"\n});\n", "import { Scope } from \"../scope.js\";\nexport const TypedArray = Scope.module({\n    Int8: [\"instanceof\", Int8Array],\n    Uint8: [\"instanceof\", Uint8Array],\n    Uint8Clamped: [\"instanceof\", Uint8ClampedArray],\n    Int16: [\"instanceof\", Int16Array],\n    Uint16: [\"instanceof\", Uint16Array],\n    Int32: [\"instanceof\", Int32Array],\n    Uint32: [\"instanceof\", Uint32Array],\n    Float32: [\"instanceof\", Float32Array],\n    Float64: [\"instanceof\", Float64Array],\n    BigInt64: [\"instanceof\", BigInt64Array],\n    BigUint64: [\"instanceof\", BigUint64Array]\n}, {\n    name: \"TypedArray\"\n});\n", "import { ecmascriptConstructors, flatMorph, platformConstructors } from \"@ark/util\";\nimport { Scope } from \"../scope.js\";\nimport { arkArray } from \"./Array.js\";\nimport { arkFormData } from \"./FormData.js\";\nimport { TypedArray } from \"./TypedArray.js\";\nconst omittedPrototypes = {\n    Boolean: 1,\n    Number: 1,\n    String: 1\n};\nexport const arkPrototypes = Scope.module({\n    ...flatMorph({ ...ecmascriptConstructors, ...platformConstructors }, (k, v) => (k in omittedPrototypes ? [] : [k, [\"instanceof\", v]])),\n    Array: arkArray,\n    TypedArray,\n    FormData: arkFormData\n});\n", "import { intrinsic, rootSchema } from \"@ark/schema\";\nimport { Scope } from \"../scope.js\";\n/**\n * As per the ECMA-262 specification:\n * A time value supports a slightly smaller range of -8,640,000,000,000,000 to 8,640,000,000,000,000 milliseconds.\n *\n * @see https://262.ecma-international.org/15.0/index.html#sec-time-values-and-time-range\n */\nexport const epoch = rootSchema({\n    domain: {\n        domain: \"number\",\n        meta: \"a number representing a Unix timestamp\"\n    },\n    divisor: {\n        rule: 1,\n        meta: `an integer representing a Unix timestamp`\n    },\n    min: {\n        rule: -8640000000000000,\n        meta: `a Unix timestamp after -8640000000000000`\n    },\n    max: {\n        rule: 8640000000000000,\n        meta: \"a Unix timestamp before 8640000000000000\"\n    },\n    meta: \"an integer representing a safe Unix timestamp\"\n});\nexport const integer = rootSchema({\n    domain: \"number\",\n    divisor: 1\n});\nexport const number = Scope.module({\n    root: intrinsic.number,\n    integer,\n    epoch,\n    safe: rootSchema({\n        domain: {\n            domain: \"number\",\n            numberAllowsNaN: false\n        },\n        min: Number.MIN_SAFE_INTEGER,\n        max: Number.MAX_SAFE_INTEGER\n    }),\n    NaN: [\"===\", Number.NaN],\n    Infinity: [\"===\", Number.POSITIVE_INFINITY],\n    NegativeInfinity: [\"===\", Number.NEGATIVE_INFINITY]\n}, {\n    name: \"number\"\n});\n", "import { ArkErrors, intrinsic, node, rootSchema } from \"@ark/schema\";\nimport { flatMorph, numericStringMatcher, wellFormedIntegerMatcher } from \"@ark/util\";\nimport { Scope } from \"../scope.js\";\nimport { number } from \"./number.js\";\n// non-trivial expressions should have an explanation or attribution\nexport const regexStringNode = (regex, description, jsonSchemaFormat) => {\n    const schema = {\n        domain: \"string\",\n        pattern: {\n            rule: regex.source,\n            flags: regex.flags,\n            meta: description\n        }\n    };\n    if (jsonSchemaFormat)\n        schema.meta = { format: jsonSchemaFormat };\n    return node(\"intersection\", schema);\n};\nconst stringIntegerRoot = regexStringNode(wellFormedIntegerMatcher, \"a well-formed integer string\");\nexport const stringInteger = Scope.module({\n    root: stringIntegerRoot,\n    parse: rootSchema({\n        in: stringIntegerRoot,\n        morphs: (s, ctx) => {\n            const parsed = Number.parseInt(s);\n            return Number.isSafeInteger(parsed) ? parsed : (ctx.error(\"an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER\"));\n        },\n        declaredOut: intrinsic.integer\n    })\n}, {\n    name: \"string.integer\"\n});\nconst hex = regexStringNode(/^[\\dA-Fa-f]+$/, \"hex characters only\");\nconst base64 = Scope.module({\n    root: regexStringNode(/^(?:[\\d+/A-Za-z]{4})*(?:[\\d+/A-Za-z]{2}==|[\\d+/A-Za-z]{3}=)?$/, \"base64-encoded\"),\n    url: regexStringNode(/^(?:[\\w-]{4})*(?:[\\w-]{2}(?:==|%3D%3D)?|[\\w-]{3}(?:=|%3D)?)?$/, \"base64url-encoded\")\n}, {\n    name: \"string.base64\"\n});\nconst preformattedCapitalize = regexStringNode(/^[A-Z].*$/, \"capitalized\");\nexport const capitalize = Scope.module({\n    root: rootSchema({\n        in: \"string\",\n        morphs: (s) => s.charAt(0).toUpperCase() + s.slice(1),\n        declaredOut: preformattedCapitalize\n    }),\n    preformatted: preformattedCapitalize\n}, {\n    name: \"string.capitalize\"\n});\n// https://github.com/validatorjs/validator.js/blob/master/src/lib/isLuhnNumber.js\nexport const isLuhnValid = (creditCardInput) => {\n    const sanitized = creditCardInput.replaceAll(/[ -]+/g, \"\");\n    let sum = 0;\n    let digit;\n    let tmpNum;\n    let shouldDouble = false;\n    for (let i = sanitized.length - 1; i >= 0; i--) {\n        digit = sanitized.substring(i, i + 1);\n        tmpNum = Number.parseInt(digit, 10);\n        if (shouldDouble) {\n            tmpNum *= 2;\n            sum += tmpNum >= 10 ? (tmpNum % 10) + 1 : tmpNum;\n        }\n        else\n            sum += tmpNum;\n        shouldDouble = !shouldDouble;\n    }\n    return !!(sum % 10 === 0 ? sanitized : false);\n};\n// https://github.com/validatorjs/validator.js/blob/master/src/lib/isCreditCard.js\nconst creditCardMatcher = /^(?:4\\d{12}(?:\\d{3,6})?|5[1-5]\\d{14}|(222[1-9]|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}|6(?:011|5\\d\\d)\\d{12,15}|3[47]\\d{13}|3(?:0[0-5]|[68]\\d)\\d{11}|(?:2131|1800|35\\d{3})\\d{11}|6[27]\\d{14}|^(81\\d{14,17}))$/;\nexport const creditCard = rootSchema({\n    domain: \"string\",\n    pattern: {\n        meta: \"a credit card number\",\n        rule: creditCardMatcher.source\n    },\n    predicate: {\n        meta: \"a credit card number\",\n        predicate: isLuhnValid\n    }\n});\nconst dayDelimiterMatcher = /^[./-]$/;\n// ISO 8601 date/time modernized from https://github.com/validatorjs/validator.js/blob/master/src/lib/isISO8601.js\n// Based on https://tc39.es/ecma262/#sec-date-time-string-format, the T\n// delimiter for date/time is mandatory. Regex from validator.js strict matcher:\nexport const iso8601Matcher = /^([+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))(T((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([,.]\\d+(?!:))?)?(\\17[0-5]\\d([,.]\\d+)?)?([Zz]|([+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\nconst isValidDateInstance = (date) => !Number.isNaN(+date);\nconst writeFormattedExpected = (format) => `a ${format}-formatted date`;\nexport const tryParseDatePattern = (data, opts) => {\n    if (!opts?.format) {\n        const result = new Date(data);\n        return isValidDateInstance(result) ? result : \"a valid date\";\n    }\n    if (opts.format === \"iso\") {\n        return iso8601Matcher.test(data) ?\n            new Date(data)\n            : writeFormattedExpected(\"iso\");\n    }\n    const dataParts = data.split(dayDelimiterMatcher);\n    // will be the first delimiter matched, if there is one\n    const delimiter = data[dataParts[0].length];\n    const formatParts = delimiter ? opts.format.split(delimiter) : [opts.format];\n    if (dataParts.length !== formatParts.length)\n        return writeFormattedExpected(opts.format);\n    const parsedParts = {};\n    for (let i = 0; i < formatParts.length; i++) {\n        if (dataParts[i].length !== formatParts[i].length &&\n            // if format is \"m\" or \"d\", data is allowed to be 1 or 2 characters\n            !(formatParts[i].length === 1 && dataParts[i].length === 2))\n            return writeFormattedExpected(opts.format);\n        parsedParts[formatParts[i][0]] = dataParts[i];\n    }\n    const date = new Date(`${parsedParts.m}/${parsedParts.d}/${parsedParts.y}`);\n    if (`${date.getDate()}` === parsedParts.d)\n        return date;\n    return writeFormattedExpected(opts.format);\n};\nconst isParsableDate = (s) => !Number.isNaN(new Date(s).valueOf());\nconst parsableDate = rootSchema({\n    domain: \"string\",\n    predicate: {\n        meta: \"a parsable date\",\n        predicate: isParsableDate\n    }\n}).assertHasKind(\"intersection\");\nconst epochRoot = stringInteger.root.internal\n    .narrow((s, ctx) => {\n    // this is safe since it has already\n    // been validated as an integer string\n    const n = Number.parseInt(s);\n    const out = number.epoch(n);\n    if (out instanceof ArkErrors) {\n        ctx.errors.merge(out);\n        return false;\n    }\n    return true;\n})\n    .configure({\n    description: \"an integer string representing a safe Unix timestamp\"\n}, \"self\")\n    .assertHasKind(\"intersection\");\nconst epoch = Scope.module({\n    root: epochRoot,\n    parse: rootSchema({\n        in: epochRoot,\n        morphs: (s) => new Date(s),\n        declaredOut: intrinsic.Date\n    })\n}, {\n    name: \"string.date.epoch\"\n});\nconst isoRoot = regexStringNode(iso8601Matcher, \"an ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) date\").internal.assertHasKind(\"intersection\");\nconst iso = Scope.module({\n    root: isoRoot,\n    parse: rootSchema({\n        in: isoRoot,\n        morphs: (s) => new Date(s),\n        declaredOut: intrinsic.Date\n    })\n}, {\n    name: \"string.date.iso\"\n});\nexport const stringDate = Scope.module({\n    root: parsableDate,\n    parse: rootSchema({\n        declaredIn: parsableDate,\n        in: \"string\",\n        morphs: (s, ctx) => {\n            const date = new Date(s);\n            if (Number.isNaN(date.valueOf()))\n                return ctx.error(\"a parsable date\");\n            return date;\n        },\n        declaredOut: intrinsic.Date\n    }),\n    iso,\n    epoch\n}, {\n    name: \"string.date\"\n});\nconst email = regexStringNode(\n// considered https://colinhacks.com/essays/reasonable-email-regex but it includes a lookahead\n// which breaks some integrations e.g. fast-check\n// regex based on:\n// https://www.regular-expressions.info/email.html\n/^[\\w%+.-]+@[\\d.A-Za-z-]+\\.[A-Za-z]{2,}$/, \"an email address\", \"email\");\n// based on https://github.com/validatorjs/validator.js/blob/master/src/lib/isIP.js\nconst ipv4Segment = \"(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\";\nconst ipv4Address = `(${ipv4Segment}[.]){3}${ipv4Segment}`;\nconst ipv4Matcher = new RegExp(`^${ipv4Address}$`);\nconst ipv6Segment = \"(?:[0-9a-fA-F]{1,4})\";\nconst ipv6Matcher = new RegExp(\"^(\" +\n    `(?:${ipv6Segment}:){7}(?:${ipv6Segment}|:)|` +\n    `(?:${ipv6Segment}:){6}(?:${ipv4Address}|:${ipv6Segment}|:)|` +\n    `(?:${ipv6Segment}:){5}(?::${ipv4Address}|(:${ipv6Segment}){1,2}|:)|` +\n    `(?:${ipv6Segment}:){4}(?:(:${ipv6Segment}){0,1}:${ipv4Address}|(:${ipv6Segment}){1,3}|:)|` +\n    `(?:${ipv6Segment}:){3}(?:(:${ipv6Segment}){0,2}:${ipv4Address}|(:${ipv6Segment}){1,4}|:)|` +\n    `(?:${ipv6Segment}:){2}(?:(:${ipv6Segment}){0,3}:${ipv4Address}|(:${ipv6Segment}){1,5}|:)|` +\n    `(?:${ipv6Segment}:){1}(?:(:${ipv6Segment}){0,4}:${ipv4Address}|(:${ipv6Segment}){1,6}|:)|` +\n    `(?::((?::${ipv6Segment}){0,5}:${ipv4Address}|(?::${ipv6Segment}){1,7}|:))` +\n    \")(%[0-9a-zA-Z.]{1,})?$\");\nexport const ip = Scope.module({\n    root: [\"v4 | v6\", \"@\", \"an IP address\"],\n    v4: regexStringNode(ipv4Matcher, \"an IPv4 address\", \"ipv4\"),\n    v6: regexStringNode(ipv6Matcher, \"an IPv6 address\", \"ipv6\")\n}, {\n    name: \"string.ip\"\n});\nconst jsonStringDescription = \"a JSON string\";\nexport const writeJsonSyntaxErrorProblem = (error) => {\n    if (!(error instanceof SyntaxError))\n        throw error;\n    return `must be ${jsonStringDescription} (${error})`;\n};\nconst jsonRoot = rootSchema({\n    meta: jsonStringDescription,\n    domain: \"string\",\n    predicate: {\n        meta: jsonStringDescription,\n        predicate: (s, ctx) => {\n            try {\n                JSON.parse(s);\n                return true;\n            }\n            catch (e) {\n                return ctx.reject({\n                    code: \"predicate\",\n                    expected: jsonStringDescription,\n                    problem: writeJsonSyntaxErrorProblem(e)\n                });\n            }\n        }\n    }\n});\nconst parseJson = (s, ctx) => {\n    if (s.length === 0) {\n        return ctx.error({\n            code: \"predicate\",\n            expected: jsonStringDescription,\n            actual: \"empty\"\n        });\n    }\n    try {\n        return JSON.parse(s);\n    }\n    catch (e) {\n        return ctx.error({\n            code: \"predicate\",\n            expected: jsonStringDescription,\n            problem: writeJsonSyntaxErrorProblem(e)\n        });\n    }\n};\nexport const json = Scope.module({\n    root: jsonRoot,\n    parse: rootSchema({\n        meta: \"safe JSON string parser\",\n        in: \"string\",\n        morphs: parseJson,\n        declaredOut: intrinsic.jsonObject\n    })\n}, {\n    name: \"string.json\"\n});\nconst preformattedLower = regexStringNode(/^[a-z]*$/, \"only lowercase letters\");\nconst lower = Scope.module({\n    root: rootSchema({\n        in: \"string\",\n        morphs: (s) => s.toLowerCase(),\n        declaredOut: preformattedLower\n    }),\n    preformatted: preformattedLower\n}, {\n    name: \"string.lower\"\n});\nexport const normalizedForms = [\"NFC\", \"NFD\", \"NFKC\", \"NFKD\"];\nconst preformattedNodes = flatMorph(normalizedForms, (i, form) => [\n    form,\n    rootSchema({\n        domain: \"string\",\n        predicate: (s) => s.normalize(form) === s,\n        meta: `${form}-normalized unicode`\n    })\n]);\nconst normalizeNodes = flatMorph(normalizedForms, (i, form) => [\n    form,\n    rootSchema({\n        in: \"string\",\n        morphs: (s) => s.normalize(form),\n        declaredOut: preformattedNodes[form]\n    })\n]);\nexport const NFC = Scope.module({\n    root: normalizeNodes.NFC,\n    preformatted: preformattedNodes.NFC\n}, {\n    name: \"string.normalize.NFC\"\n});\nexport const NFD = Scope.module({\n    root: normalizeNodes.NFD,\n    preformatted: preformattedNodes.NFD\n}, {\n    name: \"string.normalize.NFD\"\n});\nexport const NFKC = Scope.module({\n    root: normalizeNodes.NFKC,\n    preformatted: preformattedNodes.NFKC\n}, {\n    name: \"string.normalize.NFKC\"\n});\nexport const NFKD = Scope.module({\n    root: normalizeNodes.NFKD,\n    preformatted: preformattedNodes.NFKD\n}, {\n    name: \"string.normalize.NFKD\"\n});\nexport const normalize = Scope.module({\n    root: \"NFC\",\n    NFC,\n    NFD,\n    NFKC,\n    NFKD\n}, {\n    name: \"string.normalize\"\n});\nconst numericRoot = regexStringNode(numericStringMatcher, \"a well-formed numeric string\");\nexport const stringNumeric = Scope.module({\n    root: numericRoot,\n    parse: rootSchema({\n        in: numericRoot,\n        morphs: (s) => Number.parseFloat(s),\n        declaredOut: intrinsic.number\n    })\n}, {\n    name: \"string.numeric\"\n});\nconst regexPatternDescription = \"a regex pattern\";\nconst regex = rootSchema({\n    domain: \"string\",\n    predicate: {\n        meta: regexPatternDescription,\n        predicate: (s, ctx) => {\n            try {\n                new RegExp(s);\n                return true;\n            }\n            catch (e) {\n                return ctx.reject({\n                    code: \"predicate\",\n                    expected: regexPatternDescription,\n                    problem: String(e)\n                });\n            }\n        }\n    },\n    meta: { format: \"regex\" }\n});\nconst semverMatcher = /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[A-Za-z-][\\dA-Za-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[A-Za-z-][\\dA-Za-z-]*))*))?(?:\\+([\\dA-Za-z-]+(?:\\.[\\dA-Za-z-]+)*))?$/;\nconst semver = regexStringNode(semverMatcher, \"a semantic version (see https://semver.org/)\");\nconst preformattedTrim = regexStringNode(\n// no leading or trailing whitespace\n/^\\S.*\\S$|^\\S?$/, \"trimmed\");\nconst trim = Scope.module({\n    root: rootSchema({\n        in: \"string\",\n        morphs: (s) => s.trim(),\n        declaredOut: preformattedTrim\n    }),\n    preformatted: preformattedTrim\n}, {\n    name: \"string.trim\"\n});\nconst preformattedUpper = regexStringNode(/^[A-Z]*$/, \"only uppercase letters\");\nconst upper = Scope.module({\n    root: rootSchema({\n        in: \"string\",\n        morphs: (s) => s.toUpperCase(),\n        declaredOut: preformattedUpper\n    }),\n    preformatted: preformattedUpper\n}, {\n    name: \"string.upper\"\n});\nconst isParsableUrl = (s) => {\n    if (URL.canParse)\n        return URL.canParse(s);\n    // TODO[2025-04-30] remove once Node 18 is EOL and we can rely on URL.canParse\n    try {\n        new URL(s);\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\nconst urlRoot = rootSchema({\n    domain: \"string\",\n    predicate: {\n        meta: \"a URL string\",\n        predicate: isParsableUrl\n    },\n    // URL.canParse allows a subset of the RFC-3986 URI spec\n    // since there is no other serializable validation, best include a format\n    meta: { format: \"uri\" }\n});\nexport const url = Scope.module({\n    root: urlRoot,\n    parse: rootSchema({\n        declaredIn: urlRoot,\n        in: \"string\",\n        morphs: (s, ctx) => {\n            try {\n                return new URL(s);\n            }\n            catch {\n                return ctx.error(\"a URL string\");\n            }\n        },\n        declaredOut: rootSchema(URL)\n    })\n}, {\n    name: \"string.url\"\n});\n// based on https://github.com/validatorjs/validator.js/blob/master/src/lib/isUUID.js\nexport const uuid = Scope.module({\n    // the meta tuple expression ensures the error message does not delegate\n    // to the individual branches, which are too detailed\n    root: [\n        \"versioned | nil | max\",\n        \"@\",\n        { description: \"a UUID\", format: \"uuid\" }\n    ],\n    \"#nil\": \"'00000000-0000-0000-0000-000000000000'\",\n    \"#max\": \"'ffffffff-ffff-ffff-ffff-ffffffffffff'\",\n    \"#versioned\": /[\\da-f]{8}-[\\da-f]{4}-[1-8][\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}/i,\n    v1: regexStringNode(/^[\\da-f]{8}-[\\da-f]{4}-1[\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}$/i, \"a UUIDv1\"),\n    v2: regexStringNode(/^[\\da-f]{8}-[\\da-f]{4}-2[\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}$/i, \"a UUIDv2\"),\n    v3: regexStringNode(/^[\\da-f]{8}-[\\da-f]{4}-3[\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}$/i, \"a UUIDv3\"),\n    v4: regexStringNode(/^[\\da-f]{8}-[\\da-f]{4}-4[\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}$/i, \"a UUIDv4\"),\n    v5: regexStringNode(/^[\\da-f]{8}-[\\da-f]{4}-5[\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}$/i, \"a UUIDv5\"),\n    v6: regexStringNode(/^[\\da-f]{8}-[\\da-f]{4}-6[\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}$/i, \"a UUIDv6\"),\n    v7: regexStringNode(/^[\\da-f]{8}-[\\da-f]{4}-7[\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}$/i, \"a UUIDv7\"),\n    v8: regexStringNode(/^[\\da-f]{8}-[\\da-f]{4}-8[\\da-f]{3}-[89ab][\\da-f]{3}-[\\da-f]{12}$/i, \"a UUIDv8\")\n}, {\n    name: \"string.uuid\"\n});\nexport const string = Scope.module({\n    root: intrinsic.string,\n    alpha: regexStringNode(/^[A-Za-z]*$/, \"only letters\"),\n    alphanumeric: regexStringNode(/^[\\dA-Za-z]*$/, \"only letters and digits 0-9\"),\n    hex,\n    base64,\n    capitalize,\n    creditCard,\n    date: stringDate,\n    digits: regexStringNode(/^\\d*$/, \"only digits 0-9\"),\n    email,\n    integer: stringInteger,\n    ip,\n    json,\n    lower,\n    normalize,\n    numeric: stringNumeric,\n    regex,\n    semver,\n    trim,\n    upper,\n    url,\n    uuid\n}, {\n    name: \"string\"\n});\n", "import { genericNode, intrinsic, node } from \"@ark/schema\";\nimport { Hkt } from \"@ark/util\";\nimport { Scope } from \"../scope.js\";\nexport const arkTsKeywords = Scope.module({\n    bigint: intrinsic.bigint,\n    boolean: intrinsic.boolean,\n    false: intrinsic.false,\n    never: intrinsic.never,\n    null: intrinsic.null,\n    number: intrinsic.number,\n    object: intrinsic.object,\n    string: intrinsic.string,\n    symbol: intrinsic.symbol,\n    true: intrinsic.true,\n    unknown: intrinsic.unknown,\n    undefined: intrinsic.undefined\n});\nexport const unknown = Scope.module({\n    root: intrinsic.unknown,\n    any: intrinsic.unknown\n}, {\n    name: \"unknown\"\n});\nexport const json = Scope.module({\n    root: intrinsic.jsonObject,\n    stringify: node(\"morph\", {\n        in: intrinsic.jsonObject,\n        morphs: (data) => JSON.stringify(data),\n        declaredOut: intrinsic.string\n    })\n}, {\n    name: \"object.json\"\n});\nexport const object = Scope.module({\n    root: intrinsic.object,\n    json\n}, {\n    name: \"object\"\n});\nclass RecordHkt extends Hkt {\n    description = 'instantiate an object from an index signature and corresponding value type like `Record(\"string\", \"number\")`';\n}\nconst Record = genericNode([\"K\", intrinsic.key], \"V\")(args => ({\n    domain: \"object\",\n    index: {\n        signature: args.K,\n        value: args.V\n    }\n}), RecordHkt);\nclass PickHkt extends Hkt {\n    description = 'pick a set of properties from an object like `Pick(User, \"name | age\")`';\n}\nconst Pick = genericNode([\"T\", intrinsic.object], [\"K\", intrinsic.key])(args => args.T.pick(args.K), PickHkt);\nclass OmitHkt extends Hkt {\n    description = 'omit a set of properties from an object like `Omit(User, \"age\")`';\n}\nconst Omit = genericNode([\"T\", intrinsic.object], [\"K\", intrinsic.key])(args => args.T.omit(args.K), OmitHkt);\nclass PartialHkt extends Hkt {\n    description = \"make all named properties of an object optional like `Partial(User)`\";\n}\nconst Partial = genericNode([\"T\", intrinsic.object])(args => args.T.partial(), PartialHkt);\nclass RequiredHkt extends Hkt {\n    description = \"make all named properties of an object required like `Required(User)`\";\n}\nconst Required = genericNode([\"T\", intrinsic.object])(args => args.T.required(), RequiredHkt);\nclass ExcludeHkt extends Hkt {\n    description = 'exclude branches of a union like `Exclude(\"boolean\", \"true\")`';\n}\nconst Exclude = genericNode(\"T\", \"U\")(args => args.T.exclude(args.U), ExcludeHkt);\nclass ExtractHkt extends Hkt {\n    description = 'extract branches of a union like `Extract(\"0 | false | 1\", \"number\")`';\n}\nconst Extract = genericNode(\"T\", \"U\")(args => args.T.extract(args.U), ExtractHkt);\nexport const arkTsGenerics = Scope.module({\n    Exclude,\n    Extract,\n    Omit,\n    Partial,\n    Pick,\n    Record,\n    Required\n});\n", "import { $arkTypeRegistry, scope } from \"../scope.js\";\nimport { arkBuiltins } from \"./builtins.js\";\nimport { arkPrototypes } from \"./constructors.js\";\nimport { number } from \"./number.js\";\nimport { string } from \"./string.js\";\nimport { arkTsGenerics, arkTsKeywords, object, unknown } from \"./ts.js\";\nexport const ark = scope({\n    ...arkTsKeywords,\n    ...arkTsGenerics,\n    ...arkPrototypes,\n    ...arkBuiltins,\n    string,\n    number,\n    object,\n    unknown\n}, { prereducedAliases: true, name: \"ark\" });\nexport const keywords = ark.export();\nObject.assign($arkTypeRegistry.ambient, keywords);\n$arkTypeRegistry.typeAttachments = {\n    string: keywords.string.root,\n    number: keywords.number.root,\n    bigint: keywords.bigint,\n    boolean: keywords.boolean,\n    symbol: keywords.symbol,\n    undefined: keywords.undefined,\n    null: keywords.null,\n    object: keywords.object.root,\n    unknown: keywords.unknown.root,\n    false: keywords.false,\n    true: keywords.true,\n    never: keywords.never,\n    arrayIndex: keywords.Array.index,\n    Key: keywords.Key,\n    Record: keywords.Record,\n    Array: keywords.Array.root,\n    Date: keywords.Date\n};\nexport const type = Object.assign(ark.type, \n// assign attachments newly parsed in keywords\n// future scopes add these directly from the\n// registry when their TypeParsers are instantiated\n$arkTypeRegistry.typeAttachments);\nexport const match = ark.match;\nexport const generic = ark.generic;\nexport const schema = ark.schema;\nexport const define = ark.define;\nexport const declare = ark.declare;\n", "import { RootModule } from \"@ark/schema\";\nexport const Module = RootModule;\nexport const BoundModule = RootModule;\n"],
  "mappings": "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",
  "names": ["value", "value", "args", "regex", "regex", "value", "value", "value", "value", "indent", "suffix", "value", "args", "object", "suffix", "indent", "value", "node", "value", "value", "implementation", "args", "schema", "keywords", "e", "value", "transformed", "node", "value", "implementation", "schema", "schema", "node", "args", "args", "value", "schema", "node", "implementation", "schema", "node", "greatestCommonDivisor", "schema", "implementation", "schema", "node", "implementation", "schema", "node", "implementation", "schema", "node", "implementation", "schema", "node", "implementation", "node", "schema", "implementation", "schema", "node", "implementation", "node", "schema", "implementation", "schema", "node", "schema", "node", "json", "value", "implementation", "schema", "node", "args", "value", "schema", "result", "args", "node", "r", "implementation", "kind", "schema", "implementation", "node", "implementation", "schema", "node", "implementation", "schema", "node", "implementation", "schema", "node", "implementation", "schema", "node", "implementation", "schema", "node", "cases", "l", "r", "implementation", "schema", "node", "implementation", "schema", "node", "value", "implementation", "schema", "node", "implementation", "schema", "node", "value", "node", "value", "implementation", "schema", "defaultableMorphsCache", "args", "js", "implementation", "value", "schema", "node", "value", "reference", "cached", "value", "node", "value", "args", "args", "node", "schema", "value", "value", "node", "args", "generic", "value", "node", "args", "args", "regex", "schema", "parsed", "capitalize", "epoch", "capitalize", "json", "args", "Required"]
}
