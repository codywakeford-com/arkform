"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.defineFirestoreSchema = defineFirestoreSchema;exports.isJoinKey = isJoinKey;var _firestore = await jitiImport("firebase/firestore");
var _firebase = await jitiImport("../stores/firebase");
var _vue = await jitiImport("vue");



















// -> { name: string; id: string }[]
// -> { name: string; id: string }
// -> { id: string }[]
// -> { id: string }
// -> { name: string; customerName: string }





// testing schema





















// update


















const firestore = defineFirestoreSchema();
const users = firestore.docRef("users/124");
const user2 = firestore.docRef("users/123");





function defineFirestoreSchema() {
  const arkfire = {
    docRef(path, options) {


      if (!import.meta.client) {
        const fakeRef = (0, _vue.ref)(null);
        fakeRef.set = async () => {};
        return fakeRef;
      }

      const db = (0, _firebase.useFirebase)().db;
      const dataRef = (0, _vue.ref)();
      const raw = (0, _vue.ref)(null);

      const docRef = (0, _firestore.doc)(db, path);

      const unsubscribe = (0, _firestore.onSnapshot)(docRef, async (snap) => {
        if (!snap.exists()) {
          dataRef.value = null;
          raw.value = null;
          return;
        }

        dataRef.value = snap.data();
        raw.value = snap.data();

        resolveJoins(snap.data());
      });

      const joinsMap = (0, _vue.ref)({});
      const joinUnsubscribers = {};

      function resolveJoins(data, visited = new Set()) {
        function walk(obj) {
          for (let [key, value] of Object.entries(obj)) {
            if (typeof value === "string" && value.startsWith("$")) {
              const path = value.slice(1);

              if (visited.has(path)) continue;
              visited.add(path);

              const docRef = (0, _firestore.doc)(db, path);
              const unsubscribe = (0, _firestore.onSnapshot)(docRef, (snap) => {
                if (!snap.exists()) return;

                const joinedData = snap.data();

                joinsMap.value[path] = joinedData;
                dataRef.value[key] = joinedData;
                walk(joinedData);
              });

              joinUnsubscribers[path] = unsubscribe;
            }

            if (typeof value === "object" && value !== null && !Array.isArray(value)) {
              walk(value);
            }
          }
        }

        walk(data);
      }

      const set = async (newData) => {
        if (!newData) return;

        const oldData = { ...dataRef.value };

        const updatesForThisDoc = {};
        const updatesToJoins = [];
        debugger;
        // find joins
        for (const [key, value] of Object.entries(newData)) {
          const isJoin = isJoinKey(value, raw.value?.[key]);

          if (isJoin) {
            const joinPath = raw.value?.[key]; // e.g., "$users/123"
            const absolutePath = joinPath.slice(1); // "users/123"
            const docRef = (0, _firestore.doc)(db, absolutePath);

            updatesToJoins.push((0, _firestore.setDoc)(docRef, newData, { merge: false }));
            continue;
          }

          updatesForThisDoc[key] = value;
        }

        // Optimistic
        dataRef.value = {
          ...dataRef.value,
          ...updatesForThisDoc
        };

        try {
          if (Object.keys(updatesForThisDoc).length > 0) {
            await (0, _firestore.setDoc)(docRef, updatesForThisDoc, { merge: true });
          }
          await Promise.all(updatesToJoins);
        } catch (e) {
          dataRef.value = oldData; // rollback
        }
      };

      const destroy = async () => {
        try {
          await (0, _firestore.deleteDoc)(docRef);
          unsubscribe();
          dataRef.value = null;
        } catch (e) {
          console.log("Failed to delete document", docRef.path);
        }
      };

      onBeforeUnmount(() => unsubscribe());

      return Object.assign(dataRef, { set, destroy });
    }
  };
  return arkfire;
}

// currentValue can be any object, if its position matches
function isJoinKey(currentValue, path) {
  if (typeof path === "string" && typeof currentValue === "object") {
    return path.startsWith("$");
  }

  return false;
} /* v9-0ccd178f69a6a3c2 */
