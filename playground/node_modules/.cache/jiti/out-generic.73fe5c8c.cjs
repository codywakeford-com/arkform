"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.parseGenericParamName = exports.emptyGenericParameterMessage = exports.Generic = void 0;var _schema = require("@ark/schema");
var _util = require("@ark/util");
var _dynamic = require("./parser/reduce/dynamic.js");
var _string = require("./parser/string.js");
const Generic = exports.Generic = _schema.GenericRoot;
const emptyGenericParameterMessage = exports.emptyGenericParameterMessage = "An empty string is not a valid generic parameter name";
const parseGenericParamName = (scanner, result, ctx) => {
  scanner.shiftUntilNonWhitespace();
  const name = scanner.shiftUntilNextTerminator();
  if (name === "") {
    // if we've reached the end of the string and have parsed at least one
    // param, return the valid result
    if (scanner.lookahead === "" && result.length)
    return result;
    return (0, _util.throwParseError)(emptyGenericParameterMessage);
  }
  scanner.shiftUntilNonWhitespace();
  return _parseOptionalConstraint(scanner, name, result, ctx);
};exports.parseGenericParamName = parseGenericParamName;
const extendsToken = "extends ";
const _parseOptionalConstraint = (scanner, name, result, ctx) => {
  scanner.shiftUntilNonWhitespace();
  if (scanner.unscanned.startsWith(extendsToken))
  scanner.jumpForward(extendsToken.length);else
  {
    // if we don't have a contraining token here, return now so we can
    // assume in the rest of the function body we do have a constraint
    if (scanner.lookahead === ",")
    scanner.shift();
    result.push(name);
    return parseGenericParamName(scanner, result, ctx);
  }
  const s = (0, _string.parseUntilFinalizer)(new _dynamic.DynamicState(scanner, ctx));
  result.push([name, s.root]);
  return parseGenericParamName(scanner, result, ctx);
}; /* v9-53b7b71ea5fbb896 */
