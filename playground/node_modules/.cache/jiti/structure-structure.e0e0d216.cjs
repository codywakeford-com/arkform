"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeNumberIndexMessage = exports.writeInvalidKeysMessage = exports.typeKeyToString = exports.normalizeIndex = exports.StructureNode = exports.Structure = void 0;var _util = require("@ark/util");
var _constraint = require("../constraint.js");
var _intrinsic = require("../intrinsic.js");
var _root = require("../roots/root.js");
var _disjoint = require("../shared/disjoint.js");
var _implement = require("../shared/implement.js");
var _intersections = require("../shared/intersections.js");
var _registry = require("../shared/registry.js");
var _toJsonSchema = require("../shared/toJsonSchema.js");
var _traversal = require("../shared/traversal.js");
var _utils = require("../shared/utils.js");
var _optional = require("./optional.js");
const createStructuralWriter = (childStringProp) => (node) => {
  if (node.props.length || node.index) {
    const parts = node.index?.map((index) => index[childStringProp]) ?? [];
    for (const prop of node.props)
    parts.push(prop[childStringProp]);
    if (node.undeclared)
    parts.push(`+ (undeclared): ${node.undeclared}`);
    const objectLiteralDescription = `{ ${parts.join(", ")} }`;
    return node.sequence ?
    `${objectLiteralDescription} & ${node.sequence.description}` :
    objectLiteralDescription;
  }
  return node.sequence?.description ?? "{}";
};
const structuralDescription = createStructuralWriter("description");
const structuralExpression = createStructuralWriter("expression");
const intersectPropsAndIndex = (l, r, $) => {
  const kind = l.required ? "required" : "optional";
  if (!r.signature.allows(l.key))
  return null;
  const value = (0, _intersections.intersectNodesRoot)(l.value, r.value, $);
  if (value instanceof _disjoint.Disjoint) {
    return kind === "optional" ?
    $.node("optional", {
      key: l.key,
      value: _registry.$ark.intrinsic.never.internal
    }) :
    value.withPrefixKey(l.key, l.kind);
  }
  return null;
};
const implementation = (0, _implement.implementNode)({
  kind: "structure",
  hasAssociatedError: false,
  normalize: (schema) => schema,
  applyConfig: (schema, config) => {
    if (!schema.undeclared && config.onUndeclaredKey !== "ignore") {
      return {
        ...schema,
        undeclared: config.onUndeclaredKey
      };
    }
    return schema;
  },
  keys: {
    required: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("required"),
      reduceIo: (ioKind, inner, nodes) => {
        // ensure we don't overwrite nodes added by optional
        inner.required = (0, _util.append)(inner.required, nodes.map((node) => node[ioKind]));
        return;
      }
    },
    optional: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("optional"),
      reduceIo: (ioKind, inner, nodes) => {
        if (ioKind === "in") {
          inner.optional = nodes.map((node) => node.in);
          return;
        }
        for (const node of nodes) {
          inner[node.outProp.kind] = (0, _util.append)(inner[node.outProp.kind], node.outProp.out);
        }
      }
    },
    index: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("index")
    },
    sequence: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("sequence")
    },
    undeclared: {
      parse: (behavior) => behavior === "ignore" ? undefined : behavior,
      reduceIo: (ioKind, inner, value) => {
        if (value !== "delete")
        return;
        // if base is "delete", undeclared keys are "ignore" (i.e. unconstrained)
        // on input and "reject" on output
        if (ioKind === "in")
        delete inner.undeclared;else

        inner.undeclared = "reject";
      }
    }
  },
  defaults: {
    description: structuralDescription
  },
  intersections: {
    structure: (l, r, ctx) => {
      const lInner = { ...l.inner };
      const rInner = { ...r.inner };
      const disjointResult = new _disjoint.Disjoint();
      if (l.undeclared) {
        const lKey = l.keyof();
        for (const k of r.requiredKeys) {
          if (!lKey.allows(k)) {
            disjointResult.add("presence", _registry.$ark.intrinsic.never.internal, r.propsByKey[k].value, {
              path: [k]
            });
          }
        }
        if (rInner.optional)
        rInner.optional = rInner.optional.filter((n) => lKey.allows(n.key));
        if (rInner.index) {
          rInner.index = rInner.index.flatMap((n) => {
            if (n.signature.extends(lKey))
            return n;
            const indexOverlap = (0, _intersections.intersectNodesRoot)(lKey, n.signature, ctx.$);
            if (indexOverlap instanceof _disjoint.Disjoint)
            return [];
            const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);
            if (normalized.required) {
              rInner.required = (0, _util.conflatenate)(rInner.required, normalized.required);
            }
            if (normalized.optional) {
              rInner.optional = (0, _util.conflatenate)(rInner.optional, normalized.optional);
            }
            return normalized.index ?? [];
          });
        }
      }
      if (r.undeclared) {
        const rKey = r.keyof();
        for (const k of l.requiredKeys) {
          if (!rKey.allows(k)) {
            disjointResult.add("presence", l.propsByKey[k].value, _registry.$ark.intrinsic.never.internal, {
              path: [k]
            });
          }
        }
        if (lInner.optional)
        lInner.optional = lInner.optional.filter((n) => rKey.allows(n.key));
        if (lInner.index) {
          lInner.index = lInner.index.flatMap((n) => {
            if (n.signature.extends(rKey))
            return n;
            const indexOverlap = (0, _intersections.intersectNodesRoot)(rKey, n.signature, ctx.$);
            if (indexOverlap instanceof _disjoint.Disjoint)
            return [];
            const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);
            if (normalized.required) {
              lInner.required = (0, _util.conflatenate)(lInner.required, normalized.required);
            }
            if (normalized.optional) {
              lInner.optional = (0, _util.conflatenate)(lInner.optional, normalized.optional);
            }
            return normalized.index ?? [];
          });
        }
      }
      const baseInner = {};
      if (l.undeclared || r.undeclared) {
        baseInner.undeclared =
        l.undeclared === "reject" || r.undeclared === "reject" ?
        "reject" :
        "delete";
      }
      const childIntersectionResult = (0, _constraint.intersectConstraints)({
        kind: "structure",
        baseInner,
        l: (0, _constraint.flattenConstraints)(lInner),
        r: (0, _constraint.flattenConstraints)(rInner),
        roots: [],
        ctx
      });
      if (childIntersectionResult instanceof _disjoint.Disjoint)
      disjointResult.push(...childIntersectionResult);
      if (disjointResult.length)
      return disjointResult;
      return childIntersectionResult;
    }
  },
  reduce: (inner, $) => {
    if (inner.index) {
      if (!(inner.required || inner.optional))
      return;
      let updated = false;
      const requiredProps = inner.required ?? [];
      const optionalProps = inner.optional ?? [];
      const newOptionalProps = [...optionalProps];
      for (const index of inner.index) {
        for (const requiredProp of requiredProps) {
          const intersection = intersectPropsAndIndex(requiredProp, index, $);
          if (intersection instanceof _disjoint.Disjoint)
          return intersection;
        }
        for (const [indx, optionalProp] of optionalProps.entries()) {
          const intersection = intersectPropsAndIndex(optionalProp, index, $);
          if (intersection instanceof _disjoint.Disjoint)
          return intersection;
          if (intersection === null)
          continue;
          newOptionalProps[indx] = intersection;
          updated = true;
        }
      }
      if (updated) {
        return $.node("structure", { ...inner, optional: newOptionalProps }, { prereduced: true });
      }
    }
  }
});
class StructureNode extends _constraint.BaseConstraint {
  impliedBasis = _registry.$ark.intrinsic.object.internal;
  impliedSiblings = this.children.flatMap((n) => n.impliedSiblings ?? []);
  props = (0, _util.conflatenate)(this.required, this.optional);
  propsByKey = (0, _util.flatMorph)(this.props, (i, node) => [node.key, node]);
  propsByKeyReference = (0, _registry.registeredReference)(this.propsByKey);
  expression = structuralExpression(this);
  requiredKeys = this.required?.map((node) => node.key) ?? [];
  optionalKeys = this.optional?.map((node) => node.key) ?? [];
  literalKeys = [...this.requiredKeys, ...this.optionalKeys];
  _keyof;
  keyof() {
    if (this._keyof)
    return this._keyof;
    let branches = this.$.units(this.literalKeys).branches;
    if (this.index) {
      for (const { signature } of this.index)
      branches = branches.concat(signature.branches);
    }
    return this._keyof = this.$.node("union", branches);
  }
  map(flatMapProp) {
    return this.$.node("structure", this.props.
    flatMap(flatMapProp).
    reduce((structureInner, mapped) => {
      const originalProp = this.propsByKey[mapped.key];
      if ((0, _utils.isNode)(mapped)) {
        if (mapped.kind !== "required" && mapped.kind !== "optional") {
          return (0, _util.throwParseError)(`Map result must have kind "required" or "optional" (was ${mapped.kind})`);
        }
        structureInner[mapped.kind] = (0, _util.append)(structureInner[mapped.kind], mapped);
        return structureInner;
      }
      const mappedKind = mapped.kind ?? originalProp?.kind ?? "required";
      // extract the inner keys from the map result in case a node was spread,
      // which would otherwise lead to invalid keys
      const mappedPropInner = (0, _util.flatMorph)(mapped, (k, v) => k in _optional.Optional.implementation.keys ? [k, v] : []);
      structureInner[mappedKind] = (0, _util.append)(structureInner[mappedKind], this.$.node(mappedKind, mappedPropInner));
      return structureInner;
    }, {}));
  }
  assertHasKeys(keys) {
    const invalidKeys = keys.filter((k) => !(0, _root.typeOrTermExtends)(k, this.keyof()));
    if (invalidKeys.length) {
      return (0, _util.throwParseError)(writeInvalidKeysMessage(this.expression, invalidKeys));
    }
  }
  get(indexer, ...path) {
    let value;
    let required = false;
    const key = indexerToKey(indexer);
    if ((typeof key === "string" || typeof key === "symbol") &&
    this.propsByKey[key]) {
      value = this.propsByKey[key].value;
      required = this.propsByKey[key].required;
    }
    if (this.index) {
      for (const n of this.index) {
        if ((0, _root.typeOrTermExtends)(key, n.signature))
        value = value?.and(n.value) ?? n.value;
      }
    }
    if (this.sequence &&
    (0, _root.typeOrTermExtends)(key, _registry.$ark.intrinsic.nonNegativeIntegerString)) {
      if ((0, _utils.hasArkKind)(key, "root")) {
        if (this.sequence.variadic)
          // if there is a variadic element and we're accessing an index, return a union
          // of all possible elements. If there is no variadic expression, we're in a tuple
          // so this access wouldn't be safe based on the array indices
          value = value?.and(this.sequence.element) ?? this.sequence.element;
      } else
      {
        const index = Number.parseInt(key);
        if (index < this.sequence.prevariadic.length) {
          const fixedElement = this.sequence.prevariadic[index].node;
          value = value?.and(fixedElement) ?? fixedElement;
          required ||= index < this.sequence.prefixLength;
        } else
        if (this.sequence.variadic) {
          // ideally we could return something more specific for postfix
          // but there is no way to represent it using an index alone
          const nonFixedElement = this.$.node("union", this.sequence.variadicOrPostfix);
          value = value?.and(nonFixedElement) ?? nonFixedElement;
        }
      }
    }
    if (!value) {
      if (this.sequence?.variadic &&
      (0, _utils.hasArkKind)(key, "root") &&
      key.extends(_registry.$ark.intrinsic.number)) {
        return (0, _util.throwParseError)(writeNumberIndexMessage(key.expression, this.sequence.expression));
      }
      return (0, _util.throwParseError)(writeInvalidKeysMessage(this.expression, [key]));
    }
    const result = value.get(...path);
    return required ? result : result.or(_registry.$ark.intrinsic.undefined);
  }
  pick(...keys) {
    this.assertHasKeys(keys);
    return this.$.node("structure", this.filterKeys("pick", keys));
  }
  omit(...keys) {
    this.assertHasKeys(keys);
    return this.$.node("structure", this.filterKeys("omit", keys));
  }
  optionalize() {
    const { required, ...inner } = this.inner;
    return this.$.node("structure", {
      ...inner,
      optional: this.props.map((prop) => prop.hasKind("required") ? this.$.node("optional", prop.inner) : prop)
    });
  }
  require() {
    const { optional, ...inner } = this.inner;
    return this.$.node("structure", {
      ...inner,
      required: this.props.map((prop) => prop.hasKind("optional") ?
      {
        key: prop.key,
        value: prop.value
      } :
      prop)
    });
  }
  merge(r) {
    const inner = this.filterKeys("omit", [r.keyof()]);
    if (r.required)
    inner.required = (0, _util.append)(inner.required, r.required);
    if (r.optional)
    inner.optional = (0, _util.append)(inner.optional, r.optional);
    if (r.index)
    inner.index = (0, _util.append)(inner.index, r.index);
    if (r.sequence)
    inner.sequence = r.sequence;
    if (r.undeclared)
    inner.undeclared = r.undeclared;else

    delete inner.undeclared;
    return this.$.node("structure", inner);
  }
  filterKeys(operation, keys) {
    const result = (0, _utils.makeRootAndArrayPropertiesMutable)(this.inner);
    const shouldKeep = (key) => {
      const matchesKey = keys.some((k) => (0, _root.typeOrTermExtends)(key, k));
      return operation === "pick" ? matchesKey : !matchesKey;
    };
    if (result.required)
    result.required = result.required.filter((prop) => shouldKeep(prop.key));
    if (result.optional)
    result.optional = result.optional.filter((prop) => shouldKeep(prop.key));
    if (result.index)
    result.index = result.index.filter((index) => shouldKeep(index.signature));
    return result;
  }
  traverseAllows = (data, ctx) => this._traverse("Allows", data, ctx);
  traverseApply = (data, ctx) => this._traverse("Apply", data, ctx);
  _traverse = (traversalKind, data, ctx) => {
    const errorCount = ctx?.currentErrorCount ?? 0;
    for (let i = 0; i < this.props.length; i++) {
      if (traversalKind === "Allows") {
        if (!this.props[i].traverseAllows(data, ctx))
        return false;
      } else
      {
        this.props[i].traverseApply(data, ctx);
        if (ctx.failFast && ctx.currentErrorCount > errorCount)
        return false;
      }
    }
    if (this.sequence) {
      if (traversalKind === "Allows") {
        if (!this.sequence.traverseAllows(data, ctx))
        return false;
      } else
      {
        this.sequence.traverseApply(data, ctx);
        if (ctx.failFast && ctx.currentErrorCount > errorCount)
        return false;
      }
    }
    if (this.index || this.undeclared === "reject") {
      const keys = Object.keys(data);
      keys.push(...Object.getOwnPropertySymbols(data));
      for (let i = 0; i < keys.length; i++) {
        const k = keys[i];
        if (this.index) {
          for (const node of this.index) {
            if (node.signature.traverseAllows(k, ctx)) {
              if (traversalKind === "Allows") {
                const result = (0, _traversal.traverseKey)(k, () => node.value.traverseAllows(data[k], ctx), ctx);
                if (!result)
                return false;
              } else
              {
                (0, _traversal.traverseKey)(k, () => node.value.traverseApply(data[k], ctx), ctx);
                if (ctx.failFast && ctx.currentErrorCount > errorCount)
                return false;
              }
            }
          }
        }
        if (this.undeclared === "reject" && !this.declaresKey(k)) {
          if (traversalKind === "Allows")
          return false;
          // this should have its own error code:
          // https://github.com/arktypeio/arktype/issues/1403
          ctx.errorFromNodeContext({
            code: "predicate",
            expected: "removed",
            actual: "",
            relativePath: [k],
            meta: this.meta
          });
          if (ctx.failFast)
          return false;
        }
      }
    }
    // added additional ctx check here to address
    // https://github.com/arktypeio/arktype/issues/1346
    if (this.structuralMorph && ctx && !ctx.hasError())
    ctx.queueMorphs([this.structuralMorph]);
    return true;
  };
  get defaultable() {
    return this.cacheGetter("defaultable", this.optional?.filter((o) => o.hasDefault()) ?? []);
  }
  declaresKey = (k) => k in this.propsByKey ||
  this.index?.some((n) => n.signature.allows(k)) ||
  this.sequence !== undefined &&
  _registry.$ark.intrinsic.nonNegativeIntegerString.allows(k);
  _compileDeclaresKey(js) {
    const parts = [];
    if (this.props.length)
    parts.push(`k in ${this.propsByKeyReference}`);
    if (this.index) {
      for (const index of this.index)
      parts.push(js.invoke(index.signature, { kind: "Allows", arg: "k" }));
    }
    if (this.sequence)
    parts.push("$ark.intrinsic.nonNegativeIntegerString.allows(k)");
    // if parts is empty, this is a structure like { "+": "reject" }
    // that declares no keys, so return false
    return parts.join(" || ") || "false";
  }
  get structuralMorph() {
    return this.cacheGetter("structuralMorph", getPossibleMorph(this));
  }
  structuralMorphRef = this.structuralMorph && (0, _registry.registeredReference)(this.structuralMorph);
  compile(js) {
    if (js.traversalKind === "Apply")
    js.initializeErrorCount();
    for (const prop of this.props) {
      js.check(prop);
      if (js.traversalKind === "Apply")
      js.returnIfFailFast();
    }
    if (this.sequence) {
      js.check(this.sequence);
      if (js.traversalKind === "Apply")
      js.returnIfFailFast();
    }
    if (this.index || this.undeclared === "reject") {
      js.const("keys", "Object.keys(data)");
      js.line("keys.push(...Object.getOwnPropertySymbols(data))");
      js.for("i < keys.length", () => this.compileExhaustiveEntry(js));
    }
    if (js.traversalKind === "Allows")
    return js.return(true);
    // always queue deleteUndeclared on valid traversal for "delete"
    if (this.structuralMorphRef) {
      // added additional ctx check here to address
      // https://github.com/arktypeio/arktype/issues/1346
      js.if("ctx && !ctx.hasError()", () => {
        js.line(`ctx.queueMorphs([`);
        precompileMorphs(js, this);
        return js.line("])");
      });
    }
  }
  compileExhaustiveEntry(js) {
    js.const("k", "keys[i]");
    if (this.index) {
      for (const node of this.index) {
        js.if(`${js.invoke(node.signature, { arg: "k", kind: "Allows" })}`, () => js.traverseKey("k", "data[k]", node.value));
      }
    }
    if (this.undeclared === "reject") {
      js.if(`!(${this._compileDeclaresKey(js)})`, () => {
        if (js.traversalKind === "Allows")
        return js.return(false);
        return js.
        line(`ctx.errorFromNodeContext({ code: "predicate", expected: "removed", actual: "", relativePath: [k], meta: ${this.compiledMeta} })`).
        if("ctx.failFast", () => js.return());
      });
    }
    return js;
  }
  reduceJsonSchema(schema, ctx) {
    switch (schema.type) {
      case "object":
        return this.reduceObjectJsonSchema(schema, ctx);
      case "array":
        const arraySchema = this.sequence?.reduceJsonSchema(schema, ctx) ?? schema;
        if (this.props.length || this.index) {
          return ctx.fallback.arrayObject({
            code: "arrayObject",
            base: arraySchema,
            object: this.reduceObjectJsonSchema({ type: "object" }, ctx)
          });
        }
        return arraySchema;
      default:
        return _toJsonSchema.ToJsonSchema.throwInternalOperandError("structure", schema);
    }
  }
  reduceObjectJsonSchema(schema, ctx) {
    if (this.props.length) {
      schema.properties = {};
      for (const prop of this.props) {
        const valueSchema = prop.value.toJsonSchemaRecurse(ctx);
        if (typeof prop.key === "symbol") {
          ctx.fallback.symbolKey({
            code: "symbolKey",
            base: schema,
            key: prop.key,
            value: valueSchema,
            optional: prop.optional
          });
          continue;
        }
        if (prop.hasDefault()) {
          const value = typeof prop.default === "function" ? prop.default() : prop.default;
          valueSchema.default =
          _registry.$ark.intrinsic.jsonData.allows(value) ?
          value :
          ctx.fallback.defaultValue({
            code: "defaultValue",
            base: valueSchema,
            value
          });
        }
        schema.properties[prop.key] = valueSchema;
      }
      if (this.requiredKeys.length && schema.properties) {
        schema.required = this.requiredKeys.filter((k) => typeof k === "string" && k in schema.properties);
      }
    }
    if (this.index) {
      for (const index of this.index) {
        const valueJsonSchema = index.value.toJsonSchemaRecurse(ctx);
        if (index.signature.equals(_registry.$ark.intrinsic.string)) {
          schema.additionalProperties = valueJsonSchema;
          continue;
        }
        for (const keyBranch of index.signature.branches) {
          if (!keyBranch.extends(_registry.$ark.intrinsic.string)) {
            schema = ctx.fallback.symbolKey({
              code: "symbolKey",
              base: schema,
              key: null,
              value: valueJsonSchema,
              optional: false
            });
            continue;
          }
          let keySchema = { type: "string" };
          if (keyBranch.hasKind("morph")) {
            keySchema = ctx.fallback.morph({
              code: "morph",
              base: keyBranch.in.toJsonSchemaRecurse(ctx),
              out: keyBranch.out.toJsonSchemaRecurse(ctx)
            });
          }
          if (!keyBranch.hasKind("intersection")) {
            return (0, _util.throwInternalError)(`Unexpected index branch kind ${keyBranch.kind}.`);
          }
          const { pattern } = keyBranch.inner;
          if (pattern) {
            const keySchemaWithPattern = Object.assign(keySchema, {
              pattern: pattern[0].rule
            });
            for (let i = 1; i < pattern.length; i++) {
              keySchema = ctx.fallback.patternIntersection({
                code: "patternIntersection",
                base: keySchemaWithPattern,
                pattern: pattern[i].rule
              });
            }
            schema.patternProperties ??= {};
            schema.patternProperties[keySchemaWithPattern.pattern] =
            valueJsonSchema;
          }
        }
      }
    }
    if (this.undeclared && !schema.additionalProperties)
    schema.additionalProperties = false;
    return schema;
  }
}exports.StructureNode = StructureNode;
const defaultableMorphsCache = {};
const constructStructuralMorphCacheKey = (node) => {
  let cacheKey = "";
  for (let i = 0; i < node.defaultable.length; i++)
  cacheKey += node.defaultable[i].defaultValueMorphRef;
  if (node.sequence?.defaultValueMorphsReference)
  cacheKey += node.sequence?.defaultValueMorphsReference;
  if (node.undeclared === "delete") {
    cacheKey += "delete !(";
    if (node.required)
    for (const n of node.required)
    cacheKey += n.compiledKey + " | ";
    if (node.optional)
    for (const n of node.optional)
    cacheKey += n.compiledKey + " | ";
    if (node.index)
    for (const index of node.index)
    cacheKey += index.signature.id + " | ";
    if (node.sequence) {
      if (node.sequence.maxLength === null)
      cacheKey += _intrinsic.intrinsic.nonNegativeIntegerString.id;else
      {
        for (let i = 0; i < node.sequence.tuple.length; i++)
        cacheKey += i + " | ";
      }
    }
    cacheKey += ")";
  }
  return cacheKey;
};
const getPossibleMorph = (node) => {
  const cacheKey = constructStructuralMorphCacheKey(node);
  if (!cacheKey)
  return undefined;
  if (defaultableMorphsCache[cacheKey])
  return defaultableMorphsCache[cacheKey];
  const $arkStructuralMorph = (data, ctx) => {
    for (let i = 0; i < node.defaultable.length; i++) {
      if (!(node.defaultable[i].key in data))
      node.defaultable[i].defaultValueMorph(data, ctx);
    }
    if (node.sequence?.defaultables) {
      for (let i = data.length - node.sequence.prefixLength; i < node.sequence.defaultables.length; i++)
      node.sequence.defaultValueMorphs[i](data, ctx);
    }
    if (node.undeclared === "delete")
    for (const k in data)
    if (!node.declaresKey(k))
    delete data[k];
    return data;
  };
  return defaultableMorphsCache[cacheKey] = $arkStructuralMorph;
};
const precompileMorphs = (js, node) => {
  const requiresContext = node.defaultable.some((node) => node.defaultValueMorph.length === 2) ||
  node.sequence?.defaultValueMorphs.some((morph) => morph.length === 2);
  const args = `(data${requiresContext ? ", ctx" : ""})`;
  return js.block(`${args} => `, (js) => {
    for (let i = 0; i < node.defaultable.length; i++) {
      const { serializedKey, defaultValueMorphRef } = node.defaultable[i];
      js.if(`!(${serializedKey} in data)`, (js) => js.line(`${defaultValueMorphRef}${args}`));
    }
    if (node.sequence?.defaultables) {
      js.for(`i < ${node.sequence.defaultables.length}`, (js) => js.set(`data[i]`, 5), `data.length - ${node.sequence.prefixLength}`);
    }
    if (node.undeclared === "delete") {
      js.forIn("data", (js) => js.if(`!(${node._compileDeclaresKey(js)})`, (js) => js.line(`delete data[k]`)));
    }
    return js.return("data");
  });
};
const Structure = exports.Structure = {
  implementation,
  Node: StructureNode
};
const indexerToKey = (indexable) => {
  if ((0, _utils.hasArkKind)(indexable, "root") && indexable.hasKind("unit"))
  indexable = indexable.unit;
  if (typeof indexable === "number")
  indexable = `${indexable}`;
  return indexable;
};
const writeNumberIndexMessage = (indexExpression, sequenceExpression) => `${indexExpression} is not allowed as an array index on ${sequenceExpression}. Use the 'nonNegativeIntegerString' keyword instead.`;
/** extract enumerable named props from an index signature */exports.writeNumberIndexMessage = writeNumberIndexMessage;
const normalizeIndex = (signature, value, $) => {
  const [enumerableBranches, nonEnumerableBranches] = (0, _util.spliterate)(signature.branches, (k) => k.hasKind("unit"));
  if (!enumerableBranches.length)
  return { index: $.node("index", { signature, value }) };
  const normalized = {};
  for (const n of enumerableBranches) {
    // since required can be reduced to optional if it has a default or
    // optional meta on its value, we have to assign it depending on the
    // compiled kind
    const prop = $.node("required", { key: n.unit, value });
    normalized[prop.kind] = (0, _util.append)(normalized[prop.kind], prop);
  }
  if (nonEnumerableBranches.length) {
    normalized.index = $.node("index", {
      signature: nonEnumerableBranches,
      value
    });
  }
  return normalized;
};exports.normalizeIndex = normalizeIndex;
const typeKeyToString = (k) => (0, _utils.hasArkKind)(k, "root") ? k.expression : (0, _util.printable)(k);exports.typeKeyToString = typeKeyToString;
const writeInvalidKeysMessage = (o, keys) => `Key${keys.length === 1 ? "" : "s"} ${keys.map(typeKeyToString).join(", ")} ${keys.length === 1 ? "does" : "do"} not exist on ${o}`;exports.writeInvalidKeysMessage = writeInvalidKeysMessage; /* v9-0af5f03c2f74aa2b */
