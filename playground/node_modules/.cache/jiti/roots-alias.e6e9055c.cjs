"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeShallowCycleErrorMessage = exports.normalizeAliasSchema = exports.AliasNode = exports.Alias = void 0;var _util = require("@ark/util");
var _parse = require("../parse.js");
var _disjoint = require("../shared/disjoint.js");
var _implement = require("../shared/implement.js");
var _intersections = require("../shared/intersections.js");
var _registry = require("../shared/registry.js");
var _utils = require("../shared/utils.js");
var _root = require("./root.js");
var _utils2 = require("./utils.js");
const normalizeAliasSchema = (schema) => typeof schema === "string" ? { reference: schema } : schema;exports.normalizeAliasSchema = normalizeAliasSchema;
const neverIfDisjoint = (result) => result instanceof _disjoint.Disjoint ? _registry.$ark.intrinsic.never.internal : result;
const implementation = (0, _implement.implementNode)({
  kind: "alias",
  hasAssociatedError: false,
  collapsibleKey: "reference",
  keys: {
    reference: {
      serialize: (s) => s.startsWith("$") ? s : `$ark.${s}`
    },
    resolve: {}
  },
  normalize: normalizeAliasSchema,
  defaults: {
    description: (node) => node.reference
  },
  intersections: {
    alias: (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint((0, _intersections.intersectOrPipeNodes)(l.resolution, r.resolution, ctx)), `${l.reference}${ctx.pipe ? "=>" : "&"}${r.reference}`),
    ...(0, _utils2.defineRightwardIntersections)("alias", (l, r, ctx) => {
      if (r.isUnknown())
      return l;
      if (r.isNever())
      return r;
      if (r.isBasis() && !r.overlaps(_registry.$ark.intrinsic.object)) {
        // can be more robust as part of https://github.com/arktypeio/arktype/issues/1026
        return _disjoint.Disjoint.init("assignability", _registry.$ark.intrinsic.object, r);
      }
      return ctx.$.lazilyResolve(() => neverIfDisjoint((0, _intersections.intersectOrPipeNodes)(l.resolution, r, ctx)), `${l.reference}${ctx.pipe ? "=>" : "&"}${r.id}`);
    })
  }
});
class AliasNode extends _root.BaseRoot {
  expression = this.reference;
  structure = undefined;
  get resolution() {
    const result = this._resolve();
    return _parse.nodesByRegisteredId[this.id] = result;
  }
  _resolve() {
    if (this.resolve)
    return this.resolve();
    if (this.reference[0] === "$")
    return this.$.resolveRoot(this.reference.slice(1));
    const id = this.reference;
    let resolution = _parse.nodesByRegisteredId[id];
    const seen = [];
    while ((0, _utils.hasArkKind)(resolution, "context")) {
      if (seen.includes(resolution.id)) {
        return (0, _util.throwParseError)(writeShallowCycleErrorMessage(resolution.id, seen));
      }
      seen.push(resolution.id);
      resolution = _parse.nodesByRegisteredId[resolution.id];
    }
    if (!(0, _utils.hasArkKind)(resolution, "root")) {
      return (0, _util.throwInternalError)(`Unexpected resolution for reference ${this.reference}
Seen: [${seen.join("->")}] 
Resolution: ${(0, _util.printable)(resolution)}`);
    }
    return resolution;
  }
  get resolutionId() {
    if (this.reference.includes("&") || this.reference.includes("=>"))
    return this.resolution.id;
    if (this.reference[0] !== "$")
    return this.reference;
    const alias = this.reference.slice(1);
    const resolution = this.$.resolutions[alias];
    if (typeof resolution === "string")
    return resolution;
    if ((0, _utils.hasArkKind)(resolution, "root"))
    return resolution.id;
    return (0, _util.throwInternalError)(`Unexpected resolution for reference ${this.reference}: ${(0, _util.printable)(resolution)}`);
  }
  get defaultShortDescription() {
    return _util.domainDescriptions.object;
  }
  innerToJsonSchema(ctx) {
    return this.resolution.toJsonSchemaRecurse(ctx);
  }
  traverseAllows = (data, ctx) => {
    const seen = ctx.seen[this.reference];
    if (seen?.includes(data))
    return true;
    ctx.seen[this.reference] = (0, _util.append)(seen, data);
    return this.resolution.traverseAllows(data, ctx);
  };
  traverseApply = (data, ctx) => {
    const seen = ctx.seen[this.reference];
    if (seen?.includes(data))
    return;
    ctx.seen[this.reference] = (0, _util.append)(seen, data);
    this.resolution.traverseApply(data, ctx);
  };
  compile(js) {
    const id = this.resolutionId;
    js.if(`ctx.seen.${id} && ctx.seen.${id}.includes(data)`, () => js.return(true));
    js.if(`!ctx.seen.${id}`, () => js.line(`ctx.seen.${id} = []`));
    js.line(`ctx.seen.${id}.push(data)`);
    js.return(js.invoke(id));
  }
}exports.AliasNode = AliasNode;
const writeShallowCycleErrorMessage = (name, seen) => `Alias '${name}' has a shallow resolution cycle: ${[...seen, name].join("->")}`;exports.writeShallowCycleErrorMessage = writeShallowCycleErrorMessage;
const Alias = exports.Alias = {
  implementation,
  Node: AliasNode
}; /* v9-3cc9f6059c205e40 */
