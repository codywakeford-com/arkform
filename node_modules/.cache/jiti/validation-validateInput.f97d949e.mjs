"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.getErrorMessages = getErrorMessages;exports.validateInput = void 0;var _arktype = await jitiImport("arktype");

var _useArkform = await jitiImport("../../composables/useArkform");

var _getInputByName = await jitiImport("../utils/getInputByName");









const validateInput = (P) => {
  const $arkform = (0, _useArkform.useArkForm)();
  const { id } = P;

  const input = $arkform.useInput(id);
  let errors = [];

  if (!input.optional.value && !input.arkValidators.value?.length) {
    input.arkValidators.value?.push("string>0");
  }

  const err = getErrorMessages([...input.arkValidators.value], id);
  errors.push(...err);

  if (input.matches.value) {
    const inputToMatchId = (0, _getInputByName.getInputIdByName)({
      name: input.matches.value,
      id
    });

    const inputToMatch = $arkform.useInput(inputToMatchId);
    if (inputToMatch.value.value !== input.value.value) {
      errors.push(`This field must match the ${input.matches.value} field.`);
    }
  }

  const merged = [...new Set([...input.errors.value, ...errors])];
  const filtered = merged.filter((err) => errors.includes(err));

  input.errors.value.splice(0, input.errors.value.length, ...filtered);
  input.valid.value = filtered.length === 0;
  input.checked.value = true;

  return input.valid.value;
};exports.validateInput = validateInput;

function isArkError(data) {
  if (!data) return false;

  return data[" arkKind"] === "errors";
}

function formatArkValidator(arkValidator) {
  if (typeof arkValidator === "string") {
    return arkValidator.replace(" ", "");
  }

  return arkValidator;
}

function getErrorMessages(arkValidators, inputId) {
  const $arkform = (0, _useArkform.useArkForm)();
  const input = $arkform.useInput(inputId);

  let validators = [...arkValidators];
  let errors = [];
  const customErrorMessages = $arkform.config.value.errors?.messages || {};
  const errorSet = $arkform.config.value.errors?.named || {};

  for (let i = 0; i < validators.length; i++) {
    let validator = validators[i];

    if (validator in errorSet) {
      validators.push(...errorSet[validator]);
      continue;
    }

    validator = formatArkValidator(validator);

    let result;
    try {
      const InputValidator = (0, _arktype.type)(validator);
      result = InputValidator(input.value.value);
    } catch (e) {}

    if (!isArkError(result)) continue;

    const defaultError = result[0].problem.split("(was)")[0];
    const customError = customErrorMessages[validator];

    if (customError) {
      errors.push(customError);
    } else {
      errors.push(defaultError);
    }
  }

  return errors;
} /* v9-ee54097069a5af1a */
