"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeUnboundableMessage = exports.writeInvalidLengthBoundMessage = exports.parseExclusiveKey = exports.parseDateLimit = exports.dateLimitToString = exports.createLengthSchemaNormalizer = exports.createLengthRuleParser = exports.createDateSchemaNormalizer = exports.compileComparator = exports.boundKindPairsByLower = exports.BaseRange = void 0;var _util = require("@ark/util");
var _constraint = require("../constraint.js");
class BaseRange extends _constraint.InternalPrimitiveConstraint {
  boundOperandKind = operandKindsByBoundKind[this.kind];
  compiledActual = this.boundOperandKind === "value" ? `data` :
  this.boundOperandKind === "length" ? `data.length` :
  `data.valueOf()`;
  comparator = compileComparator(this.kind, this.exclusive);
  numericLimit = this.rule.valueOf();
  expression = `${this.comparator} ${this.rule}`;
  compiledCondition = `${this.compiledActual} ${this.comparator} ${this.numericLimit}`;
  compiledNegation = `${this.compiledActual} ${negatedComparators[this.comparator]} ${this.numericLimit}`;
  // we need to compute stringLimit before errorContext, which references it
  // transitively through description for date bounds
  stringLimit = this.boundOperandKind === "date" ?
  dateLimitToString(this.numericLimit) :
  `${this.numericLimit}`;
  limitKind = this.comparator["0"] === "<" ? "upper" : "lower";
  isStricterThan(r) {
    const thisLimitIsStricter = this.limitKind === "upper" ?
    this.numericLimit < r.numericLimit :
    this.numericLimit > r.numericLimit;
    return thisLimitIsStricter ||
    this.numericLimit === r.numericLimit &&
    this.exclusive === true &&
    !r.exclusive;
  }
  overlapsRange(r) {
    if (this.isStricterThan(r))
    return false;
    if (this.numericLimit === r.numericLimit && (this.exclusive || r.exclusive))
    return false;
    return true;
  }
  overlapIsUnit(r) {
    return this.numericLimit === r.numericLimit && !this.exclusive && !r.exclusive;
  }
}exports.BaseRange = BaseRange;
const negatedComparators = {
  "<": ">=",
  "<=": ">",
  ">": "<=",
  ">=": "<"
};
const boundKindPairsByLower = exports.boundKindPairsByLower = {
  min: "max",
  minLength: "maxLength",
  after: "before"
};
const parseExclusiveKey = exports.parseExclusiveKey = {
  // omit key with value false since it is the default
  parse: (flag) => flag || undefined
};
const createLengthSchemaNormalizer = (kind) => (schema) => {
  if (typeof schema === "number")
  return { rule: schema };
  const { exclusive, ...normalized } = schema;
  return exclusive ?
  {
    ...normalized,
    rule: kind === "minLength" ? normalized.rule + 1 : normalized.rule - 1
  } :
  normalized;
};exports.createLengthSchemaNormalizer = createLengthSchemaNormalizer;
const createDateSchemaNormalizer = (kind) => (schema) => {
  if (typeof schema === "number" ||
  typeof schema === "string" ||
  schema instanceof Date)
  return { rule: schema };
  const { exclusive, ...normalized } = schema;
  if (!exclusive)
  return normalized;
  const numericLimit = typeof normalized.rule === "number" ? normalized.rule :
  typeof normalized.rule === "string" ?
  new Date(normalized.rule).valueOf() :
  normalized.rule.valueOf();
  return exclusive ?
  {
    ...normalized,
    rule: kind === "after" ? numericLimit + 1 : numericLimit - 1
  } :
  normalized;
};exports.createDateSchemaNormalizer = createDateSchemaNormalizer;
const parseDateLimit = (limit) => typeof limit === "string" || typeof limit === "number" ?
new Date(limit) :
limit;exports.parseDateLimit = parseDateLimit;
const writeInvalidLengthBoundMessage = (kind, limit) => `${kind} bound must be a positive integer (was ${limit})`;exports.writeInvalidLengthBoundMessage = writeInvalidLengthBoundMessage;
const createLengthRuleParser = (kind) => (limit) => {
  if (!Number.isInteger(limit) || limit < 0)
  (0, _util.throwParseError)(writeInvalidLengthBoundMessage(kind, limit));
  return limit;
};exports.createLengthRuleParser = createLengthRuleParser;
const operandKindsByBoundKind = {
  min: "value",
  max: "value",
  minLength: "length",
  maxLength: "length",
  after: "date",
  before: "date"
};
const compileComparator = (kind, exclusive) => `${(0, _util.isKeyOf)(kind, boundKindPairsByLower) ? ">" : "<"}${exclusive ? "" : "="}`;exports.compileComparator = compileComparator;
const dateLimitToString = (limit) => typeof limit === "string" ? limit : new Date(limit).toLocaleString();exports.dateLimitToString = dateLimitToString;
const writeUnboundableMessage = (root) => `Bounded expression ${root} must be exactly one of number, string, Array, or Date`;exports.writeUnboundableMessage = writeUnboundableMessage; /* v9-1a3fc4817f1a6355 */
