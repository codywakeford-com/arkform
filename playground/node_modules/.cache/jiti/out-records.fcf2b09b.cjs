"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.withAlphabetizedKeys = exports.unset = exports.stringAndSymbolicEntriesOf = exports.splitByKeys = exports.pick = exports.omit = exports.keysOf = exports.isKeyOf = exports.isEmptyObject = exports.invert = exports.hasKey = exports.hasDefinedKey = exports.fromEntries = exports.enumValues = exports.entriesOf = exports.defineProperties = exports.NoopBase = exports.InnerDynamicBase = exports.DynamicBase = exports.CastableBase = void 0;var _errors = require("./errors.js");
var _flatMorph = require("./flatMorph.js");
/**
 * Object.entries wrapper providing narrowed types for objects with known sets
 * of keys, e.g. those defined internally as configs
 */
const entriesOf = exports.entriesOf = Object.entries;
const fromEntries = (entries) => Object.fromEntries(entries);exports.fromEntries = fromEntries;
const keysOf = (o) => Object.keys(o);exports.keysOf = keysOf;
const isKeyOf = (k, o) => k in o;exports.isKeyOf = isKeyOf;
const hasKey = (o, k) => k in o;
// must be defined this way to avoid https://github.com/microsoft/TypeScript/issues/55049
exports.hasKey = hasKey;const hasDefinedKey = (o, k) => o[k] !== undefined;exports.hasDefinedKey = hasDefinedKey;
const InnerDynamicBase = class {};exports.InnerDynamicBase = InnerDynamicBase;

class DynamicBase {
  constructor(properties) {
    Object.assign(this, properties);
  }
}exports.DynamicBase = DynamicBase;
const NoopBase = class {};

/** @ts-ignore (needed to extend `t`) **/exports.NoopBase = NoopBase;
class CastableBase extends NoopBase {}exports.CastableBase = CastableBase;

const splitByKeys = (o, leftKeys) => {
  const l = {};
  const r = {};
  let k;
  for (k in o) {
    if (k in leftKeys)
    l[k] = o[k];else

    r[k] = o[k];
  }
  return [l, r];
};exports.splitByKeys = splitByKeys;
const pick = (o, keys) => splitByKeys(o, keys)[0];exports.pick = pick;
const omit = (o, keys) => splitByKeys(o, keys)[1];exports.omit = omit;
const isEmptyObject = (o) => Object.keys(o).length === 0;exports.isEmptyObject = isEmptyObject;
const stringAndSymbolicEntriesOf = (o) => [
...Object.entries(o),
...Object.getOwnPropertySymbols(o).map((k) => [k, o[k]])];

/** Like Object.assign, but it will preserve getters instead of evaluating them. */exports.stringAndSymbolicEntriesOf = stringAndSymbolicEntriesOf;
const defineProperties = (base, merged) =>
// declared like this to avoid https://github.com/microsoft/TypeScript/issues/55049
Object.defineProperties(base, Object.getOwnPropertyDescriptors(merged));
/** Copies enumerable keys of o to a new object in alphabetical order */exports.defineProperties = defineProperties;
const withAlphabetizedKeys = (o) => {
  const keys = Object.keys(o).sort();
  const result = {};
  for (let i = 0; i < keys.length; i++)
  result[keys[i]] = o[keys[i]];
  return result;
};exports.withAlphabetizedKeys = withAlphabetizedKeys;
const invert = (t) => (0, _flatMorph.flatMorph)(t, (k, v) => [v, k]);exports.invert = invert;
const unset = exports.unset = (0, _errors.noSuggest)("represents an uninitialized value");
const enumValues = (tsEnum) => Object.values(tsEnum).filter((v) => {
  if (typeof v === "number")
  return true;
  return typeof tsEnum[v] !== "number";
});exports.enumValues = enumValues; /* v9-62e9ee28bea91deb */
