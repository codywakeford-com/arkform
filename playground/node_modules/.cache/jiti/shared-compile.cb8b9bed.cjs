"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.serializeLiteralKey = exports.indexPropAccess = exports.compileSerializedValue = exports.compileLiteralPropAccess = exports.NodeCompiler = exports.CompiledFunction = void 0;var _util = require("@ark/util");
var _registry = require("./registry.js");
class CompiledFunction extends _util.CastableBase {
  argNames;
  body = "";
  constructor(...args) {
    super();
    this.argNames = args;
    for (const arg of args) {
      if (arg in this) {
        throw new Error(`Arg name '${arg}' would overwrite an existing property on FunctionBody`);
      }
      ;
      this[arg] = arg;
    }
  }
  indentation = 0;
  indent() {
    this.indentation += 4;
    return this;
  }
  dedent() {
    this.indentation -= 4;
    return this;
  }
  prop(key, optional = false) {
    return compileLiteralPropAccess(key, optional);
  }
  index(key, optional = false) {
    return indexPropAccess(`${key}`, optional);
  }
  line(statement) {
    ;
    this.body += `${" ".repeat(this.indentation)}${statement}\n`;
    return this;
  }
  const(identifier, expression) {
    this.line(`const ${identifier} = ${expression}`);
    return this;
  }
  let(identifier, expression) {
    return this.line(`let ${identifier} = ${expression}`);
  }
  set(identifier, expression) {
    return this.line(`${identifier} = ${expression}`);
  }
  if(condition, then) {
    return this.block(`if (${condition})`, then);
  }
  elseIf(condition, then) {
    return this.block(`else if (${condition})`, then);
  }
  else(then) {
    return this.block("else", then);
  }
  /** Current index is "i" */
  for(until, body, initialValue = 0) {
    return this.block(`for (let i = ${initialValue}; ${until}; i++)`, body);
  }
  /** Current key is "k" */
  forIn(object, body) {
    return this.block(`for (const k in ${object})`, body);
  }
  block(prefix, contents, suffix = "") {
    this.line(`${prefix} {`);
    this.indent();
    contents(this);
    this.dedent();
    return this.line(`}${suffix}`);
  }
  return(expression = "") {
    return this.line(`return ${expression}`);
  }
  write(name = "anonymous", indent = 0) {
    return `${name}(${this.argNames.join(", ")}) { ${indent ?
    this.body.
    split("\n").
    map((l) => " ".repeat(indent) + `${l}`).
    join("\n") :
    this.body} }`;
  }
  compile() {
    return new _util.DynamicFunction(...this.argNames, this.body);
  }
}exports.CompiledFunction = CompiledFunction;
const compileSerializedValue = (value) => (0, _util.hasDomain)(value, "object") || typeof value === "symbol" ?
(0, _registry.registeredReference)(value) :
(0, _util.serializePrimitive)(value);exports.compileSerializedValue = compileSerializedValue;
const compileLiteralPropAccess = (key, optional = false) => {
  if (typeof key === "string" && (0, _util.isDotAccessible)(key))
  return `${optional ? "?" : ""}.${key}`;
  return indexPropAccess(serializeLiteralKey(key), optional);
};exports.compileLiteralPropAccess = compileLiteralPropAccess;
const serializeLiteralKey = (key) => typeof key === "symbol" ? (0, _registry.registeredReference)(key) : JSON.stringify(key);exports.serializeLiteralKey = serializeLiteralKey;
const indexPropAccess = (key, optional = false) => `${optional ? "?." : ""}[${key}]`;exports.indexPropAccess = indexPropAccess;
class NodeCompiler extends CompiledFunction {
  traversalKind;
  optimistic;
  constructor(ctx) {
    super("data", "ctx");
    this.traversalKind = ctx.kind;
    this.optimistic = ctx.optimistic === true;
  }
  invoke(node, opts) {
    const arg = opts?.arg ?? this.data;
    const requiresContext = typeof node === "string" ? true : this.requiresContextFor(node);
    const id = typeof node === "string" ? node : node.id;
    if (requiresContext)
    return `${this.referenceToId(id, opts)}(${arg}, ${this.ctx})`;
    return `${this.referenceToId(id, opts)}(${arg})`;
  }
  referenceToId(id, opts) {
    const invokedKind = opts?.kind ?? this.traversalKind;
    const base = `this.${id}${invokedKind}`;
    return opts?.bind ? `${base}.bind(${opts?.bind})` : base;
  }
  requiresContextFor(node) {
    return this.traversalKind === "Apply" || node.allowsRequiresContext;
  }
  initializeErrorCount() {
    return this.const("errorCount", "ctx.currentErrorCount");
  }
  returnIfFail() {
    return this.if("ctx.currentErrorCount > errorCount", () => this.return());
  }
  returnIfFailFast() {
    return this.if("ctx.failFast && ctx.currentErrorCount > errorCount", () => this.return());
  }
  traverseKey(keyExpression, accessExpression, node) {
    const requiresContext = this.requiresContextFor(node);
    if (requiresContext)
    this.line(`${this.ctx}.path.push(${keyExpression})`);
    this.check(node, {
      arg: accessExpression
    });
    if (requiresContext)
    this.line(`${this.ctx}.path.pop()`);
    return this;
  }
  check(node, opts) {
    return this.traversalKind === "Allows" ?
    this.if(`!${this.invoke(node, opts)}`, () => this.return(false)) :
    this.line(this.invoke(node, opts));
  }
}exports.NodeCompiler = NodeCompiler; /* v9-bd31571091f26356 */
