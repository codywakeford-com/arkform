"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeNonArraySpreadMessage = exports.spreadOptionalMessage = exports.spreadDefaultableMessage = exports.requiredPostOptionalMessage = exports.parseTupleLiteral = exports.optionalOrDefaultableAfterVariadicMessage = exports.multipleVariadicMesage = exports.defaultablePostOptionalMessage = void 0;var _schema = require("@ark/schema");
var _util = require("@ark/util");
var _property = require("./property.js");
const parseTupleLiteral = (def, ctx) => {
  let sequences = [{}];
  let i = 0;
  while (i < def.length) {
    let spread = false;
    if (def[i] === "..." && i < def.length - 1) {
      spread = true;
      i++;
    }
    const parsedProperty = (0, _property.parseProperty)(def[i], ctx);
    const [valueNode, operator, possibleDefaultValue] = !(0, _util.isArray)(parsedProperty) ? [parsedProperty] : parsedProperty;
    i++;
    if (spread) {
      if (!valueNode.extends(_schema.$ark.intrinsic.Array))
      return (0, _util.throwParseError)(writeNonArraySpreadMessage(valueNode.expression));
      // a spread must be distributed over branches e.g.:
      // def: [string, ...(number[] | [true, false])]
      // nodes: [string, ...number[]] | [string, true, false]
      sequences = sequences.flatMap((base) =>
      // since appendElement mutates base, we have to shallow-ish clone it for each branch
      valueNode.distribute((branch) => appendSpreadBranch((0, _schema.makeRootAndArrayPropertiesMutable)(base), branch)));
    } else
    {
      sequences = sequences.map((base) => {
        if (operator === "?")
        return appendOptionalElement(base, valueNode);
        if (operator === "=")
        return appendDefaultableElement(base, valueNode, possibleDefaultValue);
        return appendRequiredElement(base, valueNode);
      });
    }
  }
  return ctx.$.parseSchema(sequences.map((sequence) => (0, _util.isEmptyObject)(sequence) ?
  {
    proto: Array,
    exactLength: 0
  } :
  {
    proto: Array,
    sequence
  }));
};exports.parseTupleLiteral = parseTupleLiteral;
const appendRequiredElement = (base, element) => {
  if (base.defaultables || base.optionals) {
    return (0, _util.throwParseError)(base.variadic ?
    // e.g. [boolean = true, ...string[], number]
    _schema.postfixAfterOptionalOrDefaultableMessage
    // e.g. [string?, number]
    : requiredPostOptionalMessage);
  }
  if (base.variadic) {
    // e.g. [...string[], number]
    base.postfix = (0, _util.append)(base.postfix, element);
  } else
  {
    // e.g. [string, number]
    base.prefix = (0, _util.append)(base.prefix, element);
  }
  return base;
};
const appendOptionalElement = (base, element) => {
  if (base.variadic)
    // e.g. [...string[], number?]
    return (0, _util.throwParseError)(optionalOrDefaultableAfterVariadicMessage);
  // e.g. [string, number?]
  base.optionals = (0, _util.append)(base.optionals, element);
  return base;
};
const appendDefaultableElement = (base, element, value) => {
  if (base.variadic)
    // e.g. [...string[], number = 0]
    return (0, _util.throwParseError)(optionalOrDefaultableAfterVariadicMessage);
  if (base.optionals)
    // e.g. [string?, number = 0]
    return (0, _util.throwParseError)(defaultablePostOptionalMessage);
  // value's assignability to element will be checked when the
  // sequence is instantiated by @ark/schema
  // e.g. [string, number = 0]
  base.defaultables = (0, _util.append)(base.defaultables, [[element, value]]);
  return base;
};
const appendVariadicElement = (base, element) => {
  // e.g. [...string[], number, ...string[]]
  if (base.postfix)
  (0, _util.throwParseError)(multipleVariadicMesage);
  if (base.variadic) {
    if (!base.variadic.equals(element)) {
      // e.g. [...string[], ...number[]]
      (0, _util.throwParseError)(multipleVariadicMesage);
    }
    // e.g. [...string[], ...string[]]
    // do nothing, second spread doesn't change the type
  } else
  {
    // e.g. [string, ...number[]]
    base.variadic = element.internal;
  }
  return base;
};
const appendSpreadBranch = (base, branch) => {
  const spread = branch.select({ method: "find", kind: "sequence" });
  if (!spread) {
    // the only array with no sequence reference is unknown[]
    return appendVariadicElement(base, _schema.$ark.intrinsic.unknown);
  }
  if (spread.prefix)
  for (const node of spread.prefix)
  appendRequiredElement(base, node);
  if (spread.optionals)
  for (const node of spread.optionals)
  appendOptionalElement(base, node);
  if (spread.variadic)
  appendVariadicElement(base, spread.variadic);
  if (spread.postfix)
  for (const node of spread.postfix)
  appendRequiredElement(base, node);
  return base;
};
const writeNonArraySpreadMessage = (operand) => `Spread element must be an array (was ${operand})`;exports.writeNonArraySpreadMessage = writeNonArraySpreadMessage;
const multipleVariadicMesage = exports.multipleVariadicMesage = "A tuple may have at most one variadic element";
const requiredPostOptionalMessage = exports.requiredPostOptionalMessage = "A required element may not follow an optional element";
const optionalOrDefaultableAfterVariadicMessage = exports.optionalOrDefaultableAfterVariadicMessage = "An optional element may not follow a variadic element";
const spreadOptionalMessage = exports.spreadOptionalMessage = "A spread element cannot be optional";
const spreadDefaultableMessage = exports.spreadDefaultableMessage = "A spread element cannot have a default";
const defaultablePostOptionalMessage = exports.defaultablePostOptionalMessage = "A defaultable element may not follow an optional element without a default"; /* v9-71207a56c1f20b6f */
