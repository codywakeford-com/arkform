"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeMissingRightOperandMessage = exports.writeMissingOperandMessage = exports.writeExpressionExpectedMessage = exports.parseUnenclosed = exports.parseGenericInstantiation = void 0;var _schema = require("@ark/schema");
var _util = require("@ark/util");
var _validate = require("../../ast/validate.js");
var _genericArgs = require("./genericArgs.js");
const parseUnenclosed = (s) => {
  const token = s.scanner.shiftUntilNextTerminator();
  if (token === "keyof")
  s.addPrefix("keyof");else

  s.root = unenclosedToNode(s, token);
};exports.parseUnenclosed = parseUnenclosed;
const parseGenericInstantiation = (name, g, s) => {
  s.scanner.shiftUntilNonWhitespace();
  const lookahead = s.scanner.shift();
  if (lookahead !== "<")
  return s.error((0, _genericArgs.writeInvalidGenericArgCountMessage)(name, g.names, []));
  const parsedArgs = (0, _genericArgs.parseGenericArgs)(name, g, s);
  return g(...parsedArgs);
};exports.parseGenericInstantiation = parseGenericInstantiation;
const unenclosedToNode = (s, token) => maybeParseReference(s, token) ??
maybeParseUnenclosedLiteral(s, token) ??
s.error(token === "" ?
s.scanner.lookahead === "#" ?
(0, _validate.writePrefixedPrivateReferenceMessage)(s.shiftedByOne().scanner.shiftUntilNextTerminator()) :
writeMissingOperandMessage(s) :
(0, _schema.writeUnresolvableMessage)(token));
const maybeParseReference = (s, token) => {
  if (s.ctx.args?.[token]) {
    const arg = s.ctx.args[token];
    if (typeof arg !== "string")
    return arg;
    return s.ctx.$.node("alias", { reference: arg }, { prereduced: true });
  }
  const resolution = s.ctx.$.maybeResolve(token);
  if ((0, _schema.hasArkKind)(resolution, "root"))
  return resolution;
  if (resolution === undefined)
  return;
  if ((0, _schema.hasArkKind)(resolution, "generic"))
  return parseGenericInstantiation(token, resolution, s);
  return (0, _util.throwParseError)(`Unexpected resolution ${(0, _util.printable)(resolution)}`);
};
const maybeParseUnenclosedLiteral = (s, token) => {
  const maybeNumber = (0, _util.tryParseWellFormedNumber)(token);
  if (maybeNumber !== undefined)
  return s.ctx.$.node("unit", { unit: maybeNumber });
  const maybeBigint = (0, _util.tryParseWellFormedBigint)(token);
  if (maybeBigint !== undefined)
  return s.ctx.$.node("unit", { unit: maybeBigint });
};
const writeMissingOperandMessage = (s) => {
  const operator = s.previousOperator();
  return operator ?
  writeMissingRightOperandMessage(operator, s.scanner.unscanned) :
  writeExpressionExpectedMessage(s.scanner.unscanned);
};exports.writeMissingOperandMessage = writeMissingOperandMessage;
const writeMissingRightOperandMessage = (token, unscanned = "") => `Token '${token}' requires a right operand${unscanned ? ` before '${unscanned}'` : ""}`;exports.writeMissingRightOperandMessage = writeMissingRightOperandMessage;
const writeExpressionExpectedMessage = (unscanned) => `Expected an expression${unscanned ? ` before '${unscanned}'` : ""}`;exports.writeExpressionExpectedMessage = writeExpressionExpectedMessage; /* v9-cc14b03ee27441b1 */
