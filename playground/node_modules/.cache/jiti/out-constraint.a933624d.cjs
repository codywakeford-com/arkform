"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeInvalidOperandMessage = exports.unflattenConstraints = exports.throwInvalidOperandError = exports.intersectConstraints = exports.flattenConstraints = exports.constraintKeyParser = exports.InternalPrimitiveConstraint = exports.BaseConstraint = void 0;var _util = require("@ark/util");
var _node = require("./node.js");
var _disjoint = require("./shared/disjoint.js");
var _implement = require("./shared/implement.js");
var _intersections = require("./shared/intersections.js");
var _registry = require("./shared/registry.js");
var _utils = require("./shared/utils.js");
class BaseConstraint extends _node.BaseNode {
  constructor(attachments, $) {
    super(attachments, $);
    // define as a getter to avoid it being enumerable/spreadable
    Object.defineProperty(this, _utils.arkKind, {
      value: "constraint",
      enumerable: false
    });
  }
  impliedSiblings;
  intersect(r) {
    return (0, _intersections.intersectNodesRoot)(this, r, this.$);
  }
}exports.BaseConstraint = BaseConstraint;
class InternalPrimitiveConstraint extends BaseConstraint {
  traverseApply = (data, ctx) => {
    if (!this.traverseAllows(data, ctx))
    ctx.errorFromNodeContext(this.errorContext);
  };
  compile(js) {
    if (js.traversalKind === "Allows")
    js.return(this.compiledCondition);else
    {
      js.if(this.compiledNegation, () => js.line(`${js.ctx}.errorFromNodeContext(${this.compiledErrorContext})`));
    }
  }
  get errorContext() {
    return {
      code: this.kind,
      description: this.description,
      meta: this.meta,
      ...this.inner
    };
  }
  get compiledErrorContext() {
    return (0, _implement.compileObjectLiteral)(this.errorContext);
  }
}exports.InternalPrimitiveConstraint = InternalPrimitiveConstraint;
const constraintKeyParser = (kind) => (schema, ctx) => {
  if ((0, _util.isArray)(schema)) {
    if (schema.length === 0) {
      // Omit empty lists as input
      return;
    }
    const nodes = schema.map((schema) => ctx.$.node(kind, schema));
    // predicate order must be preserved to ensure inputs are narrowed
    // and checked in the correct order
    if (kind === "predicate")
    return nodes;
    return nodes.sort((l, r) => l.hash < r.hash ? -1 : 1);
  }
  const child = ctx.$.node(kind, schema);
  return child.hasOpenIntersection() ? [child] : child;
};exports.constraintKeyParser = constraintKeyParser;
const intersectConstraints = (s) => {
  const head = s.r.shift();
  if (!head) {
    let result = s.l.length === 0 && s.kind === "structure" ?
    _registry.$ark.intrinsic.unknown.internal :
    s.ctx.$.node(s.kind, Object.assign(s.baseInner, unflattenConstraints(s.l)), { prereduced: true });
    for (const root of s.roots) {
      if (result instanceof _disjoint.Disjoint)
      return result;
      result = (0, _intersections.intersectOrPipeNodes)(root, result, s.ctx);
    }
    return result;
  }
  let matched = false;
  for (let i = 0; i < s.l.length; i++) {
    const result = (0, _intersections.intersectOrPipeNodes)(s.l[i], head, s.ctx);
    if (result === null)
    continue;
    if (result instanceof _disjoint.Disjoint)
    return result;
    if (!matched) {
      if (result.isRoot()) {
        s.roots.push(result);
        s.l.splice(i);
        return intersectConstraints(s);
      }
      s.l[i] = result;
      matched = true;
    } else
    if (!s.l.includes(result)) {
      return (0, _util.throwInternalError)(`Unexpectedly encountered multiple distinct intersection results for refinement ${result}`);
    }
  }
  if (!matched)
  s.l.push(head);
  if (s.kind === "intersection") {
    if (head.impliedSiblings)
    for (const node of head.impliedSiblings)
    (0, _util.appendUnique)(s.r, node);
  }
  return intersectConstraints(s);
};exports.intersectConstraints = intersectConstraints;
const flattenConstraints = (inner) => {
  const result = Object.entries(inner).
  flatMap(([k, v]) => k in _implement.constraintKeys ? v : []).
  sort((l, r) => l.precedence < r.precedence ? -1 :
  l.precedence > r.precedence ? 1
  // preserve order for predicates
  : l.kind === "predicate" && r.kind === "predicate" ? 0 :
  l.hash < r.hash ? -1 :
  1);
  return result;
};exports.flattenConstraints = flattenConstraints;
const unflattenConstraints = (constraints) => {
  const inner = {};
  for (const constraint of constraints) {
    if (constraint.hasOpenIntersection()) {
      inner[constraint.kind] = (0, _util.append)(inner[constraint.kind], constraint);
    } else
    {
      if (inner[constraint.kind]) {
        return (0, _util.throwInternalError)(`Unexpected intersection of closed refinements of kind ${constraint.kind}`);
      }
      inner[constraint.kind] = constraint;
    }
  }
  return inner;
};exports.unflattenConstraints = unflattenConstraints;
const throwInvalidOperandError = (...args) => (0, _util.throwParseError)(writeInvalidOperandMessage(...args));exports.throwInvalidOperandError = throwInvalidOperandError;
const writeInvalidOperandMessage = (kind, expected, actual) => {
  const actualDescription = actual.hasKind("morph") ? "a morph" :
  actual.isUnknown() ? "unknown" :
  actual.exclude(expected).defaultShortDescription;
  return `${(0, _util.capitalize)(kind)} operand must be ${expected.description} (was ${actualDescription})`;
};exports.writeInvalidOperandMessage = writeInvalidOperandMessage; /* v9-ac266f7eb38770d7 */
