"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeNonIntegerDivisorMessage = exports.writeIndivisibleMessage = exports.DivisorNode = exports.Divisor = void 0;var _util = require("@ark/util");
var _constraint = require("../constraint.js");
var _implement = require("../shared/implement.js");
var _registry = require("../shared/registry.js");
const implementation = (0, _implement.implementNode)({
  kind: "divisor",
  collapsibleKey: "rule",
  keys: {
    rule: {
      parse: (divisor) => Number.isInteger(divisor) ? divisor : (0, _util.throwParseError)(writeNonIntegerDivisorMessage(divisor))
    }
  },
  normalize: (schema) => typeof schema === "number" ? { rule: schema } : schema,
  hasAssociatedError: true,
  defaults: {
    description: (node) => node.rule === 1 ? "an integer" :
    node.rule === 2 ? "even" :
    `a multiple of ${node.rule}`
  },
  intersections: {
    divisor: (l, r, ctx) => ctx.$.node("divisor", {
      rule: Math.abs(l.rule * r.rule / greatestCommonDivisor(l.rule, r.rule))
    })
  },
  obviatesBasisDescription: true
});
class DivisorNode extends _constraint.InternalPrimitiveConstraint {
  traverseAllows = (data) => data % this.rule === 0;
  compiledCondition = `data % ${this.rule} === 0`;
  compiledNegation = `data % ${this.rule} !== 0`;
  impliedBasis = _registry.$ark.intrinsic.number.internal;
  expression = `% ${this.rule}`;
  reduceJsonSchema(schema) {
    schema.type = "integer";
    if (this.rule === 1)
    return schema;
    schema.multipleOf = this.rule;
    return schema;
  }
}exports.DivisorNode = DivisorNode;
const Divisor = exports.Divisor = {
  implementation,
  Node: DivisorNode
};
const writeIndivisibleMessage = (t) => (0, _constraint.writeInvalidOperandMessage)("divisor", _registry.$ark.intrinsic.number, t);exports.writeIndivisibleMessage = writeIndivisibleMessage;
const writeNonIntegerDivisorMessage = (divisor) => `divisor must be an integer (was ${divisor})`;
// https://en.wikipedia.org/wiki/Euclidean_algorithm
exports.writeNonIntegerDivisorMessage = writeNonIntegerDivisorMessage;const greatestCommonDivisor = (l, r) => {
  let previous;
  let greatestCommonDivisor = l;
  let current = r;
  while (current !== 0) {
    previous = current;
    current = greatestCommonDivisor % current;
    greatestCommonDivisor = previous;
  }
  return greatestCommonDivisor;
}; /* v9-ab7d7501f72805f1 */
