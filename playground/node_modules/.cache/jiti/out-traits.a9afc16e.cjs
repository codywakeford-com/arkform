"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.implement = exports.hasTrait = exports.compose = exports.Trait = void 0;var _domain = require("./domain.js");
var _errors = require("./errors.js");
var _objectKinds = require("./objectKinds.js");
var _records = require("./records.js");
// even though the value we attach will be identical, we use this so classes
// won't be treated as instanceof a Trait
const implementedTraits = (0, _errors.noSuggest)("implementedTraits");
const hasTrait = (traitClass) => (o) => {
  if (!(0, _domain.hasDomain)(o, "object"))
  return false;
  if (implementedTraits in o.constructor &&
  o.constructor[implementedTraits].includes(traitClass))
  return true;
  // emulate standard instanceof behavior
  return (0, _objectKinds.ancestorsOf)(o).includes(traitClass);
};
/** @ts-ignore required to extend NoopBase */exports.hasTrait = hasTrait;
class Trait extends _records.NoopBase {
  static get [Symbol.hasInstance]() {
    return hasTrait(this);
  }
  traitsOf() {
    return implementedTraits in this.constructor ?
    this.constructor[implementedTraits] :
    [];
  }
}exports.Trait = Trait;
const collectPrototypeDescriptors = (trait) => {
  let proto = trait.prototype;
  let result = {};
  do {
    // ensure prototypes are sorted from lowest to highest precedence
    result = Object.assign(Object.getOwnPropertyDescriptors(proto), result);
    proto = Object.getPrototypeOf(proto);
  } while (proto !== Object.prototype && proto !== null);
  return result;
};
const compose = (...traits) => {
  const base = function (...args) {
    for (const trait of traits) {
      const instance = Reflect.construct(trait, args, this.constructor);
      Object.assign(this, instance);
    }
  };
  const flatImplementedTraits = [];
  for (const trait of traits) {
    // copy static properties
    Object.assign(base, trait);
    // flatten and copy prototype
    Object.defineProperties(base.prototype, collectPrototypeDescriptors(trait));
    if (implementedTraits in trait) {
      // add any ancestor traits from which the current trait was composed
      for (const innerTrait of trait[implementedTraits]) {
        if (!flatImplementedTraits.includes(innerTrait))
        flatImplementedTraits.push(innerTrait);
      }
    }
    if (!flatImplementedTraits.includes(trait))
    flatImplementedTraits.push(trait);
  }
  Object.defineProperty(base, implementedTraits, {
    value: flatImplementedTraits,
    enumerable: false
  });
  return base;
};exports.compose = compose;
const implement = (...args) => {
  if (args.at(-1) instanceof Trait)
  return compose(...args);
  const implementation = args.at(-1);
  const base = compose(...args.slice(0, -1));
  // copy implementation last since it overrides traits
  Object.defineProperties(base.prototype, Object.getOwnPropertyDescriptors(implementation));
  return base;
};exports.implement = implement; /* v9-508bc649cdcdf0d8 */
