"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeDefaultIntersectionMessage = exports.intersectProps = exports.BaseProp = void 0;var _util = require("@ark/util");
var _constraint = require("../constraint.js");
var _node = require("../node.js");
var _compile = require("../shared/compile.js");
var _disjoint = require("../shared/disjoint.js");
var _intersections = require("../shared/intersections.js");
var _registry = require("../shared/registry.js");
var _traversal = require("../shared/traversal.js");
const intersectProps = (l, r, ctx) => {
  if (l.key !== r.key)
  return null;
  const key = l.key;
  let value = (0, _intersections.intersectOrPipeNodes)(l.value, r.value, ctx);
  const kind = l.required || r.required ? "required" : "optional";
  if (value instanceof _disjoint.Disjoint) {
    if (kind === "optional")
    value = _registry.$ark.intrinsic.never.internal;else
    {
      // if either operand was optional, the Disjoint has to be treated as optional
      return value.withPrefixKey(l.key, l.required && r.required ? "required" : "optional");
    }
  }
  if (kind === "required") {
    return ctx.$.node("required", {
      key,
      value
    });
  }
  const defaultIntersection = l.hasDefault() ?
  r.hasDefault() ?
  l.default === r.default ?
  l.default :
  (0, _util.throwParseError)(writeDefaultIntersectionMessage(l.default, r.default)) :
  l.default :
  r.hasDefault() ? r.default :
  _util.unset;
  return ctx.$.node("optional", {
    key,
    value,
    // unset is stripped during parsing
    default: defaultIntersection
  });
};exports.intersectProps = intersectProps;
class BaseProp extends _constraint.BaseConstraint {
  required = this.kind === "required";
  optional = this.kind === "optional";
  impliedBasis = _registry.$ark.intrinsic.object.internal;
  serializedKey = (0, _compile.compileSerializedValue)(this.key);
  compiledKey = typeof this.key === "string" ? this.key : this.serializedKey;
  flatRefs = (0, _util.append)(this.value.flatRefs.map((ref) => (0, _node.flatRef)([this.key, ...ref.path], ref.node)), (0, _node.flatRef)([this.key], this.value));
  _transform(mapper, ctx) {
    ctx.path.push(this.key);
    const result = super._transform(mapper, ctx);
    ctx.path.pop();
    return result;
  }
  hasDefault() {
    return "default" in this.inner;
  }
  traverseAllows = (data, ctx) => {
    if (this.key in data) {
      // ctx will be undefined if this node isn't context-dependent
      return (0, _traversal.traverseKey)(this.key, () => this.value.traverseAllows(data[this.key], ctx), ctx);
    }
    return this.optional;
  };
  traverseApply = (data, ctx) => {
    if (this.key in data) {
      (0, _traversal.traverseKey)(this.key, () => this.value.traverseApply(data[this.key], ctx), ctx);
    } else
    if (this.hasKind("required"))
    ctx.errorFromNodeContext(this.errorContext);
  };
  compile(js) {
    js.if(`${this.serializedKey} in data`, () => js.traverseKey(this.serializedKey, `data${js.prop(this.key)}`, this.value));
    if (this.hasKind("required")) {
      js.else(() => js.traversalKind === "Apply" ?
      js.line(`ctx.errorFromNodeContext(${this.compiledErrorContext})`) :
      js.return(false));
    }
    if (js.traversalKind === "Allows")
    js.return(true);
  }
}exports.BaseProp = BaseProp;
const writeDefaultIntersectionMessage = (lValue, rValue) => `Invalid intersection of default values ${(0, _util.printable)(lValue)} & ${(0, _util.printable)(rValue)}`;exports.writeDefaultIntersectionMessage = writeDefaultIntersectionMessage; /* v9-182a998b6d2a898e */
