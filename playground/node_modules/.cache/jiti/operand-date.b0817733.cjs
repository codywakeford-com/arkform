"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeInvalidDateMessage = exports.tryParseDate = exports.isValidDate = exports.isDateLiteral = exports.extractDateLiteralSource = void 0;var _util = require("@ark/util");
const isDateLiteral = (value) => typeof value === "string" &&
value[0] === "d" && (
value[1] === "'" || value[1] === '"') &&
value.at(-1) === value[1];exports.isDateLiteral = isDateLiteral;
const isValidDate = (d) => d.toString() !== "Invalid Date";exports.isValidDate = isValidDate;
const extractDateLiteralSource = (literal) => literal.slice(2, -1);exports.extractDateLiteralSource = extractDateLiteralSource;
const writeInvalidDateMessage = (source) => `'${source}' could not be parsed by the Date constructor`;exports.writeInvalidDateMessage = writeInvalidDateMessage;
const tryParseDate = (source, errorOnFail) => maybeParseDate(source, errorOnFail);exports.tryParseDate = tryParseDate;
const maybeParseDate = (source, errorOnFail) => {
  const stringParsedDate = new Date(source);
  if (isValidDate(stringParsedDate))
  return stringParsedDate;
  const epochMillis = (0, _util.tryParseNumber)(source);
  if (epochMillis !== undefined) {
    const numberParsedDate = new Date(epochMillis);
    if (isValidDate(numberParsedDate))
    return numberParsedDate;
  }
  return errorOnFail ?
  (0, _util.throwParseError)(errorOnFail === true ? writeInvalidDateMessage(source) : errorOnFail) :
  undefined;
}; /* v9-085224b88443a5c6 */
