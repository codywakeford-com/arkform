"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeBadDefinitionTypeMessage = exports.parseTuple = exports.parseObject = exports.parseInnerDefinition = void 0;var _schema = require("@ark/schema");
var _util = require("@ark/util");
var _objectLiteral = require("./objectLiteral.js");
var _string = require("./string.js");
var _tupleExpressions = require("./tupleExpressions.js");
var _tupleLiteral = require("./tupleLiteral.js");
const parseCache = {};
const parseInnerDefinition = (def, ctx) => {
  if (typeof def === "string") {
    if (ctx.args && Object.keys(ctx.args).some((k) => def.includes(k))) {
      // we can only rely on the cache if there are no contextual
      // resolutions like "this" or generic args
      return (0, _string.parseString)(def, ctx);
    }
    const scopeCache = parseCache[ctx.$.name] ??= {};
    return scopeCache[def] ??= (0, _string.parseString)(def, ctx);
  }
  return (0, _util.hasDomain)(def, "object") ?
  parseObject(def, ctx) :
  (0, _util.throwParseError)(writeBadDefinitionTypeMessage((0, _util.domainOf)(def)));
};exports.parseInnerDefinition = parseInnerDefinition;
const parseObject = (def, ctx) => {
  const objectKind = (0, _util.objectKindOf)(def);
  switch (objectKind) {
    case undefined:
      if ((0, _schema.hasArkKind)(def, "root"))
      return def;
      return (0, _objectLiteral.parseObjectLiteral)(def, ctx);
    case "Array":
      return parseTuple(def, ctx);
    case "RegExp":
      return ctx.$.node("intersection", {
        domain: "string",
        pattern: def
      }, { prereduced: true });
    case "Function":{
        const resolvedDef = (0, _util.isThunk)(def) ? def() : def;
        if ((0, _schema.hasArkKind)(resolvedDef, "root"))
        return resolvedDef;
        return (0, _util.throwParseError)(writeBadDefinitionTypeMessage("Function"));
      }
    default:
      return (0, _util.throwParseError)(writeBadDefinitionTypeMessage(objectKind ?? (0, _util.printable)(def)));
  }
};exports.parseObject = parseObject;
const parseTuple = (def, ctx) => (0, _tupleExpressions.maybeParseTupleExpression)(def, ctx) ?? (0, _tupleLiteral.parseTupleLiteral)(def, ctx);exports.parseTuple = parseTuple;
const writeBadDefinitionTypeMessage = (actual) => `Type definitions must be strings or objects (was ${actual})`;exports.writeBadDefinitionTypeMessage = writeBadDefinitionTypeMessage; /* v9-2f2cc787b855924b */
