"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.UnitNode = exports.Unit = void 0;var _util = require("@ark/util");
var _disjoint = require("../shared/disjoint.js");
var _implement = require("../shared/implement.js");
var _registry = require("../shared/registry.js");
var _basis = require("./basis.js");
var _utils = require("./utils.js");
const implementation = (0, _implement.implementNode)({
  kind: "unit",
  hasAssociatedError: true,
  keys: {
    unit: {
      preserveUndefined: true,
      serialize: (schema) => schema instanceof Date ?
      schema.toISOString() :
      (0, _implement.defaultValueSerializer)(schema)
    }
  },
  normalize: (schema) => schema,
  defaults: {
    description: (node) => (0, _util.printable)(node.unit),
    problem: ({ expected, actual }) => `${expected === actual ? `must be reference equal to ${expected} (serialized to the same value)` : `must be ${expected} (was ${actual})`}`
  },
  intersections: {
    unit: (l, r) => _disjoint.Disjoint.init("unit", l, r),
    ...(0, _utils.defineRightwardIntersections)("unit", (l, r) => {
      if (r.allows(l.unit))
      return l;
      // will always be a disjoint at this point, but we try to use
      // a domain Disjoint if possible since it's better for discrimination
      const rBasis = r.hasKind("intersection") ? r.basis : r;
      if (rBasis) {
        const rDomain = rBasis.hasKind("domain") ? rBasis : _registry.$ark.intrinsic.object;
        if (l.domain !== rDomain.domain) {
          const lDomainDisjointValue = l.domain === "undefined" ||
          l.domain === "null" ||
          l.domain === "boolean" ?
          l.domain :
          _registry.$ark.intrinsic[l.domain];
          return _disjoint.Disjoint.init("domain", lDomainDisjointValue, rDomain);
        }
      }
      return _disjoint.Disjoint.init("assignability", l, r.hasKind("intersection") ?
      r.children.find((rConstraint) => !rConstraint.allows(l.unit)) :
      r);
    })
  }
});
class UnitNode extends _basis.InternalBasis {
  compiledValue = this.json.unit;
  serializedValue = typeof this.unit === "string" || this.unit instanceof Date ?
  JSON.stringify(this.compiledValue) :
  `${this.compiledValue}`;
  compiledCondition = compileEqualityCheck(this.unit, this.serializedValue);
  compiledNegation = compileEqualityCheck(this.unit, this.serializedValue, "negated");
  expression = (0, _util.printable)(this.unit);
  domain = (0, _util.domainOf)(this.unit);
  get defaultShortDescription() {
    return this.domain === "object" ?
    _util.domainDescriptions.object :
    this.description;
  }
  innerToJsonSchema(ctx) {
    return (
      // this is the more standard JSON schema representation, especially for Open API
      this.unit === null ? { type: "null" } :
      _registry.$ark.intrinsic.jsonPrimitive.allows(this.unit) ? { const: this.unit } :
      ctx.fallback.unit({ code: "unit", base: {}, unit: this.unit }));
  }
  traverseAllows = this.unit instanceof Date ?
  (data) => data instanceof Date && data.toISOString() === this.compiledValue :
  Number.isNaN(this.unit) ? (data) => Number.isNaN(data) :
  (data) => data === this.unit;
}exports.UnitNode = UnitNode;
const Unit = exports.Unit = {
  implementation,
  Node: UnitNode
};
const compileEqualityCheck = (unit, serializedValue, negated) => {
  if (unit instanceof Date) {
    const condition = `data instanceof Date && data.toISOString() === ${serializedValue}`;
    return negated ? `!(${condition})` : condition;
  }
  if (Number.isNaN(unit))
  return `${negated ? "!" : ""}Number.isNaN(data)`;
  return `data ${negated ? "!" : "="}== ${serializedValue}`;
}; /* v9-e0c1e10b0b05840a */
