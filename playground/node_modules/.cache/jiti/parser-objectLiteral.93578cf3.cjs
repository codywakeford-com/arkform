"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeInvalidUndeclaredBehaviorMessage = exports.writeInvalidSpreadTypeMessage = exports.preparseKey = exports.parseObjectLiteral = exports.nonLeadingSpreadError = void 0;var _schema = require("@ark/schema");
var _util = require("@ark/util");
var _property = require("./property.js");
const parseObjectLiteral = (def, ctx) => {
  let spread;
  const structure = {};
  // We only allow a spread operator to be used as the first key in an object
  // because to match JS behavior any keys before the spread are overwritten
  // by the values in the target object, so there'd be no useful purpose in having it
  // anywhere except for the beginning.
  const defEntries = (0, _util.stringAndSymbolicEntriesOf)(def);
  for (const [k, v] of defEntries) {
    const parsedKey = preparseKey(k);
    if (parsedKey.kind === "spread") {
      if (!(0, _util.isEmptyObject)(structure))
      return (0, _util.throwParseError)(nonLeadingSpreadError);
      const operand = ctx.$.parseOwnDefinitionFormat(v, ctx);
      // treat object domain as empty for spreading (useful for generic constraints)
      if (operand.equals(_schema.intrinsic.object))
      continue;
      if (!operand.hasKind("intersection") ||
      // still error on attempts to spread proto nodes like ...Date
      !operand.basis?.equals(_schema.intrinsic.object)) {
        return (0, _util.throwParseError)(writeInvalidSpreadTypeMessage(operand.expression));
      }
      spread = operand.structure;
      continue;
    }
    if (parsedKey.kind === "undeclared") {
      if (v !== "reject" && v !== "delete" && v !== "ignore")
      (0, _util.throwParseError)(writeInvalidUndeclaredBehaviorMessage(v));
      structure.undeclared = v;
      continue;
    }
    const parsedValue = (0, _property.parseProperty)(v, ctx);
    const parsedEntryKey = parsedKey;
    if (parsedKey.kind === "required") {
      if (!(0, _util.isArray)(parsedValue)) {
        appendNamedProp(structure, "required", {
          key: parsedKey.normalized,
          value: parsedValue
        }, ctx);
      } else
      {
        appendNamedProp(structure, "optional", parsedValue[1] === "=" ?
        {
          key: parsedKey.normalized,
          value: parsedValue[0],
          default: parsedValue[2]
        } :
        {
          key: parsedKey.normalized,
          value: parsedValue[0]
        }, ctx);
      }
      continue;
    }
    if ((0, _util.isArray)(parsedValue)) {
      if (parsedValue[1] === "?")
      (0, _util.throwParseError)(_property.invalidOptionalKeyKindMessage);
      if (parsedValue[1] === "=")
      (0, _util.throwParseError)(_property.invalidDefaultableKeyKindMessage);
    }
    // value must be a BaseRoot at this point
    if (parsedKey.kind === "optional") {
      appendNamedProp(structure, "optional", {
        key: parsedKey.normalized,
        value: parsedValue
      }, ctx);
      continue;
    }
    // must be index at this point
    const signature = ctx.$.parseOwnDefinitionFormat(parsedEntryKey.normalized, ctx);
    const normalized = (0, _schema.normalizeIndex)(signature, parsedValue, ctx.$);
    if (normalized.index)
    structure.index = (0, _util.append)(structure.index, normalized.index);
    if (normalized.required)
    structure.required = (0, _util.append)(structure.required, normalized.required);
  }
  const structureNode = ctx.$.node("structure", structure);
  return ctx.$.parseSchema({
    domain: "object",
    structure: spread?.merge(structureNode) ?? structureNode
  });
};exports.parseObjectLiteral = parseObjectLiteral;
const appendNamedProp = (structure, kind, inner, ctx) => {
  structure[kind] = (0, _util.append)(
    // doesn't seem like this cast should be necessary
    structure[kind], ctx.$.node(kind, inner));
};
const writeInvalidUndeclaredBehaviorMessage = (actual) => `Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${(0, _util.printable)(actual)})`;exports.writeInvalidUndeclaredBehaviorMessage = writeInvalidUndeclaredBehaviorMessage;
const nonLeadingSpreadError = exports.nonLeadingSpreadError = "Spread operator may only be used as the first key in an object";
const preparseKey = (key) => typeof key === "symbol" ? { kind: "required", normalized: key } :
key.at(-1) === "?" ?
key.at(-2) === _util.escapeChar ?
{ kind: "required", normalized: `${key.slice(0, -2)}?` } :
{
  kind: "optional",
  normalized: key.slice(0, -1)
} :
key[0] === "[" && key.at(-1) === "]" ?
{ kind: "index", normalized: key.slice(1, -1) } :
key[0] === _util.escapeChar && key[1] === "[" && key.at(-1) === "]" ?
{ kind: "required", normalized: key.slice(1) } :
key === "..." ? { kind: "spread" } :
key === "+" ? { kind: "undeclared" } :
{
  kind: "required",
  normalized: key === "\\..." ? "..." :
  key === "\\+" ? "+" :
  key
};exports.preparseKey = preparseKey;
const writeInvalidSpreadTypeMessage = (def) => `Spread operand must resolve to an object literal type (was ${def})`;exports.writeInvalidSpreadTypeMessage = writeInvalidSpreadTypeMessage; /* v9-2d41e53ff4694b02 */
