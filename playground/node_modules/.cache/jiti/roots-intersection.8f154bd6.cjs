"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.IntersectionNode = exports.Intersection = void 0;var _util = require("@ark/util");
var _constraint = require("../constraint.js");
var _disjoint = require("../shared/disjoint.js");
var _implement = require("../shared/implement.js");
var _intersections = require("../shared/intersections.js");
var _utils = require("../shared/utils.js");
var _root = require("./root.js");
var _utils2 = require("./utils.js");
const implementation = (0, _implement.implementNode)({
  kind: "intersection",
  hasAssociatedError: true,
  normalize: (rawSchema) => {
    if ((0, _utils.isNode)(rawSchema))
    return rawSchema;
    const { structure, ...schema } = rawSchema;
    const hasRootStructureKey = !!structure;
    const normalizedStructure = structure ?? {};
    const normalized = (0, _util.flatMorph)(schema, (k, v) => {
      if ((0, _util.isKeyOf)(k, _implement.structureKeys)) {
        if (hasRootStructureKey) {
          (0, _util.throwParseError)(`Flattened structure key ${k} cannot be specified alongside a root 'structure' key.`);
        }
        normalizedStructure[k] = v;
        return [];
      }
      return [k, v];
    });
    if ((0, _utils.hasArkKind)(normalizedStructure, "constraint") ||
    !(0, _util.isEmptyObject)(normalizedStructure))
    normalized.structure = normalizedStructure;
    return normalized;
  },
  finalizeInnerJson: ({ structure, ...rest }) => (0, _util.hasDomain)(structure, "object") ? { ...structure, ...rest } : rest,
  keys: {
    domain: {
      child: true,
      parse: (schema, ctx) => ctx.$.node("domain", schema)
    },
    proto: {
      child: true,
      parse: (schema, ctx) => ctx.$.node("proto", schema)
    },
    structure: {
      child: true,
      parse: (schema, ctx) => ctx.$.node("structure", schema),
      serialize: (node) => {
        if (!node.sequence?.minLength)
        return node.collapsibleJson;
        const { sequence, ...structureJson } = node.collapsibleJson;
        const { minVariadicLength, ...sequenceJson } = sequence;
        const collapsibleSequenceJson = sequenceJson.variadic && Object.keys(sequenceJson).length === 1 ?
        sequenceJson.variadic :
        sequenceJson;
        return { ...structureJson, sequence: collapsibleSequenceJson };
      }
    },
    divisor: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("divisor")
    },
    max: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("max")
    },
    min: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("min")
    },
    maxLength: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("maxLength")
    },
    minLength: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("minLength")
    },
    exactLength: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("exactLength")
    },
    before: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("before")
    },
    after: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("after")
    },
    pattern: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("pattern")
    },
    predicate: {
      child: true,
      parse: (0, _constraint.constraintKeyParser)("predicate")
    }
  },
  // leverage reduction logic from intersection and identity to ensure initial
  // parse result is reduced
  reduce: (inner, $) =>
  // we cast union out of the result here since that only occurs when intersecting two sequences
  // that cannot occur when reducing a single intersection schema using unknown
  intersectIntersections({}, inner, {
    $,
    invert: false,
    pipe: false
  }),
  defaults: {
    description: (node) => {
      if (node.children.length === 0)
      return "unknown";
      if (node.structure)
      return node.structure.description;
      const childDescriptions = [];
      if (node.basis &&
      !node.refinements.some((r) => r.impl.obviatesBasisDescription))
      childDescriptions.push(node.basis.description);
      if (node.refinements.length) {
        const sortedRefinementDescriptions = node.refinements
        // override alphabetization to describe min before max
        .toSorted((l, r) => l.kind === "min" && r.kind === "max" ? -1 : 0).
        map((r) => r.description);
        childDescriptions.push(...sortedRefinementDescriptions);
      }
      if (node.inner.predicate) {
        childDescriptions.push(...node.inner.predicate.map((p) => p.description));
      }
      return childDescriptions.join(" and ");
    },
    expected: (source) => `  ◦ ${source.errors.map((e) => e.expected).join("\n  ◦ ")}`,
    problem: (ctx) => `(${ctx.actual}) must be...\n${ctx.expected}`
  },
  intersections: {
    intersection: (l, r, ctx) => intersectIntersections(l.inner, r.inner, ctx),
    ...(0, _utils2.defineRightwardIntersections)("intersection", (l, r, ctx) => {
      // if l is unknown, return r
      if (l.children.length === 0)
      return r;
      const { domain, proto, ...lInnerConstraints } = l.inner;
      const lBasis = proto ?? domain;
      const basis = lBasis ? (0, _intersections.intersectOrPipeNodes)(lBasis, r, ctx) : r;
      return basis instanceof _disjoint.Disjoint ? basis :
      l?.basis?.equals(basis) ?
      // if the basis doesn't change, return the original intesection
      l
      // given we've already precluded l being unknown, the result must
      // be an intersection with the new basis result integrated
      : l.$.node("intersection", { ...lInnerConstraints, [basis.kind]: basis }, { prereduced: true });
    })
  }
});
class IntersectionNode extends _root.BaseRoot {
  basis = this.inner.domain ?? this.inner.proto ?? null;
  refinements = this.children.filter((node) => node.isRefinement());
  structure = this.inner.structure;
  expression = writeIntersectionExpression(this);
  get shallowMorphs() {
    return this.inner.structure?.structuralMorph ?
    [this.inner.structure.structuralMorph] :
    [];
  }
  get defaultShortDescription() {
    return this.basis?.defaultShortDescription ?? "present";
  }
  innerToJsonSchema(ctx) {
    return this.children.reduce(
      // cast is required since TS doesn't know children have compatible schema prerequisites
      (schema, child) => child.isBasis() ?
      child.toJsonSchemaRecurse(ctx) :
      child.reduceJsonSchema(schema, ctx), {});
  }
  traverseAllows = (data, ctx) => this.children.every((child) => child.traverseAllows(data, ctx));
  traverseApply = (data, ctx) => {
    const errorCount = ctx.currentErrorCount;
    if (this.basis) {
      this.basis.traverseApply(data, ctx);
      if (ctx.currentErrorCount > errorCount)
      return;
    }
    if (this.refinements.length) {
      for (let i = 0; i < this.refinements.length - 1; i++) {
        this.refinements[i].traverseApply(data, ctx);
        if (ctx.failFast && ctx.currentErrorCount > errorCount)
        return;
      }
      this.refinements.at(-1).traverseApply(data, ctx);
      if (ctx.currentErrorCount > errorCount)
      return;
    }
    if (this.structure) {
      this.structure.traverseApply(data, ctx);
      if (ctx.currentErrorCount > errorCount)
      return;
    }
    if (this.inner.predicate) {
      for (let i = 0; i < this.inner.predicate.length - 1; i++) {
        this.inner.predicate[i].traverseApply(data, ctx);
        if (ctx.failFast && ctx.currentErrorCount > errorCount)
        return;
      }
      this.inner.predicate.at(-1).traverseApply(data, ctx);
    }
  };
  compile(js) {
    if (js.traversalKind === "Allows") {
      for (const child of this.children)
      js.check(child);
      js.return(true);
      return;
    }
    js.initializeErrorCount();
    if (this.basis) {
      js.check(this.basis);
      // we only have to return conditionally if this is not the last check
      if (this.children.length > 1)
      js.returnIfFail();
    }
    if (this.refinements.length) {
      for (let i = 0; i < this.refinements.length - 1; i++) {
        js.check(this.refinements[i]);
        js.returnIfFailFast();
      }
      js.check(this.refinements.at(-1));
      if (this.structure || this.inner.predicate)
      js.returnIfFail();
    }
    if (this.structure) {
      js.check(this.structure);
      if (this.inner.predicate)
      js.returnIfFail();
    }
    if (this.inner.predicate) {
      for (let i = 0; i < this.inner.predicate.length - 1; i++) {
        js.check(this.inner.predicate[i]);
        // since predicates can be chained, we have to fail immediately
        // if one fails
        js.returnIfFail();
      }
      js.check(this.inner.predicate.at(-1));
    }
  }
}exports.IntersectionNode = IntersectionNode;
const Intersection = exports.Intersection = {
  implementation,
  Node: IntersectionNode
};
const writeIntersectionExpression = (node) => {
  let expression = node.structure?.expression ||
  `${node.basis && !node.refinements.some((n) => n.impl.obviatesBasisExpression) ? node.basis.nestableExpression + " " : ""}${node.refinements.map((n) => n.expression).join(" & ")}` ||
  "unknown";
  if (expression === "Array == 0")
  expression = "[]";
  return expression;
};
const intersectIntersections = (l, r, ctx) => {
  const baseInner = {};
  const lBasis = l.proto ?? l.domain;
  const rBasis = r.proto ?? r.domain;
  const basisResult = lBasis ?
  rBasis ?
  (0, _intersections.intersectOrPipeNodes)(lBasis, rBasis, ctx) :
  lBasis :
  rBasis;
  if (basisResult instanceof _disjoint.Disjoint)
  return basisResult;
  if (basisResult)
  baseInner[basisResult.kind] = basisResult;
  return (0, _constraint.intersectConstraints)({
    kind: "intersection",
    baseInner,
    l: (0, _constraint.flattenConstraints)(l),
    r: (0, _constraint.flattenConstraints)(r),
    roots: [],
    ctx
  });
}; /* v9-e649b3d9ff5acfff */
