"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeInvalidPropertyKeyMessage = exports.writeEnumerableIndexBranches = exports.IndexNode = exports.Index = void 0;var _util = require("@ark/util");
var _constraint = require("../constraint.js");
var _node = require("../node.js");
var _disjoint = require("../shared/disjoint.js");
var _implement = require("../shared/implement.js");
var _intersections = require("../shared/intersections.js");
var _registry = require("../shared/registry.js");
var _traversal = require("../shared/traversal.js");
const implementation = (0, _implement.implementNode)({
  kind: "index",
  hasAssociatedError: false,
  intersectionIsOpen: true,
  keys: {
    signature: {
      child: true,
      parse: (schema, ctx) => {
        const key = ctx.$.parseSchema(schema);
        if (!key.extends(_registry.$ark.intrinsic.key)) {
          return (0, _util.throwParseError)(writeInvalidPropertyKeyMessage(key.expression));
        }
        const enumerableBranches = key.branches.filter((b) => b.hasKind("unit"));
        if (enumerableBranches.length) {
          return (0, _util.throwParseError)(writeEnumerableIndexBranches(enumerableBranches.map((b) => (0, _util.printable)(b.unit))));
        }
        return key;
      }
    },
    value: {
      child: true,
      parse: (schema, ctx) => ctx.$.parseSchema(schema)
    }
  },
  normalize: (schema) => schema,
  defaults: {
    description: (node) => `[${node.signature.expression}]: ${node.value.description}`
  },
  intersections: {
    index: (l, r, ctx) => {
      if (l.signature.equals(r.signature)) {
        const valueIntersection = (0, _intersections.intersectOrPipeNodes)(l.value, r.value, ctx);
        const value = valueIntersection instanceof _disjoint.Disjoint ?
        _registry.$ark.intrinsic.never.internal :
        valueIntersection;
        return ctx.$.node("index", { signature: l.signature, value });
      }
      // if r constrains all of l's keys to a subtype of l's value, r is a subtype of l
      if (l.signature.extends(r.signature) && l.value.subsumes(r.value))
      return r;
      // if l constrains all of r's keys to a subtype of r's value, l is a subtype of r
      if (r.signature.extends(l.signature) && r.value.subsumes(l.value))
      return l;
      // other relationships between index signatures can't be generally reduced
      return null;
    }
  }
});
class IndexNode extends _constraint.BaseConstraint {
  impliedBasis = _registry.$ark.intrinsic.object.internal;
  expression = `[${this.signature.expression}]: ${this.value.expression}`;
  flatRefs = (0, _util.append)(this.value.flatRefs.map((ref) => (0, _node.flatRef)([this.signature, ...ref.path], ref.node)), (0, _node.flatRef)([this.signature], this.value));
  traverseAllows = (data, ctx) => (0, _util.stringAndSymbolicEntriesOf)(data).every((entry) => {
    if (this.signature.traverseAllows(entry[0], ctx)) {
      return (0, _traversal.traverseKey)(entry[0], () => this.value.traverseAllows(entry[1], ctx), ctx);
    }
    return true;
  });
  traverseApply = (data, ctx) => {
    for (const entry of (0, _util.stringAndSymbolicEntriesOf)(data)) {
      if (this.signature.traverseAllows(entry[0], ctx)) {
        (0, _traversal.traverseKey)(entry[0], () => this.value.traverseApply(entry[1], ctx), ctx);
      }
    }
  };
  _transform(mapper, ctx) {
    ctx.path.push(this.signature);
    const result = super._transform(mapper, ctx);
    ctx.path.pop();
    return result;
  }
  compile() {

    // this is currently handled by StructureNode
  }}exports.IndexNode = IndexNode;
const Index = exports.Index = {
  implementation,
  Node: IndexNode
};
const writeEnumerableIndexBranches = (keys) => `Index keys ${keys.join(", ")} should be specified as named props.`;exports.writeEnumerableIndexBranches = writeEnumerableIndexBranches;
const writeInvalidPropertyKeyMessage = (indexSchema) => `Indexed key definition '${indexSchema}' must be a string or symbol`;exports.writeInvalidPropertyKeyMessage = writeInvalidPropertyKeyMessage; /* v9-0c3680fa63da75e3 */
