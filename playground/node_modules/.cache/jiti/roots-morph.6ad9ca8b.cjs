"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeMorphIntersectionMessage = exports.MorphNode = exports.Morph = void 0;var _util = require("@ark/util");
var _disjoint = require("../shared/disjoint.js");
var _implement = require("../shared/implement.js");
var _intersections = require("../shared/intersections.js");
var _registry = require("../shared/registry.js");
var _utils = require("../shared/utils.js");
var _root = require("./root.js");
var _utils2 = require("./utils.js");
const implementation = (0, _implement.implementNode)({
  kind: "morph",
  hasAssociatedError: false,
  keys: {
    in: {
      child: true,
      parse: (schema, ctx) => ctx.$.parseSchema(schema)
    },
    morphs: {
      parse: _util.liftArray,
      serialize: (morphs) => morphs.map((m) => (0, _utils.hasArkKind)(m, "root") ? m.json : (0, _registry.registeredReference)(m))
    },
    declaredIn: {
      child: false,
      serialize: (node) => node.json
    },
    declaredOut: {
      child: false,
      serialize: (node) => node.json
    }
  },
  normalize: (schema) => schema,
  defaults: {
    description: (node) => `a morph from ${node.in.description} to ${node.out?.description ?? "unknown"}`
  },
  intersections: {
    morph: (l, r, ctx) => {
      if (!l.hasEqualMorphs(r)) {
        return (0, _util.throwParseError)(writeMorphIntersectionMessage(l.expression, r.expression));
      }
      const inTersection = (0, _intersections.intersectOrPipeNodes)(l.in, r.in, ctx);
      if (inTersection instanceof _disjoint.Disjoint)
      return inTersection;
      const baseInner = {
        morphs: l.morphs
      };
      if (l.declaredIn || r.declaredIn) {
        const declaredIn = (0, _intersections.intersectOrPipeNodes)(l.in, r.in, ctx);
        // we can't treat this as a normal Disjoint since it's just declared
        // it should only happen if someone's essentially trying to create a broken type
        if (declaredIn instanceof _disjoint.Disjoint)
        return declaredIn.throw();else

        baseInner.declaredIn = declaredIn;
      }
      if (l.declaredOut || r.declaredOut) {
        const declaredOut = (0, _intersections.intersectOrPipeNodes)(l.out, r.out, ctx);
        if (declaredOut instanceof _disjoint.Disjoint)
        return declaredOut.throw();else

        baseInner.declaredOut = declaredOut;
      }
      // in case from is a union, we need to distribute the branches
      // to can be a union as any schema is allowed
      return inTersection.distribute((inBranch) => ctx.$.node("morph", {
        ...baseInner,
        in: inBranch
      }), ctx.$.parseSchema);
    },
    ...(0, _utils2.defineRightwardIntersections)("morph", (l, r, ctx) => {
      const inTersection = l.inner.in ? (0, _intersections.intersectOrPipeNodes)(l.inner.in, r, ctx) : r;
      return inTersection instanceof _disjoint.Disjoint ? inTersection :
      inTersection.equals(l.inner.in) ? l :
      ctx.$.node("morph", {
        ...l.inner,
        in: inTersection
      });
    })
  }
});
class MorphNode extends _root.BaseRoot {
  serializedMorphs = this.morphs.map(_registry.registeredReference);
  compiledMorphs = `[${this.serializedMorphs}]`;
  lastMorph = this.inner.morphs.at(-1);
  lastMorphIfNode = (0, _utils.hasArkKind)(this.lastMorph, "root") ? this.lastMorph : undefined;
  introspectableIn = this.inner.in;
  introspectableOut = this.lastMorphIfNode ?
  Object.assign(this.referencesById, this.lastMorphIfNode.referencesById) &&
  this.lastMorphIfNode.out :
  undefined;
  get shallowMorphs() {
    // if the morph input is a union, it should not contain any other shallow morphs
    return Array.isArray(this.inner.in?.shallowMorphs) ?
    [...this.inner.in.shallowMorphs, ...this.morphs] :
    this.morphs;
  }
  get in() {
    return this.declaredIn ?? this.inner.in?.in ?? _registry.$ark.intrinsic.unknown.internal;
  }
  get out() {
    return this.declaredOut ??
    this.introspectableOut ??
    _registry.$ark.intrinsic.unknown.internal;
  }
  declareIn(declaredIn) {
    return this.$.node("morph", {
      ...this.inner,
      declaredIn
    });
  }
  declareOut(declaredOut) {
    return this.$.node("morph", {
      ...this.inner,
      declaredOut
    });
  }
  expression = `(In: ${this.in.expression}) => ${this.lastMorphIfNode ? "To" : "Out"}<${this.out.expression}>`;
  get defaultShortDescription() {
    return this.in.meta.description ?? this.in.defaultShortDescription;
  }
  innerToJsonSchema(ctx) {
    return ctx.fallback.morph({
      code: "morph",
      base: this.in.toJsonSchemaRecurse(ctx),
      out: this.introspectableOut?.toJsonSchemaRecurse(ctx) ?? null
    });
  }
  compile(js) {
    if (js.traversalKind === "Allows") {
      if (!this.introspectableIn)
      return;
      js.return(js.invoke(this.introspectableIn));
      return;
    }
    if (this.introspectableIn)
    js.line(js.invoke(this.introspectableIn));
    js.line(`ctx.queueMorphs(${this.compiledMorphs})`);
  }
  traverseAllows = (data, ctx) => !this.introspectableIn || this.introspectableIn.traverseAllows(data, ctx);
  traverseApply = (data, ctx) => {
    if (this.introspectableIn)
    this.introspectableIn.traverseApply(data, ctx);
    ctx.queueMorphs(this.morphs);
  };
  /** Check if the morphs of r are equal to those of this node */
  hasEqualMorphs(r) {
    return (0, _util.arrayEquals)(this.morphs, r.morphs, {
      isEqual: (lMorph, rMorph) => lMorph === rMorph ||
      (0, _utils.hasArkKind)(lMorph, "root") &&
      (0, _utils.hasArkKind)(rMorph, "root") &&
      lMorph.equals(rMorph)
    });
  }
}exports.MorphNode = MorphNode;
const Morph = exports.Morph = {
  implementation,
  Node: MorphNode
};
const writeMorphIntersectionMessage = (lDescription, rDescription) => `The intersection of distinct morphs at a single path is indeterminate:
Left: ${lDescription}
Right: ${rDescription}`;exports.writeMorphIntersectionMessage = writeMorphIntersectionMessage; /* v9-2d65aed875eacace */
