"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeNonPrimitiveNonFunctionDefaultValueMessage = exports.computeDefaultValueMorph = exports.assertDefaultValueAssignability = exports.OptionalNode = exports.Optional = void 0;var _util = require("@ark/util");
var _intrinsic = require("../intrinsic.js");
var _compile = require("../shared/compile.js");
var _errors = require("../shared/errors.js");
var _implement = require("../shared/implement.js");
var _registry = require("../shared/registry.js");
var _traversal = require("../shared/traversal.js");
var _prop = require("./prop.js");
const implementation = (0, _implement.implementNode)({
  kind: "optional",
  hasAssociatedError: false,
  intersectionIsOpen: true,
  keys: {
    key: {},
    value: {
      child: true,
      parse: (schema, ctx) => ctx.$.parseSchema(schema)
    },
    default: {
      preserveUndefined: true
    }
  },
  normalize: (schema) => schema,
  reduce: (inner, $) => {
    if ($.resolvedConfig.exactOptionalPropertyTypes === false) {
      if (!inner.value.allows(undefined)) {
        return $.node("optional", { ...inner, value: inner.value.or(_intrinsic.intrinsic.undefined) }, { prereduced: true });
      }
    }
  },
  defaults: {
    description: (node) => `${node.compiledKey}?: ${node.value.description}`
  },
  intersections: {
    optional: _prop.intersectProps
  }
});
class OptionalNode extends _prop.BaseProp {
  constructor(...args) {
    super(...args);
    if ("default" in this.inner)
    assertDefaultValueAssignability(this.value, this.inner.default, this.key);
  }
  get outProp() {
    if (!this.hasDefault())
    return this;
    const { default: defaultValue, ...requiredInner } = this.inner;
    return this.cacheGetter("outProp", this.$.node("required", requiredInner, { prereduced: true }));
  }
  expression = this.hasDefault() ?
  `${this.compiledKey}: ${this.value.expression} = ${(0, _util.printable)(this.inner.default)}` :
  `${this.compiledKey}?: ${this.value.expression}`;
  defaultValueMorph = getDefaultableMorph(this);
  defaultValueMorphRef = this.defaultValueMorph && (0, _registry.registeredReference)(this.defaultValueMorph);
}exports.OptionalNode = OptionalNode;
const Optional = exports.Optional = {
  implementation,
  Node: OptionalNode
};
const defaultableMorphCache = {};
const getDefaultableMorph = (node) => {
  if (!node.hasDefault())
  return;
  const cacheKey = `{${node.compiledKey}: ${node.value.id} = ${(0, _implement.defaultValueSerializer)(node.default)}}`;
  return defaultableMorphCache[cacheKey] ??= computeDefaultValueMorph(node.key, node.value, node.default);
};
const computeDefaultValueMorph = (key, value, defaultInput) => {
  if (typeof defaultInput === "function") {
    // if the value has a morph, pipe context through it
    return value.includesTransform ?
    (data, ctx) => {
      (0, _traversal.traverseKey)(key, () => value(data[key] = defaultInput(), ctx), ctx);
      return data;
    } :
    (data) => {
      data[key] = defaultInput();
      return data;
    };
  }
  // non-functional defaults can be safely cached as long as the morph is
  // guaranteed to be pure and the output is primitive
  const precomputedMorphedDefault = value.includesTransform ? value.assert(defaultInput) : defaultInput;
  return (0, _util.hasDomain)(precomputedMorphedDefault, "object") ?
  // the type signature only allows this if the value was morphed
  (data, ctx) => {
    (0, _traversal.traverseKey)(key, () => value(data[key] = defaultInput, ctx), ctx);
    return data;
  } :
  (data) => {
    data[key] = precomputedMorphedDefault;
    return data;
  };
};exports.computeDefaultValueMorph = computeDefaultValueMorph;
const assertDefaultValueAssignability = (node, value, key) => {
  const wrapped = (0, _util.isThunk)(value);
  if ((0, _util.hasDomain)(value, "object") && !wrapped)
  (0, _util.throwParseError)(writeNonPrimitiveNonFunctionDefaultValueMessage(key));
  const out = node.in(wrapped ? value() : value);
  if (out instanceof _errors.ArkErrors) {
    if (key === null) {
      // e.g. "Default must be assignable to number (was string)"
      (0, _util.throwParseError)(`Default ${out.summary}`);
    }
    const atPath = out.transform((e) => e.transform((input) => ({ ...input, prefixPath: [key] })));
    // e.g. "Default for bar must be assignable to number (was string)"
    // e.g. "Default for value at [0] must be assignable to number (was string)"
    (0, _util.throwParseError)(`Default for ${atPath.summary}`);
  }
  return value;
};exports.assertDefaultValueAssignability = assertDefaultValueAssignability;
const writeNonPrimitiveNonFunctionDefaultValueMessage = (key) => {
  const keyDescription = key === null ? "" :
  typeof key === "number" ? `for value at [${key}] ` :
  `for ${(0, _compile.compileSerializedValue)(key)} `;
  return `Non-primitive default ${keyDescription}must be specified as a function like () => ({my: 'object'})`;
};exports.writeNonPrimitiveNonFunctionDefaultValueMessage = writeNonPrimitiveNonFunctionDefaultValueMessage; /* v9-06c2bfc95b702bee */
