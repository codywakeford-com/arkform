"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.mergeToJsonSchemaConfigs = exports.mergeConfigs = exports.configureSchema = void 0;var _implement = require("./shared/implement.js");
var _registry = require("./shared/registry.js");
var _toJsonSchema = require("./shared/toJsonSchema.js");
// $ark.config could already be set if it were imported previously from the
// dedicated config entrypoint, in which case we don't want to reinitialize it
_registry.$ark.config ??= {};
const configureSchema = (config) => {
  const result = Object.assign(_registry.$ark.config, mergeConfigs(_registry.$ark.config, config));
  _registry.$ark.resolvedConfig &&= mergeConfigs(_registry.$ark.resolvedConfig, result);
  return result;
};exports.configureSchema = configureSchema;
const mergeConfigs = (base, merged) => {
  if (!merged)
  return base;
  const result = { ...base };
  let k;
  for (k in merged) {
    const keywords = { ...base.keywords };
    if (k === "keywords") {
      for (const flatAlias in merged[k]) {
        const v = merged.keywords[flatAlias];
        if (v === undefined)
        continue;
        keywords[flatAlias] = typeof v === "string" ? { description: v } : v;
      }
      result.keywords = keywords;
    } else
    if (k === "toJsonSchema") {
      result[k] = mergeToJsonSchemaConfigs(base.toJsonSchema, merged.toJsonSchema);
    } else
    if ((0, _implement.isNodeKind)(k)) {
      result[k] =
      // not casting this makes TS compute a very inefficient
      // type that is not needed
      {
        ...base[k],
        ...merged[k]
      };
    } else

    result[k] = merged[k];
  }
  return result;
};exports.mergeConfigs = mergeConfigs;
const mergeToJsonSchemaConfigs = (baseConfig, mergedConfig) => {
  if (!baseConfig)
  return mergedConfig ?? {};
  if (!mergedConfig)
  return baseConfig;
  const result = { ...baseConfig };
  let k;
  for (k in mergedConfig) {
    if (k === "fallback") {
      result.fallback = mergeFallbacks(baseConfig.fallback, mergedConfig.fallback);
    } else

    result[k] = mergedConfig[k];
  }
  return result;
};exports.mergeToJsonSchemaConfigs = mergeToJsonSchemaConfigs;
const mergeFallbacks = (base, merged) => {
  base = normalizeFallback(base);
  merged = normalizeFallback(merged);
  const result = {};
  let code;
  for (code in _toJsonSchema.ToJsonSchema.defaultConfig.fallback) {
    result[code] =
    merged[code] ??
    merged.default ??
    base[code] ??
    base.default ??
    _toJsonSchema.ToJsonSchema.defaultConfig.fallback[code];
  }
  return result;
};
const normalizeFallback = (fallback) => typeof fallback === "function" ? { default: fallback } : fallback ?? {}; /* v9-af2900aedceccafd */
