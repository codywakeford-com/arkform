"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.tryCatch = exports.isThunk = exports.envHasCsp = exports.cached = exports.DynamicFunction = exports.Callable = void 0;var _errors = require("./errors.js");
var _records = require("./records.js");
const cached = (thunk) => {
  let result = _records.unset;
  return () => result === _records.unset ? result = thunk() : result;
};exports.cached = cached;
const isThunk = (value) => typeof value === "function" && value.length === 0;exports.isThunk = isThunk;
const tryCatch = (fn, onError) => {
  try {
    return fn();
  }
  catch (e) {
    return onError?.(e);
  }
};exports.tryCatch = tryCatch;
const DynamicFunction = class extends Function {
  constructor(...args) {
    const params = args.slice(0, -1);
    const body = args.at(-1);
    try {
      super(...params, body);
    }
    catch (e) {
      return (0, _errors.throwInternalError)(`Encountered an unexpected error while compiling your definition:
                Message: ${e} 
                Source: (${args.slice(0, -1)}) => {
                    ${args.at(-1)}
                }`);
    }
  }
};exports.DynamicFunction = DynamicFunction;
class Callable {
  constructor(fn, ...[opts]) {
    return Object.assign(Object.setPrototypeOf(fn.bind(opts?.bind ?? this), this.constructor.prototype), opts?.attach);
  }
}
/**
 * Checks if the environment has Content Security Policy (CSP) enabled,
 * preventing JIT-optimized code from being compiled via new Function().
 *
 * @returns `true` if a function created using new Function() can be
 * successfully invoked in the environment, `false` otherwise.
 *
 * The result is cached for subsequent invocations.
 */exports.Callable = Callable;
const envHasCsp = exports.envHasCsp = cached(() => {
  try {
    return new Function("return false")();
  }
  catch {
    return true;
  }
}); /* v9-61693d3f125d07f6 */
