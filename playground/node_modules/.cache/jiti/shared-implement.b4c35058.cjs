"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.assertNodeKind = assertNodeKind;exports.unionChildKinds = exports.structureKeys = exports.structuralKinds = exports.schemaKindsRightOf = exports.rootKinds = exports.refinementKinds = exports.precedenceOfKind = exports.precedenceByKind = exports.nodeKinds = exports.morphChildKinds = exports.isNodeKind = exports.implementNode = exports.defaultValueSerializer = exports.constraintKinds = exports.constraintKeys = exports.compileObjectLiteral = exports.basisKinds = void 0;var _util = require("@ark/util");
var _compile = require("./compile.js");
var _utils = require("./utils.js");
const basisKinds = exports.basisKinds = ["unit", "proto", "domain"];
const structuralKinds = exports.structuralKinds = [
"required",
"optional",
"index",
"sequence"];

const refinementKinds = exports.refinementKinds = [
"pattern",
"divisor",
"exactLength",
"max",
"min",
"maxLength",
"minLength",
"before",
"after"];

const constraintKinds = exports.constraintKinds = [
...refinementKinds,
...structuralKinds,
"structure",
"predicate"];

const rootKinds = exports.rootKinds = [
"alias",
"union",
"morph",
"unit",
"intersection",
"proto",
"domain"];

const nodeKinds = exports.nodeKinds = [...rootKinds, ...constraintKinds];
const constraintKeys = exports.constraintKeys = (0, _util.flatMorph)(constraintKinds, (i, kind) => [kind, 1]);
const structureKeys = exports.structureKeys = (0, _util.flatMorph)([...structuralKinds, "undeclared"], (i, k) => [k, 1]);
const precedenceByKind = exports.precedenceByKind = (0, _util.flatMorph)(nodeKinds, (i, kind) => [kind, i]);
const isNodeKind = (value) => typeof value === "string" && value in precedenceByKind;exports.isNodeKind = isNodeKind;
function assertNodeKind(value, kind) {
  const valueIsNode = (0, _utils.isNode)(value);
  if (!valueIsNode || value.kind !== kind) {
    (0, _util.throwParseError)(`Expected node of kind ${kind} (was ${valueIsNode ? `${value.kind} node` : (0, _util.printable)(value)})`);
  }
}
const precedenceOfKind = (kind) => precedenceByKind[kind];exports.precedenceOfKind = precedenceOfKind;
const schemaKindsRightOf = (kind) => rootKinds.slice(precedenceOfKind(kind) + 1);exports.schemaKindsRightOf = schemaKindsRightOf;
const unionChildKinds = exports.unionChildKinds = [
...schemaKindsRightOf("union"),
"alias"];

const morphChildKinds = exports.morphChildKinds = [
...schemaKindsRightOf("morph"),
"alias"];

const defaultValueSerializer = (v) => {
  if (typeof v === "string" || typeof v === "boolean" || v === null)
  return v;
  if (typeof v === "number") {
    if (Number.isNaN(v))
    return "NaN";
    if (v === Number.POSITIVE_INFINITY)
    return "Infinity";
    if (v === Number.NEGATIVE_INFINITY)
    return "-Infinity";
    return v;
  }
  return (0, _compile.compileSerializedValue)(v);
};exports.defaultValueSerializer = defaultValueSerializer;
const compileObjectLiteral = (ctx) => {
  let result = "{ ";
  for (const [k, v] of Object.entries(ctx))
  result += `${k}: ${(0, _compile.compileSerializedValue)(v)}, `;
  return result + " }";
};exports.compileObjectLiteral = compileObjectLiteral;
const implementNode = (_) => {
  const implementation = _;
  if (implementation.hasAssociatedError) {
    implementation.defaults.expected ??= (ctx) => "description" in ctx ?
    ctx.description :
    implementation.defaults.description(ctx);
    implementation.defaults.actual ??= (data) => (0, _util.printable)(data);
    implementation.defaults.problem ??= (ctx) => `must be ${ctx.expected}${ctx.actual ? ` (was ${ctx.actual})` : ""}`;
    implementation.defaults.message ??= (ctx) => {
      if (ctx.path.length === 0)
      return ctx.problem;
      const problemWithLocation = `${ctx.propString} ${ctx.problem}`;
      if (problemWithLocation[0] === "[") {
        // clarify paths like [1], [0][1], and ["key!"] that could be confusing
        return `value at ${problemWithLocation}`;
      }
      return problemWithLocation;
    };
  }
  return implementation;
};exports.implementNode = implementNode; /* v9-47a38127d1bec22c */
