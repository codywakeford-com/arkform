"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.DynamicState = void 0;var _util = require("@ark/util");
var _operand = require("../shift/operand/operand.js");
var _operator = require("../shift/operator/operator.js");
var _string = require("../string.js");
var _shared = require("./shared.js");
class DynamicState {
  // set root type to `any` so that all constraints can be applied
  root;
  branches = {
    prefixes: [],
    leftBound: null,
    intersection: null,
    union: null,
    pipe: null
  };
  finalizer;
  groups = [];
  scanner;
  ctx;
  constructor(scanner, ctx) {
    this.scanner = scanner;
    this.ctx = ctx;
  }
  error(message) {
    return (0, _util.throwParseError)(message);
  }
  hasRoot() {
    return this.root !== undefined;
  }
  setRoot(root) {
    this.root = root;
  }
  unsetRoot() {
    const value = this.root;
    this.root = undefined;
    return value;
  }
  constrainRoot(...args) {
    this.root = this.root.constrain(args[0], args[1]);
  }
  finalize(finalizer) {
    if (this.groups.length)
    return this.error((0, _shared.writeUnclosedGroupMessage)(")"));
    this.finalizeBranches();
    this.finalizer = finalizer;
  }
  reduceLeftBound(limit, comparator) {
    const invertedComparator = _shared.invertedComparators[comparator];
    if (!(0, _util.isKeyOf)(invertedComparator, _shared.minComparators))
    return this.error((0, _shared.writeUnpairableComparatorMessage)(comparator));
    if (this.branches.leftBound) {
      return this.error((0, _shared.writeMultipleLeftBoundsMessage)(this.branches.leftBound.limit, this.branches.leftBound.comparator, limit, invertedComparator));
    }
    this.branches.leftBound = {
      comparator: invertedComparator,
      limit
    };
  }
  finalizeBranches() {
    this.assertRangeUnset();
    if (this.branches.pipe) {
      this.pushRootToBranch("|>");
      this.root = this.branches.pipe;
      return;
    }
    if (this.branches.union) {
      this.pushRootToBranch("|");
      this.root = this.branches.union;
      return;
    }
    if (this.branches.intersection) {
      this.pushRootToBranch("&");
      this.root = this.branches.intersection;
      return;
    }
    this.applyPrefixes();
  }
  finalizeGroup() {
    this.finalizeBranches();
    const topBranchState = this.groups.pop();
    if (!topBranchState)
    return this.error((0, _shared.writeUnmatchedGroupCloseMessage)(this.scanner.unscanned));
    this.branches = topBranchState;
  }
  addPrefix(prefix) {
    this.branches.prefixes.push(prefix);
  }
  applyPrefixes() {
    while (this.branches.prefixes.length) {
      const lastPrefix = this.branches.prefixes.pop();
      this.root =
      lastPrefix === "keyof" ?
      this.root.keyof() :
      (0, _util.throwInternalError)(`Unexpected prefix '${lastPrefix}'`);
    }
  }
  pushRootToBranch(token) {
    this.assertRangeUnset();
    this.applyPrefixes();
    const root = this.root;
    this.root = undefined;
    this.branches.intersection =
    this.branches.intersection?.rawAnd(root) ?? root;
    if (token === "&")
    return;
    this.branches.union =
    this.branches.union?.rawOr(this.branches.intersection) ??
    this.branches.intersection;
    this.branches.intersection = null;
    if (token === "|")
    return;
    this.branches.pipe =
    this.branches.pipe?.rawPipeOnce(this.branches.union) ??
    this.branches.union;
    this.branches.union = null;
  }
  parseUntilFinalizer() {
    return (0, _string.parseUntilFinalizer)(new DynamicState(this.scanner, this.ctx));
  }
  parseOperator() {
    return (0, _operator.parseOperator)(this);
  }
  parseOperand() {
    return (0, _operand.parseOperand)(this);
  }
  assertRangeUnset() {
    if (this.branches.leftBound) {
      return this.error((0, _shared.writeOpenRangeMessage)(this.branches.leftBound.limit, this.branches.leftBound.comparator));
    }
  }
  reduceGroupOpen() {
    this.groups.push(this.branches);
    this.branches = {
      prefixes: [],
      leftBound: null,
      union: null,
      intersection: null,
      pipe: null
    };
  }
  previousOperator() {
    return this.branches.leftBound?.comparator ??
    this.branches.prefixes.at(-1) ?? (
    this.branches.intersection ? "&" :
    this.branches.union ? "|" :
    this.branches.pipe ? "|>" :
    undefined);
  }
  shiftedByOne() {
    this.scanner.shift();
    return this;
  }
}exports.DynamicState = DynamicState; /* v9-1f7f7a6b7a0e12b9 */
