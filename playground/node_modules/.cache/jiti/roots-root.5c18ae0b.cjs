"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeNonStructuralOperandMessage = exports.writeLiteralUnionEntriesMessage = exports.typeOrTermExtends = exports.exclusivizeRangeSchema = exports.emptyBrandNameMessage = exports.BaseRoot = void 0;var _util = require("@ark/util");
var _config = require("../config.js");
var _constraint = require("../constraint.js");
var _node = require("../node.js");
var _disjoint = require("../shared/disjoint.js");
var _errors = require("../shared/errors.js");
var _implement = require("../shared/implement.js");
var _intersections = require("../shared/intersections.js");
var _registry = require("../shared/registry.js");
var _utils = require("../shared/utils.js");
var _optional = require("../structure/optional.js");
class BaseRoot extends _node.BaseNode {
  constructor(attachments, $) {
    super(attachments, $);
    // define as a getter to avoid it being enumerable/spreadable
    Object.defineProperty(this, _utils.arkKind, { value: "root", enumerable: false });
  }
  get internal() {
    return this;
  }
  get "~standard"() {
    return {
      vendor: "arktype",
      version: 1,
      validate: (input) => {
        const out = this(input);
        if (out instanceof _errors.ArkErrors)
        return out;
        return { value: out };
      }
    };
  }
  as() {
    return this;
  }
  brand(name) {
    if (name === "")
    return (0, _util.throwParseError)(emptyBrandNameMessage);
    return this;
  }
  readonly() {
    return this;
  }
  branches = this.hasKind("union") ? this.inner.branches : [this];
  distribute(mapBranch, reduceMapped) {
    const mappedBranches = this.branches.map(mapBranch);
    return reduceMapped?.(mappedBranches) ?? mappedBranches;
  }
  get shortDescription() {
    return this.meta.description ?? this.defaultShortDescription;
  }
  toJsonSchema(opts = {}) {
    const ctx = (0, _config.mergeToJsonSchemaConfigs)(this.$.resolvedConfig.toJsonSchema, opts);
    ctx.useRefs ||= this.isCyclic;
    // ensure $schema is the first key if present
    const schema = typeof ctx.dialect === "string" ? { $schema: ctx.dialect } : {};
    Object.assign(schema, this.toJsonSchemaRecurse(ctx));
    if (ctx.useRefs) {
      schema.$defs = (0, _util.flatMorph)(this.references, (i, ref) => ref.isRoot() && !ref.alwaysExpandJsonSchema ?
      [ref.id, ref.toResolvedJsonSchema(ctx)] :
      []);
    }
    return schema;
  }
  toJsonSchemaRecurse(ctx) {
    if (ctx.useRefs && !this.alwaysExpandJsonSchema)
    return { $ref: `#/$defs/${this.id}` };
    return this.toResolvedJsonSchema(ctx);
  }
  get alwaysExpandJsonSchema() {
    return this.isBasis() ||
    this.kind === "alias" ||
    this.hasKind("union") && this.isBoolean;
  }
  toResolvedJsonSchema(ctx) {
    const result = this.innerToJsonSchema(ctx);
    return Object.assign(result, this.metaJson);
  }
  intersect(r) {
    const rNode = this.$.parseDefinition(r);
    const result = this.rawIntersect(rNode);
    if (result instanceof _disjoint.Disjoint)
    return result;
    return this.$.finalize(result);
  }
  rawIntersect(r) {
    return (0, _intersections.intersectNodesRoot)(this, r, this.$);
  }
  toNeverIfDisjoint() {
    return this;
  }
  and(r) {
    const result = this.intersect(r);
    return result instanceof _disjoint.Disjoint ? result.throw() : result;
  }
  rawAnd(r) {
    const result = this.rawIntersect(r);
    return result instanceof _disjoint.Disjoint ? result.throw() : result;
  }
  or(r) {
    const rNode = this.$.parseDefinition(r);
    return this.$.finalize(this.rawOr(rNode));
  }
  rawOr(r) {
    const branches = [...this.branches, ...r.branches];
    return this.$.node("union", branches);
  }
  map(flatMapEntry) {
    return this.$.schema(this.applyStructuralOperation("map", [flatMapEntry]));
  }
  pick(...keys) {
    return this.$.schema(this.applyStructuralOperation("pick", keys));
  }
  omit(...keys) {
    return this.$.schema(this.applyStructuralOperation("omit", keys));
  }
  required() {
    return this.$.schema(this.applyStructuralOperation("required", []));
  }
  partial() {
    return this.$.schema(this.applyStructuralOperation("partial", []));
  }
  _keyof;
  keyof() {
    if (this._keyof)
    return this._keyof;
    const result = this.applyStructuralOperation("keyof", []).reduce((result, branch) => result.intersect(branch).toNeverIfDisjoint(), _registry.$ark.intrinsic.unknown.internal);
    if (result.branches.length === 0) {
      (0, _util.throwParseError)((0, _disjoint.writeUnsatisfiableExpressionError)(`keyof ${this.expression}`));
    }
    return this._keyof = this.$.finalize(result);
  }
  get props() {
    if (this.branches.length !== 1)
    return (0, _util.throwParseError)(writeLiteralUnionEntriesMessage(this.expression));
    return [...this.applyStructuralOperation("props", [])[0]];
  }
  merge(r) {
    const rNode = this.$.parseDefinition(r);
    return this.$.schema(rNode.distribute((branch) => this.applyStructuralOperation("merge", [
    structureOf(branch) ??
    (0, _util.throwParseError)(writeNonStructuralOperandMessage("merge", branch.expression))]
    )));
  }
  applyStructuralOperation(operation, args) {
    return this.distribute((branch) => {
      if (branch.equals(_registry.$ark.intrinsic.object) && operation !== "merge")
        // ideally this wouldn't be a special case, but for now it
        // allows us to bypass `assertHasKeys` checks on base
        // instantiations of generics like Pick and Omit. Could
        // potentially be removed once constraints can reference each other:
        // https://github.com/arktypeio/arktype/issues/1053
        return branch;
      const structure = structureOf(branch);
      if (!structure) {
        (0, _util.throwParseError)(writeNonStructuralOperandMessage(operation, branch.expression));
      }
      if (operation === "keyof")
      return structure.keyof();
      if (operation === "get")
      return structure.get(...args);
      if (operation === "props")
      return structure.props;
      const structuralMethodName = operation === "required" ? "require" :
      operation === "partial" ? "optionalize" :
      operation;
      return this.$.node("intersection", {
        ...branch.inner,
        structure: structure[structuralMethodName](...args)
      });
    });
  }
  get(...path) {
    if (path[0] === undefined)
    return this;
    return this.$.schema(this.applyStructuralOperation("get", path));
  }
  extract(r) {
    const rNode = this.$.parseDefinition(r);
    return this.$.schema(this.branches.filter((branch) => branch.extends(rNode)));
  }
  exclude(r) {
    const rNode = this.$.parseDefinition(r);
    return this.$.schema(this.branches.filter((branch) => !branch.extends(rNode)));
  }
  array() {
    return this.$.schema(this.isUnknown() ?
    { proto: Array } :
    {
      proto: Array,
      sequence: this
    }, { prereduced: true });
  }
  overlaps(r) {
    const intersection = this.intersect(r);
    return !(intersection instanceof _disjoint.Disjoint);
  }
  extends(r) {
    const intersection = this.intersect(r);
    return !(intersection instanceof _disjoint.Disjoint) && this.equals(intersection);
  }
  ifExtends(r) {
    return this.extends(r) ? this : undefined;
  }
  subsumes(r) {
    const rNode = this.$.parseDefinition(r);
    return rNode.extends(this);
  }
  configure(meta, selector = "shallow") {
    return this.configureReferences(meta, selector);
  }
  describe(description, selector = "shallow") {
    return this.configure({ description }, selector);
  }
  // these should ideally be implemented in arktype since they use its syntax
  // https://github.com/arktypeio/arktype/issues/1223
  optional() {
    return [this, "?"];
  }
  // these should ideally be implemented in arktype since they use its syntax
  // https://github.com/arktypeio/arktype/issues/1223
  default(thunkableValue) {
    (0, _optional.assertDefaultValueAssignability)(this, thunkableValue, null);
    return [this, "=", thunkableValue];
  }
  from(input) {
    // ideally we might not validate here but for now we need to do determine
    // which morphs to apply
    return this.assert(input);
  }
  _pipe(...morphs) {
    const result = morphs.reduce((acc, morph) => acc.rawPipeOnce(morph), this);
    return this.$.finalize(result);
  }
  tryPipe(...morphs) {
    const result = morphs.reduce((acc, morph) => acc.rawPipeOnce((0, _utils.hasArkKind)(morph, "root") ? morph : (In, ctx) => {
      try {
        return morph(In, ctx);
      }
      catch (e) {
        return ctx.error({
          code: "predicate",
          predicate: morph,
          actual: `aborted due to error:\n    ${e}\n`
        });
      }
    }), this);
    return this.$.finalize(result);
  }
  pipe = Object.assign(this._pipe.bind(this), {
    try: this.tryPipe.bind(this)
  });
  to(def) {
    return this.$.finalize(this.toNode(this.$.parseDefinition(def)));
  }
  toNode(root) {
    const result = (0, _intersections.pipeNodesRoot)(this, root, this.$);
    if (result instanceof _disjoint.Disjoint)
    return result.throw();
    return result;
  }
  rawPipeOnce(morph) {
    if ((0, _utils.hasArkKind)(morph, "root"))
    return this.toNode(morph);
    return this.distribute((branch) => branch.hasKind("morph") ?
    this.$.node("morph", {
      in: branch.inner.in,
      morphs: [...branch.morphs, morph]
    }) :
    this.$.node("morph", {
      in: branch,
      morphs: [morph]
    }), this.$.parseSchema);
  }
  narrow(predicate) {
    return this.constrainOut("predicate", predicate);
  }
  constrain(kind, schema) {
    return this._constrain("root", kind, schema);
  }
  constrainIn(kind, schema) {
    return this._constrain("in", kind, schema);
  }
  constrainOut(kind, schema) {
    return this._constrain("out", kind, schema);
  }
  _constrain(io, kind, schema) {
    const constraint = this.$.node(kind, schema);
    if (constraint.isRoot()) {
      // if the node reduces to `unknown`, nothing to do (e.g. minLength: 0)
      return constraint.isUnknown() ? this : (0, _util.throwInternalError)(`Unexpected constraint node ${constraint}`);
    }
    const operand = io === "root" ? this : this[io];
    if (operand.hasKind("morph") ||
    constraint.impliedBasis && !operand.extends(constraint.impliedBasis)) {
      return (0, _constraint.throwInvalidOperandError)(kind, constraint.impliedBasis, this);
    }
    const partialIntersection = this.$.node("intersection", {
      // important this is constraint.kind instead of kind in case
      // the node was reduced during parsing
      [constraint.kind]: constraint
    });
    const result = io === "out" ?
    (0, _intersections.pipeNodesRoot)(this, partialIntersection, this.$) :
    (0, _intersections.intersectNodesRoot)(this, partialIntersection, this.$);
    if (result instanceof _disjoint.Disjoint)
    result.throw();
    return this.$.finalize(result);
  }
  onUndeclaredKey(cfg) {
    const rule = typeof cfg === "string" ? cfg : cfg.rule;
    const deep = typeof cfg === "string" ? false : cfg.deep;
    return this.$.finalize(this.transform((kind, inner) => kind === "structure" ?
    rule === "ignore" ?
    (0, _util.omit)(inner, { undeclared: 1 }) :
    { ...inner, undeclared: rule } :
    inner, deep ? undefined : { shouldTransform: (node) => !(0, _util.includes)(_implement.structuralKinds, node.kind) }));
  }
  hasEqualMorphs(r) {
    if (!this.includesTransform && !r.includesTransform)
    return true;
    if (!(0, _util.arrayEquals)(this.shallowMorphs, r.shallowMorphs))
    return false;
    if (!(0, _util.arrayEquals)(this.flatMorphs, r.flatMorphs, {
      isEqual: (l, r) => l.propString === r.propString && (
      l.node.hasKind("morph") && r.node.hasKind("morph") ?
      l.node.hasEqualMorphs(r.node) :
      l.node.hasKind("intersection") && r.node.hasKind("intersection") ?
      l.node.structure?.structuralMorphRef ===
      r.node.structure?.structuralMorphRef :
      false)
    }))
    return false;
    return true;
  }
  onDeepUndeclaredKey(behavior) {
    return this.onUndeclaredKey({ rule: behavior, deep: true });
  }
  filter(predicate) {
    return this.constrainIn("predicate", predicate);
  }
  divisibleBy(schema) {
    return this.constrain("divisor", schema);
  }
  matching(schema) {
    return this.constrain("pattern", schema);
  }
  atLeast(schema) {
    return this.constrain("min", schema);
  }
  atMost(schema) {
    return this.constrain("max", schema);
  }
  moreThan(schema) {
    return this.constrain("min", exclusivizeRangeSchema(schema));
  }
  lessThan(schema) {
    return this.constrain("max", exclusivizeRangeSchema(schema));
  }
  atLeastLength(schema) {
    return this.constrain("minLength", schema);
  }
  atMostLength(schema) {
    return this.constrain("maxLength", schema);
  }
  moreThanLength(schema) {
    return this.constrain("minLength", exclusivizeRangeSchema(schema));
  }
  lessThanLength(schema) {
    return this.constrain("maxLength", exclusivizeRangeSchema(schema));
  }
  exactlyLength(schema) {
    return this.constrain("exactLength", schema);
  }
  atOrAfter(schema) {
    return this.constrain("after", schema);
  }
  atOrBefore(schema) {
    return this.constrain("before", schema);
  }
  laterThan(schema) {
    return this.constrain("after", exclusivizeRangeSchema(schema));
  }
  earlierThan(schema) {
    return this.constrain("before", exclusivizeRangeSchema(schema));
  }
}exports.BaseRoot = BaseRoot;
const emptyBrandNameMessage = exports.emptyBrandNameMessage = `Expected a non-empty brand name after #`;
const exclusivizeRangeSchema = (schema) => typeof schema === "object" && !(schema instanceof Date) ?
{ ...schema, exclusive: true } :
{
  rule: schema,
  exclusive: true
};exports.exclusivizeRangeSchema = exclusivizeRangeSchema;
const typeOrTermExtends = (t, base) => (0, _utils.hasArkKind)(base, "root") ?
(0, _utils.hasArkKind)(t, "root") ? t.extends(base) :
base.allows(t) :
(0, _utils.hasArkKind)(t, "root") ? t.hasUnit(base) :
base === t;exports.typeOrTermExtends = typeOrTermExtends;
const structureOf = (branch) => {
  if (branch.hasKind("morph"))
  return null;
  if (branch.hasKind("intersection")) {
    return branch.inner.structure ?? (
    branch.basis?.domain === "object" ?
    branch.$.bindReference(_registry.$ark.intrinsic.emptyStructure) :
    null);
  }
  if (branch.isBasis() && branch.domain === "object")
  return branch.$.bindReference(_registry.$ark.intrinsic.emptyStructure);
  return null;
};
const writeLiteralUnionEntriesMessage = (expression) => `Props cannot be extracted from a union. Use .distribute to extract props from each branch instead. Received:
${expression}`;exports.writeLiteralUnionEntriesMessage = writeLiteralUnionEntriesMessage;
const writeNonStructuralOperandMessage = (operation, operand) => `${operation} operand must be an object (was ${operand})`;exports.writeNonStructuralOperandMessage = writeNonStructuralOperandMessage; /* v9-9c741955d234bc3a */
