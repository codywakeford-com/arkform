"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.PatternNode = exports.Pattern = void 0;var _constraint = require("../constraint.js");
var _implement = require("../shared/implement.js");
var _registry = require("../shared/registry.js");
const implementation = (0, _implement.implementNode)({
  kind: "pattern",
  collapsibleKey: "rule",
  keys: {
    rule: {},
    flags: {}
  },
  normalize: (schema) => typeof schema === "string" ? { rule: schema } :
  schema instanceof RegExp ?
  schema.flags ?
  { rule: schema.source, flags: schema.flags } :
  { rule: schema.source } :
  schema,
  obviatesBasisDescription: true,
  obviatesBasisExpression: true,
  hasAssociatedError: true,
  intersectionIsOpen: true,
  defaults: {
    description: (node) => `matched by ${node.rule}`
  },
  intersections: {
    // for now, non-equal regex are naively intersected:
    // https://github.com/arktypeio/arktype/issues/853
    pattern: () => null
  }
});
class PatternNode extends _constraint.InternalPrimitiveConstraint {
  instance = new RegExp(this.rule, this.flags);
  expression = `${this.instance}`;
  traverseAllows = this.instance.test.bind(this.instance);
  compiledCondition = `${this.expression}.test(data)`;
  compiledNegation = `!${this.compiledCondition}`;
  impliedBasis = _registry.$ark.intrinsic.string.internal;
  reduceJsonSchema(base, ctx) {
    if (base.pattern) {
      return ctx.fallback.patternIntersection({
        code: "patternIntersection",
        base: base,
        pattern: this.rule
      });
    }
    base.pattern = this.rule;
    return base;
  }
}exports.PatternNode = PatternNode;
const Pattern = exports.Pattern = {
  implementation,
  Node: PatternNode
}; /* v9-69eee5b48d98d0bc */
