"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.DomainNode = exports.Domain = void 0;var _util = require("@ark/util");
var _disjoint = require("../shared/disjoint.js");
var _implement = require("../shared/implement.js");
var _basis = require("./basis.js");
const implementation = (0, _implement.implementNode)({
  kind: "domain",
  hasAssociatedError: true,
  collapsibleKey: "domain",
  keys: {
    domain: {},
    numberAllowsNaN: {}
  },
  normalize: (schema) => typeof schema === "string" ? { domain: schema } :
  (0, _util.hasKey)(schema, "numberAllowsNaN") && schema.domain !== "number" ?
  (0, _util.throwParseError)(Domain.writeBadAllowNanMessage(schema.domain)) :
  schema,
  applyConfig: (schema, config) => schema.numberAllowsNaN === undefined &&
  schema.domain === "number" &&
  config.numberAllowsNaN ?
  { ...schema, numberAllowsNaN: true } :
  schema,
  defaults: {
    description: (node) => _util.domainDescriptions[node.domain],
    actual: (data) => Number.isNaN(data) ? "NaN" : _util.domainDescriptions[(0, _util.domainOf)(data)]
  },
  intersections: {
    domain: (l, r) =>
    // since l === r is handled by default, remaining cases are disjoint
    // outside those including options like numberAllowsNaN
    l.domain === "number" && r.domain === "number" ?
    l.numberAllowsNaN ?
    r :
    l :
    _disjoint.Disjoint.init("domain", l, r)
  }
});
class DomainNode extends _basis.InternalBasis {
  requiresNaNCheck = this.domain === "number" && !this.numberAllowsNaN;
  traverseAllows = this.requiresNaNCheck ?
  (data) => typeof data === "number" && !Number.isNaN(data) :
  (data) => (0, _util.domainOf)(data) === this.domain;
  compiledCondition = this.domain === "object" ?
  `((typeof data === "object" && data !== null) || typeof data === "function")` :
  `typeof data === "${this.domain}"${this.requiresNaNCheck ? " && !Number.isNaN(data)" : ""}`;
  compiledNegation = this.domain === "object" ?
  `((typeof data !== "object" || data === null) && typeof data !== "function")` :
  `typeof data !== "${this.domain}"${this.requiresNaNCheck ? " || Number.isNaN(data)" : ""}`;
  expression = this.numberAllowsNaN ? "number | NaN" : this.domain;
  get nestableExpression() {
    return this.numberAllowsNaN ? `(${this.expression})` : this.expression;
  }
  get defaultShortDescription() {
    return _util.domainDescriptions[this.domain];
  }
  innerToJsonSchema(ctx) {
    if (this.domain === "bigint" || this.domain === "symbol") {
      return ctx.fallback.domain({
        code: "domain",
        base: {},
        domain: this.domain
      });
    }
    return {
      type: this.domain
    };
  }
}exports.DomainNode = DomainNode;
const Domain = exports.Domain = {
  implementation,
  Node: DomainNode,
  writeBadAllowNanMessage: (actual) => `numberAllowsNaN may only be specified with domain "number" (was ${actual})`
}; /* v9-69a256c9a4dab614 */
