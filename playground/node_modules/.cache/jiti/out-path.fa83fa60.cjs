"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.stringifyPath = exports.appendStringifiedKey = exports.ReadonlyPath = void 0;var _arrays = require("./arrays.js");
var _errors = require("./errors.js");
var _registry = require("./registry.js");
var _serialize = require("./serialize.js");
const appendStringifiedKey = (path, prop, ...[opts]) => {
  const stringifySymbol = opts?.stringifySymbol ?? _serialize.printable;
  let propAccessChain = path;
  switch (typeof prop) {
    case "string":
      propAccessChain =
      (0, _registry.isDotAccessible)(prop) ?
      path === "" ?
      prop :
      `${path}.${prop}` :
      `${path}[${JSON.stringify(prop)}]`;
      break;
    case "number":
      propAccessChain = `${path}[${prop}]`;
      break;
    case "symbol":
      propAccessChain = `${path}[${stringifySymbol(prop)}]`;
      break;
    default:
      if (opts?.stringifyNonKey)
      propAccessChain = `${path}[${opts.stringifyNonKey(prop)}]`;else
      {
        (0, _errors.throwParseError)(`${(0, _serialize.printable)(prop)} must be a PropertyKey or stringifyNonKey must be passed to options`);
      }
  }
  return propAccessChain;
};exports.appendStringifiedKey = appendStringifiedKey;
const stringifyPath = (path, ...opts) => path.reduce((s, k) => appendStringifiedKey(s, k, ...opts), "");exports.stringifyPath = stringifyPath;
class ReadonlyPath extends _arrays.ReadonlyArray {
  // alternate strategy for caching since the base object is frozen
  cache = {};
  constructor(...items) {
    super();
    this.push(...items);
  }
  toJSON() {
    if (this.cache.json)
    return this.cache.json;
    this.cache.json = [];
    for (let i = 0; i < this.length; i++) {
      this.cache.json.push(typeof this[i] === "symbol" ? (0, _serialize.printable)(this[i]) : this[i]);
    }
    return this.cache.json;
  }
  stringify() {
    if (this.cache.stringify)
    return this.cache.stringify;
    return this.cache.stringify = stringifyPath(this);
  }
  stringifyAncestors() {
    if (this.cache.stringifyAncestors)
    return this.cache.stringifyAncestors;
    let propString = "";
    const result = [propString];
    for (const path of this) {
      propString = appendStringifiedKey(propString, path);
      result.push(propString);
    }
    return this.cache.stringifyAncestors = result;
  }
}exports.ReadonlyPath = ReadonlyPath; /* v9-a4685e9197fe5eb1 */
