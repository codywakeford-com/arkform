"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeUnpairableComparatorMessage = exports.writeUnmatchedGroupCloseMessage = exports.writeUnclosedGroupMessage = exports.writeOpenRangeMessage = exports.writeMultipleLeftBoundsMessage = exports.minComparators = exports.maxComparators = exports.invertedComparators = exports.comparators = void 0;const minComparators = exports.minComparators = {
  ">": true,
  ">=": true
};
const maxComparators = exports.maxComparators = {
  "<": true,
  "<=": true
};
const comparators = exports.comparators = {
  ">": true,
  ">=": true,
  "<": true,
  "<=": true,
  "==": true
};
const invertedComparators = exports.invertedComparators = {
  "<": ">",
  ">": "<",
  "<=": ">=",
  ">=": "<=",
  "==": "=="
};
const writeUnmatchedGroupCloseMessage = (unscanned) => `Unmatched )${unscanned === "" ? "" : ` before ${unscanned}`}`;exports.writeUnmatchedGroupCloseMessage = writeUnmatchedGroupCloseMessage;
const writeUnclosedGroupMessage = (missingChar) => `Missing ${missingChar}`;exports.writeUnclosedGroupMessage = writeUnclosedGroupMessage;
const writeOpenRangeMessage = (min, comparator) => `Left bounds are only valid when paired with right bounds (try ...${comparator}${min})`;exports.writeOpenRangeMessage = writeOpenRangeMessage;
const writeUnpairableComparatorMessage = (comparator) => `Left-bounded expressions must specify their limits using < or <= (was ${comparator})`;exports.writeUnpairableComparatorMessage = writeUnpairableComparatorMessage;
const writeMultipleLeftBoundsMessage = (openLimit, openComparator, limit, comparator) => `An expression may have at most one left bound (parsed ${openLimit}${invertedComparators[openComparator]}, ${limit}${invertedComparators[comparator]})`;exports.writeMultipleLeftBoundsMessage = writeMultipleLeftBoundsMessage; /* v9-a680cba346fb9d4f */
