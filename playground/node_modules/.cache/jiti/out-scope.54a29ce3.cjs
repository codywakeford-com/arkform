"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeUnresolvableMessage = exports.writeNonSubmoduleDotMessage = exports.writeMissingSubmoduleAccessMessage = exports.writeDuplicateAliasError = exports.schemaScope = exports.rootSchemaScope = exports.rootSchema = exports.parseAsSchema = exports.node = exports.genericNode = exports.defineSchema = exports.SchemaScope = exports.BaseScope = void 0;var _util = require("@ark/util");
var _config = require("./config.js");
var _generic = require("./generic.js");
var _kinds = require("./kinds.js");
var _module = require("./module.js");
var _parse = require("./parse.js");
var _alias = require("./roots/alias.js");
var _compile = require("./shared/compile.js");
var _registry = require("./shared/registry.js");
var _traversal = require("./shared/traversal.js");
var _utils = require("./shared/utils.js");
const schemaBranchesOf = (schema) => (0, _util.isArray)(schema) ? schema :
"branches" in schema && (0, _util.isArray)(schema.branches) ? schema.branches :
undefined;
const throwMismatchedNodeRootError = (expected, actual) => (0, _util.throwParseError)(`Node of kind ${actual} is not valid as a ${expected} definition`);
const writeDuplicateAliasError = (alias) => `#${alias} duplicates public alias ${alias}`;exports.writeDuplicateAliasError = writeDuplicateAliasError;
const scopesByName = {};
_registry.$ark.ambient ??= {};
let rawUnknownUnion;
const rootScopeFnName = "function $";
const precompile = (references) => bindPrecompilation(references, precompileReferences(references));
const bindPrecompilation = (references, precompiler) => {
  const precompilation = precompiler.write(rootScopeFnName, 4);
  const compiledTraversals = precompiler.compile()();
  for (const node of references) {
    if (node.precompilation) {
      // if node has already been bound to another scope or anonymous type, don't rebind it
      continue;
    }
    node.traverseAllows =
    compiledTraversals[`${node.id}Allows`].bind(compiledTraversals);
    if (node.isRoot() && !node.allowsRequiresContext) {
      // if the reference doesn't require context, we can assign over
      // it directly to avoid having to initialize it
      node.allows = node.traverseAllows;
    }
    node.traverseApply =
    compiledTraversals[`${node.id}Apply`].bind(compiledTraversals);
    if (compiledTraversals[`${node.id}Optimistic`]) {
      ;
      node.traverseOptimistic =
      compiledTraversals[`${node.id}Optimistic`].bind(compiledTraversals);
    }
    node.precompilation = precompilation;
  }
};
const precompileReferences = (references) => new _compile.CompiledFunction().return(references.reduce((js, node) => {
  const allowsCompiler = new _compile.NodeCompiler({ kind: "Allows" }).indent();
  node.compile(allowsCompiler);
  const allowsJs = allowsCompiler.write(`${node.id}Allows`);
  const applyCompiler = new _compile.NodeCompiler({ kind: "Apply" }).indent();
  node.compile(applyCompiler);
  const applyJs = applyCompiler.write(`${node.id}Apply`);
  const result = `${js}${allowsJs},\n${applyJs},\n`;
  if (!node.hasKind("union"))
  return result;
  const optimisticCompiler = new _compile.NodeCompiler({
    kind: "Allows",
    optimistic: true
  }).indent();
  node.compile(optimisticCompiler);
  const optimisticJs = optimisticCompiler.write(`${node.id}Optimistic`);
  return `${result}${optimisticJs},\n`;
}, "{\n") + "}");
class BaseScope {
  config;
  resolvedConfig;
  name;
  get [_utils.arkKind]() {
    return "scope";
  }
  referencesById = {};
  references = [];
  resolutions = {};
  exportedNames = [];
  aliases = {};
  resolved = false;
  nodesByHash = {};
  intrinsic;
  constructor(
  /** The set of names defined at the root-level of the scope mapped to their
   * corresponding definitions.**/
  def, config) {
    this.config = (0, _config.mergeConfigs)(_registry.$ark.config, config);
    this.resolvedConfig = (0, _config.mergeConfigs)(_registry.$ark.resolvedConfig, config);
    this.name =
    this.resolvedConfig.name ??
    `anonymousScope${Object.keys(scopesByName).length}`;
    if (this.name in scopesByName)
    (0, _util.throwParseError)(`A Scope already named ${this.name} already exists`);
    scopesByName[this.name] = this;
    const aliasEntries = Object.entries(def).map((entry) => this.preparseOwnAliasEntry(...entry));
    for (const [k, v] of aliasEntries) {
      let name = k;
      if (k[0] === "#") {
        name = k.slice(1);
        if (name in this.aliases)
        (0, _util.throwParseError)(writeDuplicateAliasError(name));
        this.aliases[name] = v;
      } else
      {
        if (name in this.aliases)
        (0, _util.throwParseError)(writeDuplicateAliasError(k));
        this.aliases[name] = v;
        this.exportedNames.push(name);
      }
      if (!(0, _utils.hasArkKind)(v, "module") &&
      !(0, _utils.hasArkKind)(v, "generic") &&
      !(0, _util.isThunk)(v)) {
        const preparsed = this.preparseOwnDefinitionFormat(v, { alias: name });
        this.resolutions[name] =
        (0, _utils.hasArkKind)(preparsed, "root") ?
        this.bindReference(preparsed) :
        this.createParseContext(preparsed).id;
      }
    }
    // reduce union of all possible values reduces to unknown
    rawUnknownUnion ??= this.node("union", {
      branches: [
      "string",
      "number",
      "object",
      "bigint",
      "symbol",
      { unit: true },
      { unit: false },
      { unit: undefined },
      { unit: null }]

    }, { prereduced: true });
    this.nodesByHash[rawUnknownUnion.hash] = this.node("intersection", {}, { prereduced: true });
    this.intrinsic =
    _registry.$ark.intrinsic ?
    (0, _util.flatMorph)(_registry.$ark.intrinsic, (k, v) =>
    // don't include cyclic aliases from JSON scope
    k.startsWith("json") ? [] : [k, this.bindReference(v)])
    // intrinsic won't be available during bootstrapping,  so we lie
    // about the type here as an extrnal convenience
    : {};
  }
  cacheGetter(name, value) {
    Object.defineProperty(this, name, { value });
    return value;
  }
  get internal() {
    return this;
  }
  // json is populated when the scope is exported, so ensure it is populated
  // before allowing external access
  _json;
  get json() {
    if (!this._json)
    this.export();
    return this._json;
  }
  defineSchema(def) {
    return def;
  }
  generic = (...params) => {
    const $ = this;
    return (def, possibleHkt) => new _generic.GenericRoot(params, possibleHkt ? new _generic.LazyGenericBody(def) : def, $, $, possibleHkt ?? null);
  };
  units = (values, opts) => {
    const uniqueValues = [];
    for (const value of values)
    if (!uniqueValues.includes(value))
    uniqueValues.push(value);
    const branches = uniqueValues.map((unit) => this.node("unit", { unit }, opts));
    return this.node("union", branches, {
      ...opts,
      prereduced: true
    });
  };
  lazyResolutions = [];
  lazilyResolve(resolve, syntheticAlias) {
    const node = this.node("alias", {
      reference: syntheticAlias ?? "synthetic",
      resolve
    }, { prereduced: true });
    if (!this.resolved)
    this.lazyResolutions.push(node);
    return node;
  }
  schema = (schema, opts) => this.finalize(this.parseSchema(schema, opts));
  parseSchema = (schema, opts) => this.node((0, _parse.schemaKindOf)(schema), schema, opts);
  preparseNode(kinds, schema, opts) {
    let kind = typeof kinds === "string" ? kinds : (0, _parse.schemaKindOf)(schema, kinds);
    if ((0, _utils.isNode)(schema) && schema.kind === kind)
    return schema;
    if (kind === "alias" && !opts?.prereduced) {
      const { reference } = _alias.Alias.implementation.normalize(schema, this);
      if (reference.startsWith("$")) {
        const resolution = this.resolveRoot(reference.slice(1));
        schema = resolution;
        kind = resolution.kind;
      }
    } else
    if (kind === "union" && (0, _util.hasDomain)(schema, "object")) {
      const branches = schemaBranchesOf(schema);
      if (branches?.length === 1) {
        schema = branches[0];
        kind = (0, _parse.schemaKindOf)(schema);
      }
    }
    if ((0, _utils.isNode)(schema) && schema.kind === kind)
    return schema;
    const impl = _kinds.nodeImplementationsByKind[kind];
    const normalizedSchema = impl.normalize?.(schema, this) ?? schema;
    // check again after normalization in case a node is a valid collapsed
    // schema for the kind (e.g. sequence can collapse to element accepting a Node')
    if ((0, _utils.isNode)(normalizedSchema)) {
      return normalizedSchema.kind === kind ?
      normalizedSchema :
      throwMismatchedNodeRootError(kind, normalizedSchema.kind);
    }
    return {
      ...opts,
      $: this,
      kind,
      def: normalizedSchema,
      prefix: opts.alias ?? kind
    };
  }
  bindReference(reference) {
    let bound;
    if ((0, _utils.isNode)(reference)) {
      bound =
      reference.$ === this ?
      reference :
      new reference.constructor(reference.attachments, this);
    } else
    {
      bound =
      reference.$ === this ?
      reference :
      new _generic.GenericRoot(reference.params, reference.bodyDef, reference.$, this, reference.hkt);
    }
    if (!this.resolved) {
      // we're still parsing the scope itself, so defer compilation but
      // add the node as a reference
      Object.assign(this.referencesById, bound.referencesById);
    }
    return bound;
  }
  resolveRoot(name) {
    return this.maybeResolveRoot(name) ??
    (0, _util.throwParseError)(writeUnresolvableMessage(name));
  }
  maybeResolveRoot(name) {
    const result = this.maybeResolve(name);
    if ((0, _utils.hasArkKind)(result, "generic"))
    return;
    return result;
  }
  /** If name is a valid reference to a submodule alias, return its resolution  */
  maybeResolveSubalias(name) {
    return maybeResolveSubalias(this.aliases, name) ??
    maybeResolveSubalias(this.ambient, name);
  }
  get ambient() {
    return _registry.$ark.ambient;
  }
  maybeResolve(name) {
    const cached = this.resolutions[name];
    if (cached) {
      if (typeof cached !== "string")
      return this.bindReference(cached);
      const v = _parse.nodesByRegisteredId[cached];
      if ((0, _utils.hasArkKind)(v, "root"))
      return this.resolutions[name] = v;
      if ((0, _utils.hasArkKind)(v, "context")) {
        if (v.phase === "resolving") {
          return this.node("alias", { reference: `$${name}` }, { prereduced: true });
        }
        if (v.phase === "resolved") {
          return (0, _util.throwInternalError)(`Unexpected resolved context for was uncached by its scope: ${(0, _util.printable)(v)}`);
        }
        v.phase = "resolving";
        const node = this.bindReference(this.parseOwnDefinitionFormat(v.def, v));
        v.phase = "resolved";
        _parse.nodesByRegisteredId[node.id] = node;
        _parse.nodesByRegisteredId[v.id] = node;
        return this.resolutions[name] = node;
      }
      return (0, _util.throwInternalError)(`Unexpected nodesById entry for ${cached}: ${(0, _util.printable)(v)}`);
    }
    let def = this.aliases[name] ?? this.ambient?.[name];
    if (!def)
    return this.maybeResolveSubalias(name);
    def = this.normalizeRootScopeValue(def);
    if ((0, _utils.hasArkKind)(def, "generic"))
    return this.resolutions[name] = this.bindReference(def);
    if ((0, _utils.hasArkKind)(def, "module")) {
      if (!def.root)
      (0, _util.throwParseError)(writeMissingSubmoduleAccessMessage(name));
      return this.resolutions[name] = this.bindReference(def.root);
    }
    return this.resolutions[name] = this.parse(def, {
      alias: name
    });
  }
  createParseContext(input) {
    const id = input.id ?? (0, _parse.registerNodeId)(input.prefix);
    return _parse.nodesByRegisteredId[id] = Object.assign(input, {
      [_utils.arkKind]: "context",
      $: this,
      id,
      phase: "unresolved"
    });
  }
  traversal(root) {
    return new _traversal.Traversal(root, this.resolvedConfig);
  }
  import(...names) {
    return new _module.RootModule((0, _util.flatMorph)(this.export(...names), (alias, value) => [
    `#${alias}`,
    value]
    ));
  }
  precompilation;
  _exportedResolutions;
  _exports;
  export(...names) {
    if (!this._exports) {
      this._exports = {};
      for (const name of this.exportedNames) {
        const def = this.aliases[name];
        this._exports[name] =
        (0, _utils.hasArkKind)(def, "module") ?
        (0, _module.bindModule)(def, this) :
        bootstrapAliasReferences(this.maybeResolve(name));
      }
      // force node.resolution getter evaluation
      // eslint-disable-next-line @typescript-eslint/no-unused-expressions
      for (const node of this.lazyResolutions)
      node.resolution;
      this._exportedResolutions = resolutionsOfModule(this, this._exports);
      this._json = resolutionsToJson(this._exportedResolutions);
      Object.assign(this.resolutions, this._exportedResolutions);
      this.references = Object.values(this.referencesById);
      if (!this.resolvedConfig.jitless) {
        const precompiler = precompileReferences(this.references);
        this.precompilation = precompiler.write(rootScopeFnName, 4);
        bindPrecompilation(this.references, precompiler);
      }
      this.resolved = true;
    }
    const namesToExport = names.length ? names : this.exportedNames;
    return new _module.RootModule((0, _util.flatMorph)(namesToExport, (_, name) => [
    name,
    this._exports[name]]
    ));
  }
  resolve(name) {
    return this.export()[name];
  }
  node = (kinds, nodeSchema, opts = {}) => {
    const ctxOrNode = this.preparseNode(kinds, nodeSchema, opts);
    if ((0, _utils.isNode)(ctxOrNode))
    return this.bindReference(ctxOrNode);
    const ctx = this.createParseContext(ctxOrNode);
    const node = (0, _parse.parseNode)(ctx);
    const bound = this.bindReference(node);
    return _parse.nodesByRegisteredId[ctx.id] = bound;
  };
  parse = (def, opts = {}) => this.finalize(this.parseDefinition(def, opts));
  parseDefinition(def, opts = {}) {
    if ((0, _utils.hasArkKind)(def, "root"))
    return this.bindReference(def);
    const ctxInputOrNode = this.preparseOwnDefinitionFormat(def, opts);
    if ((0, _utils.hasArkKind)(ctxInputOrNode, "root"))
    return this.bindReference(ctxInputOrNode);
    const ctx = this.createParseContext(ctxInputOrNode);
    _parse.nodesByRegisteredId[ctx.id] = ctx;
    let node = this.bindReference(this.parseOwnDefinitionFormat(def, ctx));
    // if the node is recursive e.g. { box: "this" }, we need to make sure it
    // has the original id from context so that its references compile correctly
    if (node.isCyclic)
    node = (0, _parse.withId)(node, ctx.id);
    _parse.nodesByRegisteredId[ctx.id] = node;
    return node;
  }
  finalize(node) {
    bootstrapAliasReferences(node);
    if (!node.precompilation && !this.resolvedConfig.jitless)
    precompile(node.references);
    return node;
  }
}exports.BaseScope = BaseScope;
class SchemaScope extends BaseScope {
  parseOwnDefinitionFormat(def, ctx) {
    return (0, _parse.parseNode)(ctx);
  }
  preparseOwnDefinitionFormat(schema, opts) {
    return this.preparseNode((0, _parse.schemaKindOf)(schema), schema, opts);
  }
  preparseOwnAliasEntry(k, v) {
    return [k, v];
  }
  normalizeRootScopeValue(v) {
    return v;
  }
}exports.SchemaScope = SchemaScope;
const bootstrapAliasReferences = (resolution) => {
  const aliases = resolution.references.filter((node) => node.hasKind("alias"));
  for (const aliasNode of aliases) {
    Object.assign(aliasNode.referencesById, aliasNode.resolution.referencesById);
    for (const ref of resolution.references) {
      if (aliasNode.id in ref.referencesById)
      Object.assign(ref.referencesById, aliasNode.referencesById);
    }
  }
  return resolution;
};
const resolutionsToJson = (resolutions) => (0, _util.flatMorph)(resolutions, (k, v) => [
k,
(0, _utils.hasArkKind)(v, "root") || (0, _utils.hasArkKind)(v, "generic") ? v.json :
(0, _utils.hasArkKind)(v, "module") ? resolutionsToJson(v) :
(0, _util.throwInternalError)(`Unexpected resolution ${(0, _util.printable)(v)}`)]
);
const maybeResolveSubalias = (base, name) => {
  const dotIndex = name.indexOf(".");
  if (dotIndex === -1)
  return;
  const dotPrefix = name.slice(0, dotIndex);
  const prefixSchema = base[dotPrefix];
  // if the name includes ".", but the prefix is not an alias, it
  // might be something like a decimal literal, so just fall through to return
  if (prefixSchema === undefined)
  return;
  if (!(0, _utils.hasArkKind)(prefixSchema, "module"))
  return (0, _util.throwParseError)(writeNonSubmoduleDotMessage(dotPrefix));
  const subalias = name.slice(dotIndex + 1);
  const resolution = prefixSchema[subalias];
  if (resolution === undefined)
  return maybeResolveSubalias(prefixSchema, subalias);
  if ((0, _utils.hasArkKind)(resolution, "root") || (0, _utils.hasArkKind)(resolution, "generic"))
  return resolution;
  if ((0, _utils.hasArkKind)(resolution, "module")) {
    return resolution.root ??
    (0, _util.throwParseError)(writeMissingSubmoduleAccessMessage(name));
  }
  (0, _util.throwInternalError)(`Unexpected resolution for alias '${name}': ${(0, _util.printable)(resolution)}`);
};
const schemaScope = (aliases, config) => new SchemaScope(aliases, config);exports.schemaScope = schemaScope;
const rootSchemaScope = exports.rootSchemaScope = new SchemaScope({});
const parseAsSchema = (def, opts) => {
  try {
    return rootSchema(def, opts);
  }
  catch (e) {
    if (e instanceof _util.ParseError)
    return e;
    throw e;
  }
};exports.parseAsSchema = parseAsSchema;
const resolutionsOfModule = ($, typeSet) => {
  const result = {};
  for (const k in typeSet) {
    const v = typeSet[k];
    if ((0, _utils.hasArkKind)(v, "module")) {
      const innerResolutions = resolutionsOfModule($, v);
      const prefixedResolutions = (0, _util.flatMorph)(innerResolutions, (innerK, innerV) => [`${k}.${innerK}`, innerV]);
      Object.assign(result, prefixedResolutions);
    } else
    if ((0, _utils.hasArkKind)(v, "root") || (0, _utils.hasArkKind)(v, "generic"))
    result[k] = v;else

    (0, _util.throwInternalError)(`Unexpected scope resolution ${(0, _util.printable)(v)}`);
  }
  return result;
};
const writeUnresolvableMessage = (token) => `'${token}' is unresolvable`;exports.writeUnresolvableMessage = writeUnresolvableMessage;
const writeNonSubmoduleDotMessage = (name) => `'${name}' must reference a module to be accessed using dot syntax`;exports.writeNonSubmoduleDotMessage = writeNonSubmoduleDotMessage;
const writeMissingSubmoduleAccessMessage = (name) => `Reference to submodule '${name}' must specify an alias`;
// ensure the scope is resolved so JIT will be applied to future types
exports.writeMissingSubmoduleAccessMessage = writeMissingSubmoduleAccessMessage;rootSchemaScope.export();
const rootSchema = exports.rootSchema = rootSchemaScope.schema;
const node = exports.node = rootSchemaScope.node;
const defineSchema = exports.defineSchema = rootSchemaScope.defineSchema;
const genericNode = exports.genericNode = rootSchemaScope.generic; /* v9-8c640a6b2d0fc065 */
