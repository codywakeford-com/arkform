"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeInvalidLimitMessage = exports.writeIncompatibleRangeMessage = exports.parseRightBound = exports.parseBound = exports.getBoundKinds = exports.comparatorStartChars = void 0;var _schema = require("@ark/schema");
var _util = require("@ark/util");
var _shared = require("../../reduce/shared.js");
var _date = require("../operand/date.js");
const parseBound = (s, start) => {
  const comparator = shiftComparator(s, start);
  if (s.root.hasKind("unit")) {
    if (typeof s.root.unit === "number") {
      s.reduceLeftBound(s.root.unit, comparator);
      s.unsetRoot();
      return;
    }
    if (s.root.unit instanceof Date) {
      const literal = `d'${s.root.description ?? s.root.unit.toISOString()}'`;
      s.unsetRoot();
      s.reduceLeftBound(literal, comparator);
      return;
    }
  }
  return parseRightBound(s, comparator);
};exports.parseBound = parseBound;
const comparatorStartChars = exports.comparatorStartChars = {
  "<": 1,
  ">": 1,
  "=": 1
};
const shiftComparator = (s, start) => s.scanner.lookaheadIs("=") ?
`${start}${s.scanner.shift()}` :
start;
const writeIncompatibleRangeMessage = (l, r) => `Bound kinds ${l} and ${r} are incompatible`;exports.writeIncompatibleRangeMessage = writeIncompatibleRangeMessage;
const getBoundKinds = (comparator, limit, root, boundKind) => {
  if (root.extends(_schema.$ark.intrinsic.number)) {
    if (typeof limit !== "number") {
      return (0, _util.throwParseError)(writeInvalidLimitMessage(comparator, limit, boundKind));
    }
    return comparator === "==" ? ["min", "max"] :
    comparator[0] === ">" ? ["min"] :
    ["max"];
  }
  if (root.extends(_schema.$ark.intrinsic.lengthBoundable)) {
    if (typeof limit !== "number") {
      return (0, _util.throwParseError)(writeInvalidLimitMessage(comparator, limit, boundKind));
    }
    return comparator === "==" ? ["exactLength"] :
    comparator[0] === ">" ? ["minLength"] :
    ["maxLength"];
  }
  if (root.extends(_schema.$ark.intrinsic.Date)) {
    // allow either numeric or date limits
    return comparator === "==" ? ["after", "before"] :
    comparator[0] === ">" ? ["after"] :
    ["before"];
  }
  return (0, _util.throwParseError)((0, _schema.writeUnboundableMessage)(root.expression));
};exports.getBoundKinds = getBoundKinds;
const openLeftBoundToRoot = (leftBound) => ({
  rule: (0, _date.isDateLiteral)(leftBound.limit) ?
  (0, _date.extractDateLiteralSource)(leftBound.limit) :
  leftBound.limit,
  exclusive: leftBound.comparator.length === 1
});
const parseRightBound = (s, comparator) => {
  // store the node that will be bounded
  const previousRoot = s.unsetRoot();
  const previousScannerIndex = s.scanner.location;
  s.parseOperand();
  const limitNode = s.unsetRoot();
  // after parsing the next operand, use the locations to get the
  // token from which it was parsed
  const limitToken = s.scanner.sliceChars(previousScannerIndex, s.scanner.location);
  s.root = previousRoot;
  if (!limitNode.hasKind("unit") ||
  typeof limitNode.unit !== "number" && !(limitNode.unit instanceof Date))
  return s.error(writeInvalidLimitMessage(comparator, limitToken, "right"));
  const limit = limitNode.unit;
  // apply the newly-parsed right bound
  const exclusive = comparator.length === 1;
  const boundKinds = getBoundKinds(comparator, typeof limit === "number" ? limit : limitToken, previousRoot, "right");
  for (const kind of boundKinds) {
    s.constrainRoot(kind, comparator === "==" ? { rule: limit } : { rule: limit, exclusive });
  }
  if (!s.branches.leftBound)
  return;
  // if there's an open left bound, perform additional validation and apply it
  if (!(0, _util.isKeyOf)(comparator, _shared.maxComparators))
  return s.error((0, _shared.writeUnpairableComparatorMessage)(comparator));
  const lowerBoundKind = getBoundKinds(s.branches.leftBound.comparator, s.branches.leftBound.limit, previousRoot, "left");
  s.constrainRoot(lowerBoundKind[0], openLeftBoundToRoot(s.branches.leftBound));
  s.branches.leftBound = null;
};exports.parseRightBound = parseRightBound;
const writeInvalidLimitMessage = (comparator, limit, boundKind) => `Comparator ${boundKind === "left" ? _shared.invertedComparators[comparator] : comparator} must be ${boundKind === "left" ? "preceded" : "followed"} by a corresponding literal (was ${limit})`;exports.writeInvalidLimitMessage = writeInvalidLimitMessage; /* v9-36bb072bf7c97f54 */
