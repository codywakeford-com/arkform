"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.scope = exports.Scope = exports.InternalScope = exports.$arkTypeRegistry = void 0;var _schema = require("@ark/schema");
var _util = require("@ark/util");
var _generic = require("./generic.js");
var _match = require("./match.js");
var _validate = require("./parser/ast/validate.js");
var _definition = require("./parser/definition.js");
var _scanner = require("./parser/shift/scanner.js");
var _type = require("./type.js");
const $arkTypeRegistry = exports.$arkTypeRegistry = _schema.$ark;
class InternalScope extends _schema.BaseScope {
  get ambientAttachments() {
    if (!$arkTypeRegistry.typeAttachments)
    return;
    return this.cacheGetter("ambientAttachments", (0, _util.flatMorph)($arkTypeRegistry.typeAttachments, (k, v) => [
    k,
    this.bindReference(v)]
    ));
  }
  preparseOwnAliasEntry(alias, def) {
    const firstParamIndex = alias.indexOf("<");
    if (firstParamIndex === -1) {
      if ((0, _schema.hasArkKind)(def, "module") || (0, _schema.hasArkKind)(def, "generic"))
      return [alias, def];
      const qualifiedName = this.name === "ark" ? alias :
      alias === "root" ? this.name :
      `${this.name}.${alias}`;
      const config = this.resolvedConfig.keywords?.[qualifiedName];
      if (config)
      def = [def, "@", config];
      return [alias, def];
    }
    if (alias.at(-1) !== ">") {
      (0, _util.throwParseError)(`'>' must be the last character of a generic declaration in a scope`);
    }
    const name = alias.slice(0, firstParamIndex);
    const paramString = alias.slice(firstParamIndex + 1, -1);
    return [
    name,
    // use a thunk definition for the generic so that we can parse
    // constraints within the current scope
    () => {
      const params = this.parseGenericParams(paramString, { alias: name });
      const generic = (0, _schema.parseGeneric)(params, def, this);
      return generic;
    }];

  }
  parseGenericParams(def, opts) {
    return (0, _generic.parseGenericParamName)(new _scanner.ArkTypeScanner(def), [], this.createParseContext({
      ...opts,
      def,
      prefix: "generic"
    }));
  }
  normalizeRootScopeValue(resolution) {
    if ((0, _util.isThunk)(resolution) && !(0, _schema.hasArkKind)(resolution, "generic"))
    return resolution();
    return resolution;
  }
  preparseOwnDefinitionFormat(def, opts) {
    return {
      ...opts,
      def,
      prefix: opts.alias ?? "type"
    };
  }
  parseOwnDefinitionFormat(def, ctx) {
    const isScopeAlias = ctx.alias && ctx.alias in this.aliases;
    // if the definition being parsed is not a scope alias and is not a
    // generic instantiation (i.e. opts don't include args), add `this` as a resolution.
    // if we're parsing a nested string, ctx.args will have already been set
    if (!isScopeAlias && !ctx.args)
    ctx.args = { this: ctx.id };
    const result = (0, _definition.parseInnerDefinition)(def, ctx);
    if ((0, _util.isArray)(result)) {
      if (result[1] === "=")
      return (0, _util.throwParseError)(_validate.shallowDefaultableMessage);
      if (result[1] === "?")
      return (0, _util.throwParseError)(_validate.shallowOptionalMessage);
    }
    return result;
  }
  unit = (value) => this.units([value]);
  valueOf = (tsEnum) => this.units((0, _util.enumValues)(tsEnum));
  enumerated = (...values) => this.units(values);
  instanceOf = (ctor) => this.node("proto", { proto: ctor }, { prereduced: true });
  or = (...defs) => this.schema(defs.map((def) => this.parse(def)));
  and = (...defs) => defs.reduce((node, def) => node.and(this.parse(def)), this.intrinsic.unknown);
  merge = (...defs) => defs.reduce((node, def) => node.merge(this.parse(def)), this.intrinsic.object);
  pipe = (...morphs) => this.intrinsic.unknown.pipe(...morphs);
  match = new _match.InternalMatchParser(this);
  declare = () => ({
    type: this.type
  });
  define(def) {
    return def;
  }
  type = new _type.InternalTypeParser(this);
  static scope = (def, config = {}) => new InternalScope(def, config);
  static module = (def, config = {}) => this.scope(def, config).export();
}exports.InternalScope = InternalScope;
const scope = exports.scope = Object.assign(InternalScope.scope, {
  define: (def) => def
});
const Scope = exports.Scope = InternalScope; /* v9-161fbd8fdd3008a2 */
