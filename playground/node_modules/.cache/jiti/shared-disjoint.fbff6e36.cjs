"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeUnsatisfiableExpressionError = exports.Disjoint = void 0;var _util = require("@ark/util");
var _registry = require("./registry.js");
var _utils = require("./utils.js");
class Disjoint extends Array {
  static init(kind, l, r, ctx) {
    return new Disjoint({
      kind,
      l,
      r,
      path: ctx?.path ?? [],
      optional: ctx?.optional ?? false
    });
  }
  add(kind, l, r, ctx) {
    this.push({
      kind,
      l,
      r,
      path: ctx?.path ?? [],
      optional: ctx?.optional ?? false
    });
    return this;
  }
  get summary() {
    return this.describeReasons();
  }
  describeReasons() {
    if (this.length === 1) {
      const { path, l, r } = this[0];
      const pathString = (0, _util.stringifyPath)(path);
      return writeUnsatisfiableExpressionError(`Intersection${pathString && ` at ${pathString}`} of ${describeReasons(l, r)}`);
    }
    return `The following intersections result in unsatisfiable types:\n• ${this.map(({ path, l, r }) => `${path}: ${describeReasons(l, r)}`).join("\n• ")}`;
  }
  throw() {
    return (0, _util.throwParseError)(this.describeReasons());
  }
  invert() {
    const result = this.map((entry) => ({
      ...entry,
      l: entry.r,
      r: entry.l
    }));
    // Workaround for Static Hermes, which doesn't preserve the Array subclass here
    // https://github.com/arktypeio/arktype/issues/1027
    if (!(result instanceof Disjoint))
    return new Disjoint(...result);
    return result;
  }
  withPrefixKey(key, kind) {
    return this.map((entry) => ({
      ...entry,
      path: [key, ...entry.path],
      optional: entry.optional || kind === "optional"
    }));
  }
  toNeverIfDisjoint() {
    return _registry.$ark.intrinsic.never;
  }
}exports.Disjoint = Disjoint;
const describeReasons = (l, r) => `${describeReason(l)} and ${describeReason(r)}`;
const describeReason = (value) => (0, _utils.isNode)(value) ? value.expression :
(0, _util.isArray)(value) ? value.map(describeReason).join(" | ") || "never" :
String(value);
const writeUnsatisfiableExpressionError = (expression) => `${expression} results in an unsatisfiable type`;exports.writeUnsatisfiableExpressionError = writeUnsatisfiableExpressionError; /* v9-99cb04d8de000b2d */
