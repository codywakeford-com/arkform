"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.Type = exports.InternalTypeParser = void 0;var _schema = require("@ark/schema");
var _util = require("@ark/util");
class InternalTypeParser extends _util.Callable {
  constructor($) {
    const attach = Object.assign({
      errors: _schema.ArkErrors,
      hkt: _util.Hkt,
      $: $,
      raw: $.parse,
      module: $.constructor.module,
      scope: $.constructor.scope,
      define: $.define,
      match: $.match,
      generic: $.generic,
      schema: $.schema,
      // this won't be defined during bootstrapping, but externally always will be
      keywords: $.ambient,
      unit: $.unit,
      enumerated: $.enumerated,
      instanceOf: $.instanceOf,
      valueOf: $.valueOf,
      or: $.or,
      and: $.and,
      merge: $.merge,
      pipe: $.pipe
    },
    // also won't be defined during bootstrapping
    $.ambientAttachments);
    super((...args) => {
      if (args.length === 1) {
        // treat as a simple definition
        return $.parse(args[0]);
      }
      if (args.length === 2 &&
      typeof args[0] === "string" &&
      args[0][0] === "<" &&
      args[0].at(-1) === ">") {
        // if there are exactly two args, the first of which looks like <${string}>,
        // treat as a generic
        const paramString = args[0].slice(1, -1);
        const params = $.parseGenericParams(paramString, {});
        return new _schema.GenericRoot(params, args[1], $, $, null);
      }
      // otherwise, treat as a tuple expression. technically, this also allows
      // non-expression tuple definitions to be parsed, but it's not a supported
      // part of the API as specified by the associated types
      return $.parse(args);
    }, {
      bind: $,
      attach
    });
  }
}exports.InternalTypeParser = InternalTypeParser;
const Type = exports.Type = _schema.BaseRoot; /* v9-d2aa6f7c1fd7a6d3 */
