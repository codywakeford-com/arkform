"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.writeMalformedFunctionalExpressionMessage = exports.writeInvalidConstructorMessage = exports.parseNarrowTuple = exports.parseMorphTuple = exports.parseKeyOfTuple = exports.maybeParseTupleExpression = void 0;var _schema = require("@ark/schema");
var _util = require("@ark/util");
var _validate = require("./ast/validate.js");
var _unenclosed = require("./shift/operand/unenclosed.js");
const maybeParseTupleExpression = (def, ctx) => isIndexZeroExpression(def) ? indexZeroParsers[def[0]](def, ctx) :
isIndexOneExpression(def) ? indexOneParsers[def[1]](def, ctx) :
null;exports.maybeParseTupleExpression = maybeParseTupleExpression;
const parseKeyOfTuple = (def, ctx) => ctx.$.parseOwnDefinitionFormat(def[1], ctx).keyof();exports.parseKeyOfTuple = parseKeyOfTuple;
const parseBranchTuple = (def, ctx) => {
  if (def[2] === undefined)
  return (0, _util.throwParseError)((0, _unenclosed.writeMissingRightOperandMessage)(def[1], ""));
  const l = ctx.$.parseOwnDefinitionFormat(def[0], ctx);
  const r = ctx.$.parseOwnDefinitionFormat(def[2], ctx);
  if (def[1] === "|")
  return ctx.$.node("union", { branches: [l, r] });
  const result = def[1] === "&" ?
  (0, _schema.intersectNodesRoot)(l, r, ctx.$) :
  (0, _schema.pipeNodesRoot)(l, r, ctx.$);
  if (result instanceof _schema.Disjoint)
  return result.throw();
  return result;
};
const parseArrayTuple = (def, ctx) => ctx.$.parseOwnDefinitionFormat(def[0], ctx).array();
const parseMorphTuple = (def, ctx) => {
  if (typeof def[2] !== "function") {
    return (0, _util.throwParseError)(writeMalformedFunctionalExpressionMessage("=>", def[2]));
  }
  return ctx.$.parseOwnDefinitionFormat(def[0], ctx).pipe(def[2]);
};exports.parseMorphTuple = parseMorphTuple;
const writeMalformedFunctionalExpressionMessage = (operator, value) => `${operator === ":" ? "Narrow" : "Morph"} expression requires a function following '${operator}' (was ${typeof value})`;exports.writeMalformedFunctionalExpressionMessage = writeMalformedFunctionalExpressionMessage;
const parseNarrowTuple = (def, ctx) => {
  if (typeof def[2] !== "function") {
    return (0, _util.throwParseError)(writeMalformedFunctionalExpressionMessage(":", def[2]));
  }
  return ctx.$.parseOwnDefinitionFormat(def[0], ctx).constrain("predicate", def[2]);
};exports.parseNarrowTuple = parseNarrowTuple;
const parseAttributeTuple = (def, ctx) => ctx.$.parseOwnDefinitionFormat(def[0], ctx).configureReferences(def[2], "shallow");
const defineIndexOneParsers = (parsers) => parsers;
const postfixParsers = defineIndexOneParsers({
  "[]": parseArrayTuple,
  "?": () => (0, _util.throwParseError)(_validate.shallowOptionalMessage)
});
const infixParsers = defineIndexOneParsers({
  "|": parseBranchTuple,
  "&": parseBranchTuple,
  ":": parseNarrowTuple,
  "=>": parseMorphTuple,
  "|>": parseBranchTuple,
  "@": parseAttributeTuple,
  // since object and tuple literals parse there via `parseProperty`,
  // they must be shallow if parsed directly as a tuple expression
  "=": () => (0, _util.throwParseError)(_validate.shallowDefaultableMessage)
});
const indexOneParsers = { ...postfixParsers, ...infixParsers };
const isIndexOneExpression = (def) => indexOneParsers[def[1]] !== undefined;
const defineIndexZeroParsers = (parsers) => parsers;
const indexZeroParsers = defineIndexZeroParsers({
  keyof: parseKeyOfTuple,
  instanceof: (def, ctx) => {
    if (typeof def[1] !== "function") {
      return (0, _util.throwParseError)(writeInvalidConstructorMessage((0, _util.objectKindOrDomainOf)(def[1])));
    }
    const branches = def.
    slice(1).
    map((ctor) => typeof ctor === "function" ?
    ctx.$.node("proto", { proto: ctor }) :
    (0, _util.throwParseError)(writeInvalidConstructorMessage((0, _util.objectKindOrDomainOf)(ctor))));
    return branches.length === 1 ?
    branches[0] :
    ctx.$.node("union", { branches });
  },
  "===": (def, ctx) => ctx.$.units(def.slice(1))
});
const isIndexZeroExpression = (def) => indexZeroParsers[def[0]] !== undefined;
const writeInvalidConstructorMessage = (actual) => `Expected a constructor following 'instanceof' operator (was ${actual})`;exports.writeInvalidConstructorMessage = writeInvalidConstructorMessage; /* v9-54a558171bcbd642 */
